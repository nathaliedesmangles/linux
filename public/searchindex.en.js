var relearn_searchindex = [
  {
    "breadcrumb": "",
    "content": "Pondération : 2-2-2\nDescription du cours :\nLinux est le système d’exploitation qui constitue la colonne vertébrale des entreprises les plus puissantes et les plus innovantes au monde. Dès lors, l’étudiante ou l’étudiant sera initié aux principes de base des systèmes d’exploitation libre (Linux) et à l’installation et l’exploitation d’une distribution libre de Linux (p. ex. Fedora, Ubuntu, AlmaLinux, OpenSource).\nPour cela, l’étudiant ou l’étudiante devra exploiter l’interface graphique et la puissance de la ligne de commande pour gérer une station de travail, explorer les systèmes de fichiers et le partitionnement des disques, gérer les processus, l’automatisation des tâches et la programmation de scripts shell.\nObjectifs du cours : Effectuer l’installation et la gestion d’ordinateurs.",
    "description": "Pondération : 2-2-2\nDescription du cours :\nLinux est le système d’exploitation qui constitue la colonne vertébrale des entreprises les plus puissantes et les plus innovantes au monde. Dès lors, l’étudiante ou l’étudiant sera initié aux principes de base des systèmes d’exploitation libre (Linux) et à l’installation et l’exploitation d’une distribution libre de Linux (p. ex. Fedora, Ubuntu, AlmaLinux, OpenSource).",
    "tags": [],
    "title": "420-ZG4-MO Système d’exploitation Linux",
    "uri": "/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "Plan de la leçon Présentation du cours (plan de cours).\nPondération. Objectifs. Contexte d’apprentissage et méthodes pédagogiques. Evaluations formatives. Évaluations sommatives. Politiques institutionnelles (absences, retards, plagiat, etc.). Règlements en classe et hors classe. Théorie :\nGénéralités sur le système d’exploitation Linux. Atelier :\nInstallation de Linux sur une machine virtuelle.",
    "description": "Plan de la leçon Présentation du cours (plan de cours).\nPondération. Objectifs. Contexte d’apprentissage et méthodes pédagogiques. Evaluations formatives. Évaluations sommatives. Politiques institutionnelles (absences, retards, plagiat, etc.). Règlements en classe et hors classe. Théorie :\nGénéralités sur le système d’exploitation Linux. Atelier :\nInstallation de Linux sur une machine virtuelle.",
    "tags": [],
    "title": "Introduction à Linux",
    "uri": "/semaine1/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Introduction à Linux",
    "content": "Qu’est-ce qu’un système d’exploitation? Un système d’exploitation (SE) est un logiciel essentiel qui agit comme un intermédiaire entre l’utilisateur et le matériel de l’ordinateur. Il gère les ressources matérielles et logicielles de l’ordinateur et fournit des services communs pour les programmes informatiques. Voici quelques-unes de ses principales fonctions:\nGestion des ressources matérielles: Le système d’exploitation contrôle et coordonne l’utilisation du processeur, de la mémoire, des périphériques de stockage, et des périphériques d’entrée/sortie comme le clavier, la souris et l’écran.\nGestion des fichiers: Il organise les données en fichiers et dossiers, permettant aux utilisateurs de stocker, récupérer et manipuler des informations de manière efficace.\nGestion des processus: Le système d’exploitation gère l’exécution des programmes, en allouant du temps processeur et en assurant que les tâches s’exécutent sans conflit.\nInterface utilisateur: Il fournit une interface utilisateur, qui peut être en ligne de commande (CLI) ou graphique (GUI), permettant aux utilisateurs d’interagir facilement avec l’ordinateur.\nSécurité et gestion des utilisateurs: Le système d’exploitation protège les données et les ressources de l’ordinateur contre les accès non autorisés et permet la gestion des comptes utilisateurs.\nExemples de systèmes d’exploitation Windows: Développé par Microsoft, c’est l’un des systèmes d’exploitation les plus utilisés dans le monde. macOS: Développé par Apple, il est utilisé sur les ordinateurs Mac. Linux: Un système d’exploitation open-source utilisé principalement par les développeurs et les serveurs. Android: Utilisé principalement sur les smartphones et les tablettes. iOS: Le système d’exploitation d’Apple pour ses appareils mobiles comme l’iPhone et l’iPad. Pourquoi est-ce important? Le système d’exploitation est crucial car il permet à l’utilisateur d’exploiter pleinement les capacités de l’ordinateur sans avoir à gérer directement les complexités matérielles. Il offre une plateforme stable et sécurisée pour exécuter des applications et effectuer des tâches quotidiennes.\nQu’est-ce que Linux ? Définition\rLinux est un système d’exploitation puissant et flexible qui offre de nombreux avantages, notamment en termes de sécurité, de stabilité, et de personnalisation.\nQue ce soit pour un usage personnel, professionnel, ou pour des serveurs, Linux est une option solide et fiable.\nUn peu d’histoire 1991 : Créé par Linus Torvalds et est basé sur le système Unix. 1992 : Le noyau Linux a été re-licencié sous la licence publique générale GNU GPL (GNU’s Not Unix General Public Licence), ce qui a renforcé son statut de logiciel libre. 1994 : La version 1.0 du noyau Linux a été publiée, marquant une étape importante dans son développement. Depuis sa création, Linux est devenu l’un des systèmes d’exploitation les plus populaires, notamment pour les serveurs, les superordinateurs, et les appareils embarqués.\nCaractéristiques principales Open Source : Le code source de Linux est disponible gratuitement, permettant aux utilisateurs de le modifier et de le distribuer. Sécurité : Linux est réputé pour sa robustesse et sa sécurité. Les mises à jour régulières et la communauté active contribuent à maintenir un haut niveau de sécurité. Stabilité : Linux est connu pour sa stabilité et sa capacité à fonctionner pendant de longues périodes sans nécessiter de redémarrage. Personnalisation : Les utilisateurs peuvent personnaliser leur environnement Linux selon leurs besoins, grâce à une multitude de distributions et d’outils disponibles. Distributions Linux Définition\rUne distribution Linux est une version de Linux qui inclut le noyau Linux ainsi que divers logiciels et outils.\nVoici quelques-unes des distributions les plus populaires :\nUbuntu : Connue pour sa convivialité et son support communautaire.\nSite d’Ubuntu Fedora : Souvent utilisée par les développeurs et les administrateurs système.\nSite de Fedora Red Hat : L’une des premières distributions commerciales de Linux. Elle est particulièrement populaire dans les environnements d’entreprise.\nSite de Red Hat Debian : Réputée pour sa stabilité et sa large collection de logiciels.\nsite de Debian Arch Linux : Appréciée par les utilisateurs avancés pour sa flexibilité et sa simplicité.\nSite d’Arch Linux Utilisations de Linux Serveurs : Linux est largement utilisé pour les serveurs web, les serveurs de bases de données, et les serveurs de fichiers en raison de sa fiabilité et de sa sécurité. Superordinateurs : La majorité des superordinateurs dans le monde fonctionnent sous Linux. Appareils embarqués : De nombreux appareils, tels que les routeurs, les téléviseurs intelligents, et les smartphones (via Android), utilisent Linux. Postes de travail : Bien que moins courant que Windows ou macOS, Linux est utilisé par de nombreux développeurs et professionnels de l’informatique pour ses capacités de personnalisation et ses outils puissants. Répartition des SE chez les développeurs Répartition des systèmes d’exploitation pour le développement de logiciels dans le monde de 2018 à 2023\nAvantages Inconvénients Très souvent le même environnement que la machine de production (surtout pour la portion serveur d’une application) Accès très limité aux outils Microsoft : pas de Visual Studio, seulement VS Code et un support minimal pour C# Très facile d’installer des nouveaux outils de développement : $ dnf install nodejs $ dnf install nodejs Une bonne console (ligne de commande) est souvent un bon dépanneur pour un développeur (p.ex. les messages d’erreur sont souvent plus explicites à la ligne de commande que dans l’IDE) Plus facile d’automatiser des tâches de compilation et de tests Systèmes plus légers qui laissent la place aux outils de développement (p.ex. mon Linux prend moins de 1Go de mémoire, alors le reste est pour les outils, VM, etc.). Dans le cours Android p.ex., l’environnement de développement prend 15Go de mémoire (pour l’IDE + deux émulateurs de téléphone). Part de marché des SE pour les serveurs Part de marché des systèmes d’exploitation pour les serveurs",
    "description": "Qu’est-ce qu’un système d’exploitation? Un système d’exploitation (SE) est un logiciel essentiel qui agit comme un intermédiaire entre l’utilisateur et le matériel de l’ordinateur. Il gère les ressources matérielles et logicielles de l’ordinateur et fournit des services communs pour les programmes informatiques. Voici quelques-unes de ses principales fonctions:\nGestion des ressources matérielles: Le système d’exploitation contrôle et coordonne l’utilisation du processeur, de la mémoire, des périphériques de stockage, et des périphériques d’entrée/sortie comme le clavier, la souris et l’écran.",
    "tags": [],
    "title": "Qu'est-ce que Linux ?",
    "uri": "/semaine1/cours/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Introduction à Linux",
    "content": "Objectifs Installation du logiciel de virtualisation VMware workstation Pro. Création d’une machine virtuelle (VM). Installation de Linux sur la VM. Prérequis pour l’atelier Avoir Windows 11 installé sur votre disque SSD (sur une seule partition). Télécharger un logiciel de virtualisation tel que VMWare Workstation Pro 17. Télécharger la dernière version d’Almalinux (janvier 2025 c’est la version 9.5). Rappels (Cours ZE5 Virtualisation) VMWare permet d’installer différents systèmes d’exploitation sur une même machine. Le nombre de machines virtuelles (VM) que l’on peut installer dépend de la puissance en terme de CPU et de mémoire de la machine hôte. La machine hôte est celle qui héberge les machines virtuelles aussi appelées les invités. La machine hôte peut être Windows ou Linux et les invités peuvent être une grande variété de systèmes d’exploitation. Format de la remise Attention\rVous devrez prendre des captures d’écran de vos installations. Pour plus de détails, voir les documents ci-dessous:.\nAtelier Étape 1: Réinstallation de Windows Utiliser la procédure obtenue dans le cours 420-ZC5-MO de la session d’automne.\nAttention\rVous devez installer Windows 11 et sur une seule partition.\nÉtape 2: Téléchargement et installation de VMWare sur la machine hôte (votre SSD Windows) Guide - Téléchargement WMWare\nGuide - Installation de VMWare\nÉtape 3: Création d’une VM et installation d’Almalinux Télécharger l’image d’Almalinux Site Almalinux\nNote\rChoisir AlmaLinux OS 9.5 DVD ISO\nVous obtiendrez le fichier AlmaLinux-9.5-x86_64-dvd.iso\nCréer une VM pour y installer Almalinux Attention\rNe pas sauvegarder le fichier .iso sur OneDrive, ni dans le répertoire Téléchargements (Downloads), Sauvegardez le sur votre disque dur (en général c’est le lecteur C:).\nGuide - Création d’une VM Almalinux\nEn cas de problème Cas #1: Il arrive parfois que le serveur X ne démarre pas dans le temps imparti, ce qui force l’installation à basculer en mode texte. Vous le résolvez en augmentant le délai avec inst.xtimeout=180 en début d’installation.\nPour résoudre le problème:\nmenu installation - choisir troubleshooting touche tab ajouter inst.xtimeout=valeur en seconde en bas ( comme l’image ci bas) Cas #2: Si le processus d’installation exécute le Check et que c’est très long, il suffit d’appuyer plusieurs fois sur la touche Esc pour sauter la vérification et poursuivre l’installation.\nCas #3: Sur certains postes/SSD, la configuration ci-dessous règle les problèmes encourus pendant l’installation d’Almalinux.\nConfiguration de la VM:\n40 Gb au lieu de 20 Gb 4096 en mémoire 1 processeur et 4 Coeurs",
    "description": "Objectifs Installation du logiciel de virtualisation VMware workstation Pro. Création d’une machine virtuelle (VM). Installation de Linux sur la VM. Prérequis pour l’atelier Avoir Windows 11 installé sur votre disque SSD (sur une seule partition). Télécharger un logiciel de virtualisation tel que VMWare Workstation Pro 17. Télécharger la dernière version d’Almalinux (janvier 2025 c’est la version 9.5). Rappels (Cours ZE5 Virtualisation) VMWare permet d’installer différents systèmes d’exploitation sur une même machine. Le nombre de machines virtuelles (VM) que l’on peut installer dépend de la puissance en terme de CPU et de mémoire de la machine hôte. La machine hôte est celle qui héberge les machines virtuelles aussi appelées les invités. La machine hôte peut être Windows ou Linux et les invités peuvent être une grande variété de systèmes d’exploitation. Format de la remise Attention\rVous devrez prendre des captures d’écran de vos installations. Pour plus de détails, voir les documents ci-dessous:.",
    "tags": [],
    "title": "ATELIER #1: Installation de Linux sur une VM",
    "uri": "/semaine1/atelier/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "Plan de la leçon Théorie :\nLe système de fichiers de Linux. Le Shell Bash. La ligne de commandes. Les commandes de base. Introduction à VIM. Atelier :\nUtilisation des commandes de base et Vim.",
    "description": "Plan de la leçon Théorie :\nLe système de fichiers de Linux. Le Shell Bash. La ligne de commandes. Les commandes de base. Introduction à VIM. Atelier :\nUtilisation des commandes de base et Vim.",
    "tags": [],
    "title": "Système de fichiers, Shell, commandes de base, Vim",
    "uri": "/semaine2/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Système de fichiers, Shell, commandes de base, Vim",
    "content": "La structure du système de fichiers Linux est hiérarchique et organisée sous la forme d’un arbre inversé, où la racine (root) est représentée par /. Tous les fichiers et répertoires sont situés sous cette racine.\nLa structure du système de fichiers Linux est conçue pour être logique et organisée, facilitant ainsi la gestion et la navigation.\nComprendre cette structure est essentiel pour naviguer et gérer efficacement un système Linux.\nTout est fichier Sous Linux, TOUT les éléments visibles dans l’arborescence du système de fichiers sont des fichiers.\nUn fichier est un fichier Un répertoire est un fichier Une clé USB est un fichier Une partition est un fichier Un disque dur est un fichier etc. Répertoires principaux Important\rChaque répertoire a un rôle spécifique et contient des types de fichiers bien définis.\n/ (Racine) Le point de départ de l’arborescence du système de fichiers. Tous les autres répertoires et fichiers sont situés sous ce répertoire. /bin Contient les binaires essentiels nécessaires au démarrage du système et à l’exécution des commandes de base, comme ls, cp, mv, etc. /boot Contient les fichiers nécessaires au démarrage du système, y compris le noyau Linux et les fichiers de configuration du chargeur de démarrage (bootloader). /dev Contient les fichiers de périphériques. Chaque périphérique matériel (comme les disques durs, les clés USB, etc.) est représenté par un fichier dans ce répertoire. /etc Contient les fichiers de configuration du système. Par exemple, les fichiers de configuration des services, des utilisateurs, des réseaux, etc. /home Contient les répertoires personnels des utilisateurs. Chaque utilisateur a son propre répertoire sous /home, par exemple /home/ndesmangles. /lib Contient les bibliothèques partagées nécessaires pour les binaires situés dans /bin et /sbin. /media Point de montage pour les périphériques amovibles comme les CD-ROM, les clés USB, etc. /mnt Utilisé pour monter temporairement des systèmes de fichiers. Par exemple, pour monter un disque dur externe. /opt Contient les logiciels optionnels et les paquets additionnels qui ne sont pas inclus dans la distribution standard. /proc Système de fichiers virtuel qui contient des informations sur les processus en cours et le système. Par exemple, /proc/cpuinfo contient des informations sur le processeur. /root Répertoire personnel de l’utilisateur root (administrateur du système). /run Contient des informations sur l’état du système depuis le dernier démarrage. Utilisé pour stocker des fichiers temporaires nécessaires au fonctionnement du système. /sbin Contient les binaires essentiels pour l’administration du système, comme fdisk, ifconfig, etc. /srv Contient les données spécifiques aux services fournis par le système. Par exemple, les fichiers de données pour un serveur web peuvent être stockés ici. /tmp Contient les fichiers temporaires créés par les utilisateurs et les applications. Ce répertoire est souvent vidé au redémarrage du système. /usr Contient les applications et les fichiers utilisés par les utilisateurs. Sous-répertoires importants : /usr/bin : Contient les binaires des applications utilisateur. /usr/lib : Contient les bibliothèques partagées pour les applications utilisateur. /usr/local : Contient les logiciels installés localement par l’administrateur du système. /var Contient les fichiers variables, tels que les journaux système, les fichiers de spool, et les fichiers temporaires des applications. Par exemple, /var/log contient les fichiers journaux. Les chemins absolu et relatif Chemin absolu Un chemin absolu est un chemin complet qui commence à la racine du système de fichiers. Il indique l’emplacement exact d’un fichier ou d’un répertoire, peu importe où vous vous trouvez dans le système de fichiers. Par exemple :\n/home/utilisateur/Documents/fichier.txt\rDans cet exemple, le chemin commence par /, qui est la racine du système de fichiers, et suit l’arborescence jusqu’au fichier fichier.txt.\nChemin relatif Un chemin relatif, quant à lui, est un chemin qui est relatif à votre répertoire de travail actuel. Il ne commence pas par /. Par exemple, si vous êtes dans le répertoire /home/utilisateur, et que vous voulez accéder à fichier.txt dans le sous-répertoire Documents, vous pouvez utiliser :\nDocuments/fichier.txt\rOu, si vous voulez remonter d’un niveau dans l’arborescence, vous pouvez utiliser .. pour représenter le répertoire parent. Par exemple, si vous êtes dans /home/utilisateur/Documents et que vous voulez accéder à un fichier dans /home/utilisateur, vous pouvez utiliser :\n../fichier.txt\rEn résumé\nChemin absolu : Commence à la racine / et donne l’emplacement complet. Chemin relatif : Dépend de votre répertoire de travail actuel et ne commence pas par /. Qu’est-ce que le SHELL? Le terme Shell désigne un programme qui interprète les commandes que vous tapez et les exécute. Il existe plusieurs types de shells, comme le Bourne Shell (sh), le C Shell (csh), le Korn Shell (ksh), et bien d’autres.\nLe shell Bash Bash (Bourne Again Shell) est le shell par défaut sur de nombreuses distributions Linux. Il agit comme une interface entre l’utilisateur et le système d’exploitation, permettant d’exécuter des commandes, des scripts, et d’automatiser des tâches.\nFonctionnalités clés de Bash Historique des commandes : Bash conserve un historique des commandes entrées, ce qui permet de les réutiliser facilement. Redirection : Les flux d’entrée et de sortie peuvent être redirigés pour enregistrer des résultats ou chaîner des commandes. Variables : Bash prend en charge les variables, qui peuvent stocker des données pour une utilisation ultérieure. Alias : Vous pouvez créer des alias pour simplifier des commandes longues ou fréquemment utilisées. La ligne de commande La ligne de commande est l’interface où vous tapez vos commandes. Elle est souvent représentée par un symbole $ ou #:\n$ signifie que vous êtes un utilisateur standard # signifie que vous êtes le super-utilisateur root (administrateur du système). ~ signifie le répertoire personnel, les symboles $ et # seront précédés du symbole tilde: ~$ ou ~#. Une commande dans le shell suit généralement cette structure :\ncommande [options] [arguments]\rcommande : Le programme ou l’outil que vous souhaitez exécuter. options : Des paramètres supplémentaires qui modifient le comportement de la commande. arguments : Les cibles sur lesquelles la commande doit agir (fichiers, répertoires, etc.). Lorsque vous êtes prêt à exécuter une commande, appuyez sur la touche Entrée. Tapez chaque commande sur une ligne séparée. Le résultat de la commande est affiché avant l’invite du shell suivante.\nExemple de commande sans option :\n[ndesmangles@localhost ~]$ whoami ndesmangles [ndesmangles@localhost ~]$\rExemple de commande avec une option :\n[ndesmangles@localhost ~]$ date -R Fri, 17 Jan 2025 20:19:50 -0500 [ndesmangles@localhost ~]$ date +%R 20:19 Pour exécuter une commande avec des privilèges de super-utilisateur (root), on la précède de sudo:\n[ndesmangles@localhost ~]$ sudo ls /root\rCommandes de base en Bash Bash propose une variété de commandes puissantes pour interagir avec le système. Ces commandes de base sont essentielles pour naviguer, gérer des fichiers, et interagir avec votre système sous Bash.\nNavigation dans le système de fichiers Commande Description pwd Affiche le chemin absolu du répertoire courant. cd Change le répertoire courant. ls Affiche le contenu d’un répertoire. pwd (Print Working Directory) :\n[ndesmangles@localhost ~]$ pwd /home/ndesmangles\t# Le répertoire personnel dans home [ndesmangles@localhost ~]$ cd (Change Directory) :\n[ndesmangles@localhost ~]$ cd /etc [ndesmangles@localhost etc]$\t# Notez le changement du répertoire courant (etc)\rRemonter d’un niveau. [ndesmangles@localhost etc]$ cd .. [ndesmangles@localhost /]$ # Notez le positionnement à la racine /\rRevenir dans le répertoire etc [ndesmangles@localhost /]$ cd etc [ndesmangles@localhost etc]$ Remonter de deux niveaux. [ndesmangles@localhost etc]$ cd ../.. [ndesmangles@localhost /]$ # Notez le retour à la racine /\rRevenir à notre répertoire personnel [ndesmangles@localhost etc]$ cd ~ [ndesmangles@localhost ~]$ # Notez le retour au répertoire personnel ~\rls (List) :\nOptions utiles :\n-l : Affiche des détails comme les permissions1, la taille, etc. -a : Montre les fichiers cachés. [ndesmangles@localhost /]$ ls afs bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var [ndesmangles@localhost /]$ ls -l total 24 dr-xr-xr-x. 2 root root 6 2 oct 17:00 afs lrwxrwxrwx. 1 root root 7 2 oct 17:00 bin -\u003e usr/bin dr-xr-xr-x. 5 root root 4096 11 jan 23:06 boot\rQuelques explications :\nPremière colonne: -rwxr-xr-x par exemple représente le type de fichier et les droits d’accès (abordés en détail dans un prochain cours) qui lui sont associés. Deuxième colonne : ce qu’elle représente dépend du type de fichier: Répertoire : indique le nombre de sous-répertoires (+2 pour . et ..). Fichier : nombre de lien physiques (vu plus loin dans ce cours). Troisième et quatrième colonnes représentent l’utilisateur propriétaire du fichier et le groupe propriétaire du fichier. Cinquième colonne indique la taille du fichier (notez qu’un répertoire a une taille qui correspond à la taille du fichier répertoire sur le disque). Sixième colonne indique la date de dernière modification. Septième colonne est le nom du fichier. Bon à savoir\rLa commande clear permet d’effacer l’écran du terminal.\nManipulation de fichiers et répertoires Commande Description touch Crée un fichier vide ou met à jour la date de modification d’un fichier existant. mkdir Crée un nouveau répertoire. rm Supprime des fichiers. Pour supprimer des répertoires, utilisez -r (récursif). rmdir Supprime un répertoire vide. cp Copie des fichiers ou des répertoires. mv Déplace ou renomme des fichiers et des répertoires. touch :\n[ndesmangles@localhost ~]$ touch nouveau_fichier.txt\rmkdir (Make Directory) :\n[ndesmangles@localhost ~]$ mkdir nouveau_repertoire\rrm (Remove) :\n[ndesmangles@localhost ~]$ rm fichier.txt [ndesmangles@localhost ~]$ rm -r dossier_a_supprimer\rrmdir (Remove Directory) :\n[ndesmangles@localhost ~]$ rmdir dossier_vide [ndesmangles@localhost ~]$ rmdir dossier_pas_vide # Affiche une erreur\rcp (Copy) :\n[ndesmangles@localhost ~]$ cp fichier_source.txt fichier_destination.txt [ndesmangles@localhost ~]$ cp -r dossier_source dossier_destination\rmv (Move) :\n[ndesmangles@localhost ~]$ mv ancien_nom.txt nouveau_nom.txt [ndesmangles@localhost ~]$ mv fichier.txt /nouveau/chemin/\rAffichage et lecture de fichiers Commande Description cat Affiche le contenu complet d’un fichier. less Permet de lire un fichier page par page. head Affiche les premières lignes d’un fichier. 10 lignes par défaut. tail Affiche les dernières lignes d’un fichier. 10 lignes par défaut. cat :\n[ndesmangles@localhost ~]$ cat fichier.txt [ndesmangles@localhost ~]$ cat fichier1 fichier2 Hello World!! Introduction aux commandes Linux. [ndesmangles@localhost ~]$ cat /etc/shells\t# Affiche les Shells installés sur la machine.\rless :\nContrôles : Espace : Page suivante q : Quitter [ndesmangles@localhost ~]$ less fichier.txt\rhead :\n[ndesmangles@localhost ~]$ head fichier.txt # Affiche les 10 premières lignes [ndesmangles@localhost ~]$ head -n 5 fichier.txt # Affiche les 5 premières lignes\rtail :\n[ndesmangles@localhost ~]$ tail fichier.txt # Affiche les 10 dernières lignes [ndesmangles@localhost ~]$ tail -n 5 fichier.txt # Affiche les 5 dernières lignes\rInformations système et historique Commande Description date Affiche la date et l’heure actuelles. history Liste les commandes précédemment exécutées. date :\nOptions utiles :\n+ : Pour spécifier un format personnalisé. Formats:\n%Y : Année complète (ex. 2025). %m : Mois (01-12). %d : Jour (01-31). %H : Heure (00-23). %M : Minutes (00-59). %S : Secondes (00-59). %r : Heure au format 12h (ex. 11:11:04 PM) %R : Heure au format 24h (ex. 23:11 sans les secondes) %p : Heure avec AM ou PM [ndesmangles@localhost ~]$ date Thu Jan 9 20:42:36 EST 2025 [ndesmangles@localhost ~]$ date \"+%Y-%m-%d %H:%M:%S\" 2025-01-09 20:42:43\rhistory :\nOptions utiles : n : Pour spécifier le nombre de commandes précédentes à afficher. ! : Pour exécuter une commande spécifique de l’historique, par son numéro. c : Pour effacer l’historique de la session. [ndesmangles@localhost ~]$ history\t# Affiche l'historique complet de la session. 1 date -R 2 pwd 3 cd /etc 4 cd .. 5 cd etc 6 cd ../.. 7 ls 8 ls -a 9 ls -l 10 date 11 date \"+%Y-%m-%d %H:%M:%S\" 12 cd ~ 13 history [ndesmangles@localhost ~]$ history 5\t# Affiche les 5 dernières commandes effectuées. 10 date 11 date \"+%Y-%m-%d %H:%M:%S\" 12 cd ~ 13 history 14 history 5 [ndesmangles@localhost ~]$ !11\t# Exécute la commande #11 dans l'historique date \"+%Y-%m-%d %H:%M:%S\" 2025-01-09 20:47:03 [ndesmangles@localhost ~]$ !da\t# Exécute la commande la plus récente, dont le nom commence par 'da'. date \"+%Y-%m-%d %H:%M:%S\"\t2025-01-18 20:48:22\t[ndesmangles@localhost ~]$ history -c\t# Efface l'historique. [ndesmangles@localhost ~]$ history 1 history\rCommandes utiles Commande Description echo Affiche un message ou une variable dans le terminal. man Affiche le manuel d’aide pour une commande. echo :\n[ndesmangles@localhost ~]$ echo \"Bonjour, monde!\" Bonjour, monde! [ndesmangles@localhost ~]$ echo $SHELL /bin/bash\rNote\r$SHELL doit être écrit en respectant la casse.\rman (Manual) :\n[ndesmangles@localhost ~]$ man ls\t# Affiche le manuel de la commande `ls`.\rStructure d’une page de manuel Une page de manuel typique contient plusieurs sections, telles que :\nNAME : Le nom de la commande et une brève description. SYNOPSIS : La syntaxe de la commande. DESCRIPTION : Une description détaillée de la commande et de ses options. OPTIONS : Les options disponibles pour la commande. EXAMPLES : Des exemples d’utilisation. SEE ALSO : Des références à d’autres commandes ou documents pertinents. Options utiles man -k keyword : Recherche des pages de manuel contenant le mot-clé spécifié. man -f command : Affiche une brève description de la commande (équivalent à whatis command). Autocompletion d’une commande Bash La touche Tab du clavier, permet de compléter rapidement les commandes et les noms de fichiers après avoir entré un nombre de caractères suffisant pour réduire les possibilités à une seule. Si les caractères saisis ne sont pas uniques, appuyez deux fois sur la touche de tabulation pour afficher toutes les commandes correspondantes. [ndesmangles@localhost ~]$ cat /etc/serTab\t# `cat /etc/ser` suivi de la touche `Tab` complète le nom du fichier. [ndesmangles@localhost ~]$ cat /etc/services [ndesmangles@localhost ~]$ passTabTab\t# `pass` suivi de 2 fois la touche `Tab` propose les commande dont le nom commence par `pass`. passt passt.avx2 passwd [ndesmangles@localhost ~]$ pass\rIntroduction à l’éditeur de texte VIM VIM (Vi IMproved) est un éditeur de texte, souvent utilisé dans les environnements Unix/Linux. Bien qu’il puisse sembler intimidant au premier abord, il devient très efficace une fois maîtrisé.\nPourquoi utiliser vim ? Disponibilité : Installé par défaut sur presque tous les systèmes Unix/Linux. Léger et rapide : Idéal pour éditer des fichiers même sur des systèmes limités en ressources. Puissant : Supporte des fonctionnalités avancées comme la recherche, la substitution, et l’édition de plusieurs fichiers simultanément. Premiers pas avec vim Pour ouvrir un fichier avec vim, utilisez la commande suivante :\n$ vim nom_du_fichier\rSi le fichier n’existe pas, vim le créera.\nLorsque vous ouvrez vim, il commence en mode commande. Vous ne pouvez pas directement écrire du texte. Vous devez d’abord passer au mode insertion en tapant la lettre i. En bas de la fenêtre Vim, le mot INSERTION s’affichera.\nRevenir au mode Normal\rSi avant de taper i ou n’importe quel autre mode, vous n’êtes plus dans le mode Normal, il suffit de tapper la touche ESC pour revenir au mode Normal.\nModes principaux de vim Ces modes sont les bases du fonctionnement de vim. Vous pouvez basculer entre eux selon vos besoins pour éditer et manipuler vos fichiers.\nMode Description Action Commande Normal Mode par défaut lorsque vous ouvrez vim. Appuyez sur Esc pour revenir à ce mode. ESC Insertion Permet d’insérer ou de modifier du texte. Passer en mode insertion où se trouve le curseur. i Commande Permet de sauvegarder un fichier. Sauvegarde :w Permet de quitter Vim, si aucun changement n’a été effectué dans le fichier en cours. Quitter :q Permet de forcer la fermeture de vim sans sauvegarder les modifications. Quitter sans sauvegarder les modifications. :q! Permet de sauvegarder et fermer le fichier. Sauvegarde et quitter. :wq Exercices pratiques Ouvrez un fichier nommé test.txt avec la commande :\n$ vim test.txt\rPassez en mode insertion (i), écrivez quelques lignes, puis sauvegardez et quittez avec :wq.\nRecherchez du texte : Ouvrez un fichier existant, cherchez un mot avec /mot, puis naviguez entre les occurrences avec n.\nTestez l’annulation : Modifiez une ligne, annulez avec u, puis rétablissez avec Ctrl+r.\nNous étudierons comment gérer les droits des différents utilisateurs plus tard dans ce cours. ↩︎",
    "description": "La structure du système de fichiers Linux est hiérarchique et organisée sous la forme d’un arbre inversé, où la racine (root) est représentée par /. Tous les fichiers et répertoires sont situés sous cette racine.\nLa structure du système de fichiers Linux est conçue pour être logique et organisée, facilitant ainsi la gestion et la navigation.\nComprendre cette structure est essentiel pour naviguer et gérer efficacement un système Linux.",
    "tags": [],
    "title": "Système de fichiers, Shell et commandes de base et VIM",
    "uri": "/semaine2/cours/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Système de fichiers, Shell, commandes de base, Vim",
    "content": "Objectifs de l’atelier Se familiariser avec la ligne de commandes. Naviguer dans l’arborescence Linux à l’aide de commandes. Gerer des fichiers et répertoires à l’aide de commandes. Format de la remise sur Moodle Attention\rPour chaque exercice, vous devrez prendre une capture d’écran. Sur les captures, on doit pouvoir voir : Votre nom d’utilisateur (Ne travaillez donc pas avec l’utilisateur root, ni la commande sudo). La ligne de commande et la commande. Le résultat de la commande. Si le résultat fait plus de 10 lignes, capturer juste les 10 premières lignes. Nommer les fichiers image, tel qu’indiqué pour chaque question. Remettre toutes vos images dans 1 seul fichier compressé (ex:.zip). Tout autre format ne sera pas corrigé. Pour l’exercice #3, quelques questions devront ètre répondues dans un fichier texte à remettre sur Moodle en plus du .zip. Atelier Préparation Sur votre machine Almalinux, avec votre utilisateur standard, allez sur votre cours sur Moodle, dans la semaine 2. On vous demande de télécharger le fichier fichier.txt. Vous en aurez besoin pour l’exercice #3.\nCliquez sur fichier1. Sur la fenêtre qui s’ouvre, faites un clic droit et choisissez Enregistrez-sous. Le fichier va être enregistré par défaut dans le dossier Téléchargements. Fermer la fenêtre.\nCliquez sur le bouton Activités sur le bureau.\nCliquer sur l’icône Fichiers. Attention\rAvant de commencer chaque exercice, assurez vous que vous travaillez dans votre répertoire personnel et ne vous déplacez pas que lorsque demandé. À moins d’indication contraire, utiliser TOUJOURS des chemins relatifs. Allez maintenant sur votre terminal. Placez-vous dans votre répertoire personnel.\nExercice 1 : Explorer l’arborescence Linux Afficher le chemin de votre répertoire courant. Prendre une capture d’écran et nommez-la 1-1.png. Allez dans le répertoire /usr/share/doc, puis vérifiez le chemin de votre répertoire courant. Prendre une capture d’écran et nommez-la 1-2.png. Remontez dans le répertoire parent. Prendre une capture d’écran et nommez-la 1-3.png. Allez dans votre répertoire personnel. Prendre une capture d’écran et nommez-la 1-4.png. Listez les fichiers présents du répertoire courant. Prendre une capture d’écran et nommez-la 1-5.png. Toujours en étant dans votre dossier personnel, listez les fichiers du répertoire /usr. Prendre une capture d’écran et nommez-la 1-6.png. Exercice 2: Commandes Linux simples Commande date\nAfficher la date et l’heure actuelles du système. Afficher l’heure actuelle sur une horloge de douze heures (par exemple, 11:42:11 AM). Prendre une capture d’écran et nommez-la 2-1.png. Commande head\nAffichez les 10 premières lignes du fichier /etc/services Prendre une capture d’écran et nommez-la 2-2.png. Commande tail\nAffichez les 10 dernières lignes du fichier /etc/services. Prendre une capture d’écran et nommez-la 2-3.png. Commande tail et la flèche vers le haut\nRépéter la commande précédente avec exactement trois frappes de touches. Prendre une capture d’écran et nommez-la 2-4.png. Commande tail et les flèches vers le haut et vers la gauche\nRépéter la commande précédente, mais afficher les 20 dernières lignes du fichier. Prendre une capture d’écran et nommez-la 2-5.png. Commande history\nUtiliser l’historique du shell pour exécuter à nouveau la commande effectuée pour la question #3 (heure sur 12h) Prendre une capture d’écran et nommez-la 2-6.png. Exercice 3: Commandes de base Important\rUtilisez pas l’interface graphique d’Almalinux QUE LORSQUE demandé (#6). Autrement, utilisez uniquement des commandes pour répondre aux questions. Après chaque question (sauf #6, #12a, #15 à #20), n’oubliez pas de prendre une capture d’écran et de la nommer 3-X.png où X est le numéro de la question. Créer un répertoire Atelier2 dans le répertoire courant. Copier le fichier téléchargé fichier.txt dans le répertoire Atelier2. Créer un autre répertoire nommé Rep2. Déplacer Atelier2 dans Rep2. Déplacez-vous dans Atelier2. Avec vim, ouvrez le fichier fichier.txt et écrivez écrivez votre nom complet dans le fichier. Enregistrer la modification et fermer le fichier. Afficher le contenu du fichier à l’aide de la commande cat. Créer un autre fichier nommé fichier2.txt dans Atelier2. Avec une seule commande cat afficher le contenu de fichier.txt et fichier2.txt. Revenir dans votre répertoire personnel. Supprimer le répertoire Rep2. a) Dans quel répertoire vous trouvez-vous? b) Utiliser une commande pour voir le répertoire courant. Créer un dossier avec le nom Rep3 dans le dossier /root(en utilisant un chemin absolu). Avez-vous réussi ? Si non, pourquoi ? Afficher le contenu du répertoire /etc en utilisant l’option -l. Par quels caractères, les lignes affichées débutent ? Quelles est leur signification ? Qu’est-ce qui distingue le répertoire /proc des autres répertoires de l’arborescence linux ? Qu’est ce qui distingue le répertoire /bin et /sbin ? Quel est le répertoire qui est utilisé pour charger le noyau du système d’exploitation au démarrage ? Dans Linux, tout est fichier. Si on connecte une clé usb à une machine linux, dans quel répertoire de l’arborescence, on va trouver la référence à cette clé ? Si on installe un serveur web apache sur une machine linux, dans quel répertoire de l’arborescence le dossier contenant les fichiers de configuration du serveur se trouvera-t-il ?",
    "description": "Objectifs de l’atelier Se familiariser avec la ligne de commandes. Naviguer dans l’arborescence Linux à l’aide de commandes. Gerer des fichiers et répertoires à l’aide de commandes. Format de la remise sur Moodle Attention\rPour chaque exercice, vous devrez prendre une capture d’écran. Sur les captures, on doit pouvoir voir : Votre nom d’utilisateur (Ne travaillez donc pas avec l’utilisateur root, ni la commande sudo). La ligne de commande et la commande. Le résultat de la commande. Si le résultat fait plus de 10 lignes, capturer juste les 10 premières lignes. Nommer les fichiers image, tel qu’indiqué pour chaque question. Remettre toutes vos images dans 1 seul fichier compressé (ex:.zip). Tout autre format ne sera pas corrigé. Pour l’exercice #3, quelques questions devront ètre répondues dans un fichier texte à remettre sur Moodle en plus du .zip. Atelier Préparation Sur votre machine Almalinux, avec votre utilisateur standard, allez sur votre cours sur Moodle, dans la semaine 2. On vous demande de télécharger le fichier fichier.txt. Vous en aurez besoin pour l’exercice #3.",
    "tags": [],
    "title": "ATELIER #2: Commandes Linux de base",
    "uri": "/semaine2/atelier/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e WSL installation et manipulation (Ubuntu, VS Code)",
    "content": "Objectifs de l’atelier Cet atelier a pour but de vous familiariser avec la ligne de commandes en utilisant Ubuntu comme distribution Linux.\nFormat de la remise Attention\rPour chacune des étapes des parties 2 et 3 vous devrez prendre une capture d’écran de vos commandes et résultats. ATTENTION: On doit pouvoir voir votre nom d’utilisateur. Ne travaillez donc pas avec l’utilisateur root.\nAtelier Partie 1: Installations WSL (Windows Subsystem for Linux) Rechercher les fonctionnalités Windows Dans la liste, cocher Sous-Système Windows pour Linux Redémarrer Une fois redémarré, vous pouvez installer la distribution Ubuntu depuis le Microsoft Store.\nPartie 2: Installation d’Ubuntu WSL prend en charge une variété de distributions Linux, y compris la dernière version LTS d’Ubuntu.\nIl existe plusieurs façons d’installer des distributions sur WSL, nous nous concentrons ici sur la méthode via l’application dans Microsoft Store et les commandes WSL exécutées dans le terminal. Le résultat est le même quelle que soit la méthode.\nApplication dans Microsoft Store\nOuvrir Microsoft Store et trouver la dernière version d’Ubuntu. Cliquez sur Free/Gratuit, puis sur Get/Obtenir. Patienter durant l’installation. Ubuntu sera alors installé sur votre machine.\nAvant de commencer, s’assurer qu’Ubuntu est à jour:\n$ sudo apt update\rPrenez une capture d’écran de la fenêtre de la commande avec le résultat et nommez-la 1.png. NOTE: La commande sudo permet d’exécuter une commande en tant qu’administrateur du système.\nUne fois installé, vous pouvez soit lancer l’application directement depuis le Microsoft Store, soit rechercher Ubuntu dans votre barre de recherche Windows.\nPrenez une capture d’écran de la fenêtre de terminal Ubuntu et nommez-la 2.png. References:\nSite Ubuntu WSL Vidéo YouTube",
    "description": "Objectifs de l’atelier Cet atelier a pour but de vous familiariser avec la ligne de commandes en utilisant Ubuntu comme distribution Linux.\nFormat de la remise Attention\rPour chacune des étapes des parties 2 et 3 vous devrez prendre une capture d’écran de vos commandes et résultats. ATTENTION: On doit pouvoir voir votre nom d’utilisateur. Ne travaillez donc pas avec l’utilisateur root.\nAtelier Partie 1: Installations WSL (Windows Subsystem for Linux) Rechercher les fonctionnalités Windows",
    "tags": [],
    "title": "ATELIER #2: WSL, Ubuntu et des commandes Linux simples",
    "uri": "/semaine14/atelier/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "Plan de la leçon Théorie :\nLa séquence de démarrage de Linux. Les cibles (niveaux d’exécution). Les variables utilisateur. Itération avec la boucle FOR. Atelier :\nGestion des cibles. Création et utilisation de variables. Utilisation de la boucle FOR.",
    "description": "Plan de la leçon Théorie :\nLa séquence de démarrage de Linux. Les cibles (niveaux d’exécution). Les variables utilisateur. Itération avec la boucle FOR. Atelier :\nGestion des cibles. Création et utilisation de variables. Utilisation de la boucle FOR.",
    "tags": [],
    "title": "Processus de démarrage, variables et FOR",
    "uri": "/semaine3/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Processus de démarrage, variables et FOR",
    "content": "Séquence de démarrage de Linux Le processus de démarrage de Linux est une série d’étapes qui se déroulent depuis l’allumage de l’ordinateur jusqu’à l’affichage de l’invite de commande ou de l’interface graphique. Comprendre ce processus est essentiel pour diagnostiquer et résoudre les problèmes de démarrage.\nLorsqu’un système Linux démarre, plusieurs étapes se succèdent de manière ordonnée pour préparer la machine et le système d’exploitation à fonctionner. Voici les étapes principales :\nBIOS/UEFI : Initialise le matériel et recherche un périphérique amorçable. Bootloader (GRUB) : Charge le noyau Linux et transfère le contrôle au système d’exploitation. Noyau Linux : Configure le matériel, monte le système de fichiers racine, et démarre le processus d’initialisation. Init/Systemd : Gère le lancement des services et des processus utilisateur. Étape 1 : BIOS/UEFI Rôle du BIOS/UEFI Le BIOS (Basic Input/Output System) ou l’UEFI (Unified Extensible Firmware Interface) est le premier programme exécuté lorsqu’une machine est allumée. Il effectue des tests matériels (POST) et localise le bootloader sur un disque amorçable, et charge le MBR en mémoire Le BIOS transfère alors le contrôle au code du Master Boot Record (MBR). Le MBR se trouve dans le premier secteur du disque dur (secteur 0), c’est-à-dire les premiers 512 octets de l’espace de stockage. Le MBR contient un programme minimal d’amorçage (bootloader primaire) qui localise et charge le bootloader secondaire (ex. GRUB ou LILO) depuis une partition active. Modes de démarrage Legacy (BIOS) : Mode traditionnel compatible avec les anciens systèmes. UEFI : Plus moderne, prend en charge des fonctionnalités avancées comme le Secure Boot. BIOS ou UEFI ?\rAvec l’essor de l’UEFI, le MBR est remplacé par le schéma GPT (GUID Partition Table), qui offre plus de flexibilité (gestion de disques de grande taille et partitions multiples). Les systèmes UEFI n’utilisent pas de MBR classique mais démarrent directement via un fichier exécutable dans une partition EFI (ESP). Le MBR est une étape initiale critique dans les systèmes BIOS/MBR, mais il est remplacé dans les environnements modernes utilisant UEFI. Étape 2 : Bootloader (GRUB) Rôle de GRUB Le bootloader (GRUB : GRand Unified Bootloader) est responsable de charger le noyau Linux en mémoire. Il peut proposer plusieurs options de démarrage, comme des versions différentes du noyau ou un mode de récupération. Étape 3 : Le noyau Linux (Kernel) Fonctionnalités du noyau au démarrage Détection matérielle : Identifie et initialise les composants matériels. Chargement des modules : Ajoute des pilotes pour des périphériques spécifiques. Montage du système de fichiers racine : Prépare l’environnement pour le reste du système. Lancement du processus d’initialisation : Appelle le gestionnaire d’initialisation (PID 1). Définition\rPID : Processus ID est l’identifiant d’un processus. Étape 4 : Init et Systemd Gestionnaires d’initialisation SysVinit : Ancien gestionnaire basé sur des scripts shell. Systemd : Gestionnaire moderne basé sur des unités (units) qui remplacent les scripts traditionnels. Rôle de l’init (PID 1) L’init est le premier processus utilisateur démarré par le noyau. Il gère le lancement des services essentiels et assure la transition vers un état prêt pour les utilisateurs. Les services sont des processus en arrière-plan qui effectuent des tâches spécifiques (ex. serveur SSH, journalisation). Quand tous les services sont lancés, le programme init affiche l’écran de connexion, qui vous demande votre nom d’utilisateur et votre mot de passe. 5. Les cibles / niveaux d’exécution (Runlevels) Les cibles (niveaux d’exécution) définissent l’état du système et les services qui doivent être exécutés. Dans le passé, les modes de fonctionnement étaient connus sous le nom de niveaux d’exécution, chacun permettant l’accès à un ensemble spécifique de services. Le concept de niveaux d’exécution a été remplacé par celui de cibles (target). L’ensemble des services associés aux anciens niveaux d’exécution ont été conservés dans le système de cibles de systemd, afin de maintenir la compatibilité avec les scripts et les configurations existantes. Information\rLes distributions modernes comme Fedora, Ubuntu et Almalinux utilisent donc Systemd. Voici les cibles les plus courantes et leur correspondance:\nNiveau d’exécution Description Target Systemd 0 Arrêt du système. poweroff.target 1 Mode monoutilisateur (maintenance). rescue.target ou emergency.target 3 Multi-utilisateur (texte) multi-user.target 5 Multi-utilisateur (graphique) graphical.target 6 Redémarrage reboot.target Différence entre emergency.target et rescue.target emergency.target : Le mode le plus minimal, aucun système de fichiers supplémentaire n’est monté, pas de réseau, pas de services. C’est vraiment pour les urgences critiques. rescue.target : Similaire au mode monoutilisateur (niveau d’exécution 1). Il monte certains systèmes de fichiers et démarre un ensemble limité de services, mais pas de services réseau. Commandes liées aux cibles Systemd ou init. Note\rLes commandes systemctl qui modifient l’état du système ou des services touchent des fichiers et des processus sous contrôle strict, souvent localisés dans des répertoires comme /etc/systemd/system ou /lib/systemd/system. Ces zones sont protégées pour éviter des modifications accidentelles ou malveillantes. Dans la plupart des cas, vous devez avoir des privilèges sudo ou être connecté en tant qu’utilisateur root pour utiliser la commande systemctl, car elle est conçue pour gérer des services, des cibles (targets), et d’autres composants système qui nécessitent des autorisations élevées. Pour lister les processus s’exécutant sur une machine Avec ps :\nAffiche tous les processus s’exécutant sur la machine. $ ps -ef UID PID PPID C STIME TTY TIME CMD root 1 0 2 16:18 ? 00:00:01 /usr/lib/systemd/systemd --s\rPour connaître le niveau d’exécution actuel Avec Systemd :\n$ systemctl get-default graphical.target\rAvec runlevel (SysVinit) :\n$ runlevel N 5\rCette commande affiche deux valeurs : le précédent et l’actuel niveau d’exécution. Ici, N indique qu’il n’y avait pas de niveau précédent (au démarrage), et 5 est le niveau actuel. Pour se placer temporairement dans un niveau d’exécution Avec systemctl isolate reboot :\nCette commande met immédiatement le système en état de redémarrage. Elle isole le target associé à l’action de redémarrage (souvent reboot.target). Effet : Redémarrage immédiat, tous les services et processus actifs sont arrêtés proprement. Avec systemctl isolate poweroff :\nCette commande met immédiatement le système hors tension (extinction complète). Elle isole le target associé à l’arrêt (poweroff.target). Effet : Extinction immédiate, tous les services et processus actifs sont arrêtés proprement. Pour voir quel est le niveau d’exécution par défaut Avec Systemd :\n$ systemctl get-default\t# Renvoie le *target* par défaut.\rAvec runlevel (SysVinit) :\nVous pouvez également utiliser runlevel comme décrit précédemment. Pour modifier le niveau par défaut Avec Systemd :\nChangez le target par défaut avec : $ sudo systemctl set-default multi-user.target\t# Niveau d’exécution 3 (mode texte multi-utilisateur).\rAvec SysVinit :\nModifiez le fichier /etc/inittab (pour les systèmes utilisant encore SysVinit) : $ id:5:initdefault:\t# Définit le niveau 5 (mode graphique) comme niveau d’exécution par défaut.\rPour se rendre directement au niveau d’exécution par défaut Utilisez la commande suivante pour forcer le système à se placer dans le niveau d’exécution ou target par défaut : $ sudo systemctl isolate default.target\rQuestion: Suite aux commandes suivantes, que se passe-t-il ?\n$ init 0 : Réponse\rEnvoie le système au niveau d’exécution 0, qui correspond à l’extinction. Effet : Éteint immédiatement la machine, tout comme la commande systemctl poweroff. $ init 6 : Réponse\rEnvoie le système au niveau d’exécution 6, qui correspond au redémarrage. Effet : Redémarre immédiatement la machine, tout comme la commande systemctl reboot. Les variables utilisateur en Bash Nomenclature, assignation et affichage des variables Lors de la création d’une variable, toujours utiliser des noms descriptifs. Exemple: nombre_utilisateurs au lieu de nombre. Attention\rLes caractères spéciaux ou espaces dans les noms peuvent causer des erreurs. Les noms sont sensible à la casse. Exemple: VAR1 ≠ var1\nPas besoin de déclaration explicite, pour affecter une valeur on utilise = sans espace autour de =. Exemple:\n$ ma_variable=\"Bonjour, Linux!\"\rPour afficher la valeur d’une variable, on utilise le symbole $ devant le nom. Exemple: $ echo $ma_variable\rPour supprimer une variable, on utilise unset suivi du nom de la variable (sans $). Exemple: $ unset ma_variable\rStocker le résultat d’une commande dans une variable En Bash, vous pouvez capturer la sortie d’une commande dans une variable en utilisant la syntaxe $(...).\nExemple 1 : Stocker la date courante\n$ date_courante=$(date +%Y-%m-%d)\t# La date sera stockée dans date_courante aaaa-mm-jj $ echo $date_courante\t# Affiche la valeur de date_courante 2025-01-09\rExemple 2 : Compter et stocker le nombre de fichiers dans le répertoire courant\n$ nombre_fichiers=$(ls | wc -l) $ echo $nombre_fichiers 8\rls : Liste les fichiers et répertoires dans le répertoire courant. wc -l : Compte le nombre de lignes de la sortie de ls, correspondant au nombre d’entrées.1 Expansion des variables en Bash L’expansion des variables consiste à remplacer le nom d’une variable par sa valeur lors de l’exécution d’une commande, permettant ainsi d’utiliser dynamiquement des données dans des scripts ou des commandes.\nExemple 1: Remplacement de la variable par sa valeur\n$ fichiers=\"toto titi tutu\" $ ls -l $fichiers\rCommande exécutée :\n$ ls -l toto titi tutu\rExemple 2: Une variable peut inclure des options :\n$ fichiers=\"-l toto titi tutu\" $ ls $fichiers\rCommande équivalente :\n$ ls -l toto titi tutu\rStocker le résultat d’une commande dans une variable Stocker le résultat d’une commande dans une variable consiste à capturer la sortie d’une commande en utilisant la syntaxe $(commande) afin de la réutiliser ultérieurement dans un script ou une commande.\n$ fichiers=$(ls) $ ls \"$fichiers\" # Toujours utiliser des guillemets pour gérer les espaces.\rExpansion de noms de fichiers (* et ?) Dans Bash on peut utiliser des caractères génériques pour étendre des motifs en liste de fichiers existants.\nCaractère Description Exemple Résultat * Remplace une chaîne de longueur variable ls *.txt Fichiers comme toto.txt, titi.txt ? Remplace un seul caractère ls t?t?.txt Fichiers comme toto.txt, titi.txt Expansion d’accolades L’expansion d’accolades en Bash permet de générer rapidement des séries de chaînes ou de motifs en factorisant des éléments variables, comme dans {a,b,c} pour produire a, b, c, ou {1..5} pour générer 1, 2, 3, 4, 5.\nBut Commande Résultat Générer des variations touch patat{a,e,i,o,u,y} patata, patate, … Générer une séquence touch test{1..12}.txt test1.txt, test2.txt, … Attention\rPas d’espace dans les accolades Protéger contre l’expansion Protéger contre l’expansion en Bash consiste à empêcher l’interprétation des caractères spéciaux, des variables ou des commandes en utilisant des guillemets simples, doubles ou le caractère d’échappement \\.\nMéthode Commande Effet Échappement \\ echo Je veux afficher \\* et \\$x Affiche * et $x sans expansion. Guillemets simples ' echo 'Voici * et $x' Aucun remplacement, affiche littéralement. Guillemets doubles \" echo \"Valeur : $x\" Permet l’expansion des variables. Commandes spéciales et expansions Certaines commandes comme find1 nécessitent une attention particulière concernant l’expansion.\nExemple : Recherche avec find Pour rechercher tous les fichiers .txt :\n$ find / -name \"*.txt\"\rIci, les guillemets protègent *.txt pour empêcher Bash d’expandre le motif avant de passer à find. Cela garantit que find traite correctement le motif.\nBonnes pratiques avec les variables Toujours utiliser des guillemets pour éviter les problèmes avec les espaces ou caractères spéciaux :\n$ ls \"$fichiers\"\rProtégez les motifs pour les commandes comme find:\n$ find / -name \"*.txt\"\rUtilisez les accolades pour générer des séquences et factoriser vos commandes :\n$ touch fichier{1..10}.txt\rItération sur les résultats de commandes La boucle for est un élément fondamental qui permet de répéter une action pour chaque élément d’une liste ou d’un ensemble de valeurs. Elle est particulièrement utile pour automatiser des tâches répétitives.\nStructure générale for variable in liste do commande1 commande2 ... done\rvariable : Une variable temporaire qui prend successivement chaque valeur de la liste. liste : Un ensemble de valeurs, qui peut être défini explicitement ou généré dynamiquement. Les commandes entre do et done sont exécutées pour chaque valeur de la liste. Exemple 1 : Parcourir une liste statique for animal in chat chien oiseau do echo \"Je suis un $animal\" done\rSortie :\nJe suis un chat\rJe suis un chien\rJe suis un oiseau\rExemple 2 : Parcourir des fichiers d’un répertoire for fichier in *.txt do echo \"Traitement de $fichier\" done\rIci, *.txt est un motif de fichier. Bash remplace *.txt par la liste des fichiers correspondants dans le répertoire courant. Sortie : (si le répertoire contient file1.txt et file2.txt)\nTraitement de file1.txt\rTraitement de file2.txt\rExemple 3 : Générer une liste avec une séquence Vous pouvez utiliser une séquence avec {debut..fin} pour générer des nombres ou des caractères :\nfor i in {1..5} do echo \"Nombre : $i\" done\rSortie :\nNombre : 1\rNombre : 2\rNombre : 3\rNombre : 4\rNombre : 5\rExemple 4 : Ajouter des pas dans une séquence Pour parcourir une séquence avec un pas spécifique, utilisez {debut..fin..pas} :\nfor i in {1..10..2} do echo \"Nombre impair : $i\" done\rSortie :\nNombre impair : 1\rNombre impair : 3\rNombre impair : 5\rNombre impair : 7\rNombre impair : 9\rExemple 5 : Lire des entrées à partir d’une commande Vous pouvez parcourir les fichiers dans un répertoire pour lister les utilisateurs disposant d’un répertoire personnel sur le système :\nfor user in $(ls /home) do echo \"Utilisateur avec un répertoire : $user\" done\rExplication :\nls /home liste les répertoires dans /home, où chaque répertoire correspond généralement à un utilisateur ayant un compte sur le système. La boucle for parcourt chaque nom de répertoire et l’associe à la variable user. La commande echo affiche ensuite le nom de chaque utilisateur. Utiliser des guillemets pour protéger les valeurs Si les éléments de la liste contiennent des espaces, utilisez des guillemets pour éviter des erreurs :\nfor fichier in \"Fichier 1.txt\" \"Fichier 2.txt\" do echo \"Traitement de $fichier\" done\rBonnes pratiques avec la boucle for Liste explicite : Utilisez une liste statique ou une séquence simple :\nfor i in {1..10}\rMotifs et fichiers : Parcourez les fichiers d’un répertoire avec des motifs :\nfor fichier in *.txt\rCommandes dynamiques : Créez une liste à partir du résultat d’une commande :\nfor utilisateur in $(who | awk '{print $1}')\rGuillemets : Protégez les éléments avec des espaces :\nfor fichier in \"file 1\" \"file 2\"\rNous verrons cette commande plus en détails au prochain cours. ↩︎ ↩︎",
    "description": "Séquence de démarrage de Linux Le processus de démarrage de Linux est une série d’étapes qui se déroulent depuis l’allumage de l’ordinateur jusqu’à l’affichage de l’invite de commande ou de l’interface graphique. Comprendre ce processus est essentiel pour diagnostiquer et résoudre les problèmes de démarrage.\nLorsqu’un système Linux démarre, plusieurs étapes se succèdent de manière ordonnée pour préparer la machine et le système d’exploitation à fonctionner. Voici les étapes principales :",
    "tags": [],
    "title": "Processus de démarrage, cibles, variables et boucle For",
    "uri": "/semaine3/cours/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Processus de démarrage, variables et FOR",
    "content": "Objectifs de l’atelier Se familiariser avec les cibles (niveaux d’exécution). Comprendre les bases des variables utilisateur en Bash. Apprendre à manipuler et utiliser des variables pour stocker des résultats de commandes. Atelier Exercice 1 : Manipuler les cibles (niveaux d’exécution) Utiliser la commande systemctl pour passer en mode multi-utilisateur sans interface graphique Vérifier que vous êtes maintenant en mode multi-utilisateur sans interface graphique. Définir le mode multi-utilisateur avec interface graphique comme cible par défaut. Redémarrer votre système pour vérifier que le mode graphique est bien la cible par défaut. Exercice 2 : Création et affichage de variables Déclarez une variable nom avec votre prénom. Affichez la valeur de la variable. Essayez d’accéder à la variable sans $. Notez la différence. Exercice 3 : Capturer une date formatée Stockez la date actuelle dans une variable date_actuelle avec le format AAAA/MM/JJ hh:mm:ss. Affichez la date formatée. Exercice 4 : Supprimer une variable Déclarez une variable temporaire. Supprimez la variable avec unset. Essayez d’afficher la variable supprimée. Exercice 5: Expansion de variables et d’accolades Créer une variable variable_etc contenant la liste des fichiers du répertoire /etc et l’afficher. Son contenu est-il facile à lire ? Que se passe-t-il si vous exécutez ls suivi du nom de votre variable ? Pourquoi ? Sachant que beaucoup de fichiers de configuration se terminent par .conf, les trouver et stocker leur nom dans une variable. Que se passe-t-il si vous exécutez ls suivi du nom de votre variable? Seriez-vous capable d’afficher la taille de chacun des fichiers de configuration ? La commande du -sh \u003cfichier\u003e permet d’afficher la taille de fichier. Créer un répertoire dans lequel vous créerez les fichiers suivants à l’aide de la commande touch en utilisant la syntaxe permettant de factoriser une commande: test1.txt, test2.txt, test3.txt, test1.doc, test2.doc, test3.doc, test1.tot, test2.tot, test3.tot Grâce aux caractères génériques, n’afficher que les fichiers .txt qui commencent par test (plusieurs possibilités existent, essayez de les trouver). a. Tous les fichiers .txt et .tot`. b. Tous les fichiers test1 Exercice 6: Expansion d’accolade et boucle for En faisant cet exercice, vérifiez pour cette question le résultat de vos commandes en utilisant la commande tree. La figure ci-dessous montre un exemple d’utilisation de cette commande. Assurez-vous d’être revenu dans votre répertoire personnel À l’aide d’une seule commande et en utilisant l’expansion d’accolade, créez l’arborescence des dossiers suivante : À l’aide d’une seule commande et en utilisant l’expansion d’accolade, créer le fichier vide priseNote dans chaque répertoire lab. À l’aide d’une boucle for, renommer les fichier priseNote en priseNote.txt. À l’aide d’une boucle for, déplacer les fichiers priseNote.txt du répertoire lab vers le répertoire leçon correspondant.",
    "description": "Objectifs de l’atelier Se familiariser avec les cibles (niveaux d’exécution). Comprendre les bases des variables utilisateur en Bash. Apprendre à manipuler et utiliser des variables pour stocker des résultats de commandes. Atelier Exercice 1 : Manipuler les cibles (niveaux d’exécution) Utiliser la commande systemctl pour passer en mode multi-utilisateur sans interface graphique Vérifier que vous êtes maintenant en mode multi-utilisateur sans interface graphique. Définir le mode multi-utilisateur avec interface graphique comme cible par défaut. Redémarrer votre système pour vérifier que le mode graphique est bien la cible par défaut. Exercice 2 : Création et affichage de variables Déclarez une variable nom avec votre prénom. Affichez la valeur de la variable. Essayez d’accéder à la variable sans $. Notez la différence. Exercice 3 : Capturer une date formatée Stockez la date actuelle dans une variable date_actuelle avec le format AAAA/MM/JJ hh:mm:ss. Affichez la date formatée. Exercice 4 : Supprimer une variable Déclarez une variable temporaire. Supprimez la variable avec unset. Essayez d’afficher la variable supprimée. Exercice 5: Expansion de variables et d’accolades Créer une variable variable_etc contenant la liste des fichiers du répertoire /etc et l’afficher. Son contenu est-il facile à lire ? Que se passe-t-il si vous exécutez ls suivi du nom de votre variable ? Pourquoi ? Sachant que beaucoup de fichiers de configuration se terminent par .conf, les trouver et stocker leur nom dans une variable. Que se passe-t-il si vous exécutez ls suivi du nom de votre variable? Seriez-vous capable d’afficher la taille de chacun des fichiers de configuration ? La commande du -sh \u003cfichier\u003e permet d’afficher la taille de fichier. Créer un répertoire dans lequel vous créerez les fichiers suivants à l’aide de la commande touch en utilisant la syntaxe permettant de factoriser une commande: test1.txt, test2.txt, test3.txt, test1.doc, test2.doc, test3.doc, test1.tot, test2.tot, test3.tot Grâce aux caractères génériques, n’afficher que les fichiers .txt qui commencent par test (plusieurs possibilités existent, essayez de les trouver). a. Tous les fichiers .txt et .tot`. b. Tous les fichiers test1 Exercice 6: Expansion d’accolade et boucle for En faisant cet exercice, vérifiez pour cette question le résultat de vos commandes en utilisant la commande tree. La figure ci-dessous montre un exemple d’utilisation de cette commande. Assurez-vous d’être revenu dans votre répertoire personnel À l’aide d’une seule commande et en utilisant l’expansion d’accolade, créez l’arborescence des dossiers suivante :",
    "tags": [],
    "title": "ATELIER #3: Cibles et variables utilisateurs et for",
    "uri": "/semaine3/atelier/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "Plan de la leçon Théorie :\nLes entrées et sorties des commandes. La redirection des entrées et sorties. Les Pipelines. Les commandes de filtrage courantes. La boucle while. Atelier :\nRedirection des entrées et sorties. Utilisation de pipelines. Utilisation des commandes de filtrage. Itération avec While.",
    "description": "Plan de la leçon Théorie :\nLes entrées et sorties des commandes. La redirection des entrées et sorties. Les Pipelines. Les commandes de filtrage courantes. La boucle while. Atelier :\nRedirection des entrées et sorties. Utilisation de pipelines. Utilisation des commandes de filtrage. Itération avec While.",
    "tags": [],
    "title": "E/S, redirection et filtrage de commandes et While",
    "uri": "/semaine4/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e E/S, redirection et filtrage de commandes et While",
    "content": "Les concepts d’entrées/sorties, de redirection, de filtres, de pipelines et l’utilisation des boucles pour automatiser des tâches sont des bases essentielles pour manipuler efficacement des données.\nLes entrées et sorties des commandes Qu’est-ce que l’entrée (input) ? L’entrée (standard input ou stdin) est une source d’information qu’une commande peut utiliser. Par défaut, l’entrée provient du clavier.\nQu’est-ce que la sortie (output) ? La sortie (standard output ou stdout) est l’endroit où une commande affiche ses résultats. Par défaut, cette sortie s’affiche dans le terminal.\nQu’est-ce que la sortie d’erreur (stderr) ? La sortie d’erreur (standard error ou stderr) est où les messages d’erreur sont affichés. Par défaut, elle s’affiche également dans le terminal.\nLa redirection La redirection permet de changer la source d’entrée ou la destination des sorties pour enregistrer ou réutiliser des données facilement.\nInformation\rNous ne verrons pas la redirection à l’aide de \u003c. Cependant, vous pouvez rediriger stdin pour lire des données à partir d’un fichier ou d’une autre commande, en récupérant la sortie standard d’une autre commande grâce au pipeline (vu plus loin).\nRediriger la sortie standard (stdout) Pour envoyer le résultat d’une commande dans un fichier :\ncommande \u003e fichier.txt\rExemple :\n$ echo \"Bonjour !\" \u003e bonjour.txt\rAjouter à un fichier existant Pour ajouter une sortie à la fin d’un fichier existant sans écraser son contenu :\ncommande \u003e\u003e fichier.txt\rExemple :\n$ echo \"Encore une ligne.\" \u003e\u003e bonjour.txt\rRediriger la sortie standard avec 1\u003e La redirection explicite de stdout s’écrit :\ncommande 1\u003e fichier.txt\rCeci a le même effet que \u003e.\nRediriger la sortie d’erreur (stderr) Pour enregistrer les erreurs dans un fichier :\ncommande 2\u003e erreurs.txt\rCombiner stdout et stderr Pour rediriger les deux vers un même fichier :\ncommande \u003e fichier.txt 2\u003e\u00261\rPour rediriger la sortie d’erreur standard vers la sortie standard et envoyer le tout dans un fichier\n$ find / -name services \u003eresultats.txt 2\u003e\u00261\rRedirection vers /dev/null Pour ignorer la sortie d’une commande, vous pouvez la rediriger vers /dev/null :\ncommande \u003e /dev/null\rExemple :\n$ ls dossier_inexistant \u003e /dev/null 2\u003e\u00261\rIci, la commande ls tente d’afficher le contenu d’un dossier inexistant, et ses messages (sortie standard et erreurs) sont redirigés vers /dev/null pour être ignorés.\nUtiliser un fichier comme entrée Pour utiliser un fichier comme source d’entrée :\ncommande \u003c fichier.txt\rExemple :\n$ sort \u003c liste.txt\rExercices 1 : Entrées/Sorties\nSans être root et sans utiliser sudo, rechercher le fichier services sur tout le disque dur. Est-ce facile de le trouver dans la sortie de la commande ? Faites la même recherche mais en redirigeant les lignes “Accès refusé” vers le fichier /dev/null. Est-ce plus facile de trouver le résultat de la commande ? Sauvegardez le résultat dans le fichier ~/services.txt à l’aide d’une redirection. Les filtres Un filtre est une commande qui traite une entrée pour produire une sortie modifiée. Voici les filtres les plus courants :\nCommande Description Options et descriptions grep Recherche des lignes contenant un mot ou une expression. -i : Ignore la casse \\n -r : Recherche récursive\\n -v : Inverse la recherche\\n -n : Affiche les numéros de ligne sort Trie les lignes d’un fichier. -r : Ordre inverse\\n -n : Tri numérique\\n -k : Tri par clé spécifique uniq Supprime les doublons dans une liste triée. -c : Compte les occurrences\\n -d : Affiche les doublons uniquement wc Compte le nombre de lignes, mots ou caractères. -l : Compte les lignes\\n -w : Compte les mots\\n -c : Compte les caractères sed Modifie le contenu des lignes selon des motifs. -e : Applique plusieurs commandes\\n -i : Modifie en place find Recherche des fichiers ou dossiers selon des critères. -name : Recherche par nom\\n -type : Recherche par type (dossier ou fichier) cut Extrait des sections de chaque ligne d’un fichier. -d : Spécifie le délimiteur\\n -f : Spécifie les champs à extraire tr Traduit ou supprime des caractères. -d : Supprime des caractères\\n -s : Remplace des séquences répétées Exemples grep : Recherche des lignes contenant un mot ou une expression. $ grep \"mot\" fichier.txt\rsort : Trie les lignes d’un fichier. $ sort fichier.txt\runiq : Supprime les doublons dans une liste triée. $ sort fichier.txt | uniq\rwc : Compte le nombre de lignes, mots ou caractères. $ wc fichier.txt\rsed : Modifie le contenu des lignes selon des motifs. $ sed 's/ancien/nouveau/g' fichier.txt\rExemple : Remplacer “erreur” par “avertissement” dans un fichier : $ sed 's/erreur/avertissement/g' journal.txt\rfind : Recherche des fichiers ou dossiers selon des critères. $ find . -name \"*.txt\"\rcut : Extrait des sections de chaque ligne d’un fichier. $ cut -d':' -f1 fichier.txt\rExemple : Extraire le premier champ d’un fichier où les champs sont séparés par des deux-points (:). $ cut -d':' -f1 liste.txt\rtr : Traduit ou supprime des caractères. $ tr 'a-z' 'A-Z' \u003c fichier.txt\rExemple : Convertir tout le texte en majuscules. Les pipelines Les pipelines (ou “pipes”) permettent de connecter plusieurs commandes ensemble. Le symbole | transmet la sortie d’une commande comme entrée à une autre.\nExemples $ cat fichier.txt | grep \"mot\" | sort\rcat fichier.txt : Lit le fichier.\ngrep \"mot\" : Filtre les lignes contenant “mot”.\nsort : Trie les lignes filtrées.\nPour afficher les 5 mots les plus fréquents dans un texte :\ncat texte.txt | tr -s ' ' '\\n' | sort | uniq -c | sort -nr | head -5\rtr -s ' ' : Transforme les espaces multiples en simples et ajoute des sauts de ligne.\nuniq -c : Compte les occurrences de chaque mot.\nsort -nr : Trie par ordre décroissant des fréquences.\nhead -5 : Affiche les 5 premiers.\nRedirection de l’entrée standard (\u003c)\nVous pouvez utiliser un fichier en entrée dans un pipeline. Par exemple, pour afficher les lignes contenant “erreur” dans un fichier trié :\n$ grep \"erreur\" \u003c journal.txt | sort\rExercices 2 : Filtres et pipe\nEn utilisant le | et les filtres, trouvez le numéro de port de zephyr-srv dans le fichier /etc/services. Dans le fichier /etc/services, combien y a-t-il de lignes qui ne contiennent pas de e? Et combien de lignes ne contiennent ni e ni a ? Automatiser avec la boucle while Les boucles permettent de répéter des commandes sur un ensemble d’éléments.\nSyntaxe de la boucle while Voici la forme générale d’une boucle while en ligne de commande :\nwhile [ condition ]; do # Actions à répéter commande1 commande2 ... done\rcondition : C’est ce que le programme vérifie à chaque fois. do…done : Tout le code entre do et done sera répété tant que la condition est vraie. Exemples Compter de 1 à 5 compteur=1; while [ $compteur -le 5 ]; do echo \"Compteur : $compteur\"; compteur=$((compteur + 1)); done\rcompteur=1 : On commence avec le chiffre 1. [ $compteur -le 5 ] : La condition signifie “tant que le compteur est inférieur ou égal à 5”. echo : Affiche le compteur. compteur=$((compteur + 1)) : On ajoute 1 au compteur à chaque tour. Affichera :\nCompteur : 1\rCompteur : 2\rCompteur : 3\rCompteur : 4\rCompteur : 5\rLire un fichier ligne par ligne et afficher chaque ligne : while read ligne; do echo \"Ligne : $ligne\" done \u003c fichier.txt\rread ligne : Lit chaque ligne du fichier. echo : Affiche le contenu de la ligne. Renommer tous les fichiers .txt d’un répertoire pour ajouter le suffixe _backup : find . -name \"*.txt\" | while read fichier; do mv \"$fichier\" \"${fichier%.txt}_backup.txt\" done\rfind : Trouve tous les fichiers .txt. mv : Renomme chaque fichier en ajoutant “_backup”. Demander un mot de passe à l’utilisateur mot_de_passe=\"secret\"; reponse=\"\"; while [ \"$reponse\" != \"$mot_de_passe\" ]; do echo \"Entrez le mot de passe :\"; read reponse; done; echo \"Mot de passe correct !\"\rmot_de_passe=\"secret\" : Le mot de passe attendu est “secret”. read reponse : Demande à l’utilisateur de taper une réponse. [ \"$reponse\" != \"$mot_de_passe\" ] : Tant que la réponse n’est pas égale au mot de passe, la boucle continue. Cette commande, demandera le mot de passe jusqu’à ce que l’utilisateur tapes “secret”.\nBoucles infinie Attention aux boucles infinies\rSi la condition ne devient jamais fausse, la boucle ne s’arrêtera pas. Par exemple :\n$ while true; do echo \"Ceci ne s'arrête jamais !\"; sleep 1; done\rInformation\rUtilise Ctrl + C pour arrêter une boucle infinie. Exercices 3 : While et autres commandes\nRecherchez tous les fichiers de configuration du système (on considère qu’ils se terminent par .conf) puis n’affichez que le nom du fichier sans le chemin. La commande basename /rep1/rep2/…/fichier.txt affiche seulement fichier.txt. Une fois l’exercice terminé, classez les résultats par ordre alphabétique. Avec une boucle while, parcourez le fichier /etc/services et pour chaque ligne, ne garder que le 1er champs en utilisant comme délimiteur ‘ ’ (espace). Une fois terminé, éliminez les doublons et comptez le nombre de lignes.",
    "description": "Les concepts d’entrées/sorties, de redirection, de filtres, de pipelines et l’utilisation des boucles pour automatiser des tâches sont des bases essentielles pour manipuler efficacement des données.\nLes entrées et sorties des commandes Qu’est-ce que l’entrée (input) ? L’entrée (standard input ou stdin) est une source d’information qu’une commande peut utiliser. Par défaut, l’entrée provient du clavier.\nQu’est-ce que la sortie (output) ? La sortie (standard output ou stdout) est l’endroit où une commande affiche ses résultats. Par défaut, cette sortie s’affiche dans le terminal.",
    "tags": [],
    "title": "Entrées/Sorties, redirection, filtres, pipeline des commandes et while",
    "uri": "/semaine4/cours/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e E/S, redirection et filtrage de commandes et While",
    "content": "Objectifs de l’atelier Se familiariser avec les entrées/sorties et la redirection des commandes. Combinaison de commandes. Filtrage de données. Utilisation de l’itération avec la boucle While. Atelier Astuce\rPour effectuer des opérations simple, vous pouvez utiliser la commande bc de cette façon: $ echo 7-3 | bc\rExercice 1 Ouvrez une session avec l’utilisateur standard et reproduisez, dans le répertoire courant, l’arborescence suivante et ce en utilisant un maximum de trois commandes : ├── H2025\r│ ├── Linux\r│ │ ├── Cours\r│ │ └── Ateliers\r│ └── Virtualisation\r│ └── machines\r└── Personnel\rChangez de répertoire en allant dans le dossier Notes. En saisissant une seule commande, créez, à l’intérieur du répertoire courant, les dossiers semaine1, semaine2, …semaine15. Vous ne devez pas à entrer tous les noms de semaines dans la commande. En une seule commande, faites-en-sorte que dans chacun des dossiers précédents (semaine1..), un fichier est créé et qui contient la ligne suivante : Ce cours concerne la semaineN Où N correspond au numéro de la semaine.\nToujours à partir du répertoire courant, utilisez le chemin relatif pour copier dans le dossier Travaux le fichier passwd qui est dans /etc. Toujours à partir du répertoire courant et en utilisant le chemin relatif, renommez le fichier copié en ajoutant « Copie » à son nom (passwdCopie) Changez le caractère délimiteur du fichier passwdCopie par ; Triez le contenu du fichier passwdCopie en ordre croissant du numéro de groupe, soit le quatrième champ. On veut que le fichier soit trié et non uniquement le résultat retourné par la commande. Exercice 2 Écrire la ligne de commande qui permet d’afficher le nombre d’utilisateurs qui ont pour shell par défaut un des shells disponibles sur votre machine. À l’exécution de la commande, on aurait pour chacun des shells un résultat de la même forme que le suivant: 0 utilisateurs ont pour shell /bin/sh\r11 utilisateurs ont pour shell /bin/bash\r0 utilisateurs ont pour shell /usr/bin/sh\r0 utilisateurs ont pour shell /usr/bin/bash\rVous ne devez pas indiquer manuellement les noms des shells.\nExercice 3 On veut savoir combien de dossiers et de fichiers standards et combien d’éléments qui ne sont ni des dossiers ni des fichiers standards contient le répertoire courant. Le résultat doit être affiché comme suit : Le répertoire nomdurépertoire contient N dossiers\rLe répertoire nomdurépertoire contient N fichiers standards\rLe répertoire nomdurépertoire contient N fichiers qui ne sont ni standards ni des répertoires\rnomdurépertoire est affiché automatiquement. N est le nombre trouvé. On veut afficher la liste de tous les fichiers standards (de toute l’arborescence) portant le nom du dernier utilisateur créé sur votre machine. Les messages d’erreurs sont redirigés vers /dev/null. Exercice 4 En une seule ligne de commande, trouvez tous les fichiers txt sur votre disque dur en tant qu’utilisateur standard et sans afficher les erreurs, afficher la taille de ces fichiers avec les unités et classer les par ordre de taille croissante.\nExercice 5: Caractères génériques et commande find Aller dans le répertoire /etc. Ne vous déplacez pas pour le reste de cet exercice. En utilisant la commande find, chercher les fichiers dont le nom commence par la lettre r à partir du répertoire courant. Chercher tous les fichiers dont le nom contient la chaîne de caractères “rc” à partir du répertoire courant. Afficher tous les fichiers dont le nom comporte trois caractères sur tout le système.",
    "description": "Objectifs de l’atelier Se familiariser avec les entrées/sorties et la redirection des commandes. Combinaison de commandes. Filtrage de données. Utilisation de l’itération avec la boucle While. Atelier Astuce\rPour effectuer des opérations simple, vous pouvez utiliser la commande bc de cette façon: $ echo 7-3 | bc\rExercice 1 Ouvrez une session avec l’utilisateur standard et reproduisez, dans le répertoire courant, l’arborescence suivante et ce en utilisant un maximum de trois commandes : ├── H2025\r│ ├── Linux\r│ │ ├── Cours\r│ │ └── Ateliers\r│ └── Virtualisation\r│ └── machines\r└── Personnel\rChangez de répertoire en allant dans le dossier Notes. En saisissant une seule commande, créez, à l’intérieur du répertoire courant, les dossiers semaine1, semaine2, …semaine15. Vous ne devez pas à entrer tous les noms de semaines dans la commande. En une seule commande, faites-en-sorte que dans chacun des dossiers précédents (semaine1..), un fichier est créé et qui contient la ligne suivante : Ce cours concerne la semaineN Où N correspond au numéro de la semaine.",
    "tags": [],
    "title": "ATELIER #4: Redirection, E/S, pipeline, filtres et while",
    "uri": "/semaine4/atelier/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "Plan de la leçon Théorie :\nQu’est-ce qu’un processus ? Exemples de processus. L’exécution en arrière-plan. Visualiser les processus. Les états des processus. La gestion des processus. Le code de retour des commandes. Les combinaison de commandes. La création de scripts bash. Atelier :\nGestion et manipulation de processus à l’aide de scripts.",
    "description": "Plan de la leçon Théorie :\nQu’est-ce qu’un processus ? Exemples de processus. L’exécution en arrière-plan. Visualiser les processus. Les états des processus. La gestion des processus. Le code de retour des commandes. Les combinaison de commandes. La création de scripts bash. Atelier :\nGestion et manipulation de processus à l’aide de scripts.",
    "tags": [],
    "title": "Les processus Linux",
    "uri": "/semaine5/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Les processus Linux",
    "content": "Objectifs de l’atelier Manipuler les processus sous Linux en utilisant des commandes de base. Comprendre et explorer les différents types de processus sous Linux. Apprendre à lister, gérer et contrôler les processus. Manipuler les processus en premier plan et en arrière-plan. Remise Vous devez remettre sur Moodle :\nVos deux fichiers .sh Deux captures d’écran illustrant le fonctionnement des scripts : Capture Contenu 01_nombre_de_fichiers_seq.png Appel au script séquentiel et résultats 02_nombre_de_fichiers_conc.png Appel au script concurrent et résultats Atelier Dans cet atelier, vous apprendrez à créer deux scripts Bash :\nl’un avec des commandes séquentielles et l’autre avec des commandes exécutées de manière asynchrone. Ces scripts vous permettront de mieux comprendre les différences entre l’exécution séquentielle et concurrente.\nAstuces et rappels Stocker une valeur dans une variable Pour stocker le nombre de fichiers présents dans un répertoire :\nnb=$(ls | wc -l)\rCette commande place le nombre de fichiers dans la variable nb.\nTester la valeur d’une variable Pour comparer une variable à un chiffre :\ntest $nb -eq 10\rCette commande vérifie si nb est égal à 10. Si c’est le cas, le code de retour sera 0, sinon il sera différent de 0.\nVous pouvez combiner cette commande avec des opérateurs logiques :\ntest $nb -eq 10 \u0026\u0026 echo \"Les deux valeurs sont égales\" || echo \"Les deux valeurs sont différentes\"\rParcourir une variable avec une boucle for Pour parcourir une liste de serveurs :\nserveurs=\"google.com facebook.com youtube.com\" for i in $serveurs; do echo $i; done\rChaque élément de la variable serveurs sera affiché séparément.\nConseils supplémentaires Pour mesurer les performances des scripts, utilisez la commande time. Comparez les temps d’exécution pour comprendre l’intérêt de la concurrence. Exercice 1 : Script séquentiel Créer un script Bash nommé nombre_de_fichiers_seq.sh pour compter le nombre de fichiers par type. Aide pour l’exercice Ce script doit compter et afficher le nombre de fichiers pour chaque type suivant : java, conf, txt, png, tiff.\nStructure de base\nAjoutez cette ligne au début du script :\ntypes=\"java conf txt png tiff\"\rFonctionnalités à implémenter\nCompter le nombre de fichiers pour chaque type. Afficher un message si aucun fichier n’est trouvé. Ne pas afficher d’autres messages. Exemple de sortie\nDécompte des fichiers java conf txt png tiff Il y a 50718 fichiers .java Il y a 1171 fichiers .conf Il y a 6999 fichiers .txt Il y a 67296 fichiers .png Il n’y a aucun fichier .tiff\rExercice 2 : Script concurrent Créer une version concurrente de ce script nommée nombre_de_fichiers_conc.sh, en utilisant des commandes asynchrones (\u0026). Aide pour l’exercice Ce script doit être une version améliorée de nombre_de_fichiers_seq.sh, en exécutant les commandes de manière asynchrone.\nFonctionnalités à implémenter\nUtiliser \u0026 pour exécuter les commandes find en arrière-plan. Regrouper les processus dans un sous-processus avec (CMD1; CMD2; ...) \u0026. Utiliser la commande wait à la fin pour attendre la fin de tous les processus en arrière-plan. Exemple de sortie\nDécompte des fichiers java conf txt png tiff Il y a 1171 fichiers .conf Il n’y a aucun fichier .tiff Il y a 67296 fichiers .png Il y a 50718 fichiers .java Il y a 6999 fichiers .txt",
    "description": "Objectifs de l’atelier Manipuler les processus sous Linux en utilisant des commandes de base. Comprendre et explorer les différents types de processus sous Linux. Apprendre à lister, gérer et contrôler les processus. Manipuler les processus en premier plan et en arrière-plan. Remise Vous devez remettre sur Moodle :\nVos deux fichiers .sh Deux captures d’écran illustrant le fonctionnement des scripts : Capture Contenu 01_nombre_de_fichiers_seq.png Appel au script séquentiel et résultats 02_nombre_de_fichiers_conc.png Appel au script concurrent et résultats Atelier Dans cet atelier, vous apprendrez à créer deux scripts Bash :",
    "tags": [],
    "title": "ATELIER #5: Gestion des processus Linux",
    "uri": "/semaine5/atelier/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "Plan de la leçon Théorie :\nRôles des expressions régulières. Quelques motifs de base. La commande egrep. L’opérateur logique OU. Les ensembles de caractères. Les intervalles. Les quantificateurs. Les groupes. L’échappement de caractères spéciaux. Atelier :.\nUtilisation d’expressions régulières.",
    "description": "Plan de la leçon Théorie :\nRôles des expressions régulières. Quelques motifs de base. La commande egrep. L’opérateur logique OU. Les ensembles de caractères. Les intervalles. Les quantificateurs. Les groupes. L’échappement de caractères spéciaux. Atelier :.\nUtilisation d’expressions régulières.",
    "tags": [],
    "title": "Les expressions régulières",
    "uri": "/semaine6/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Les expressions régulières",
    "content": "Introduction aux expressions régulières Dans l’univers Linux, la manipulation des fichiers texte est une tâche essentielle. Parmi les outils utilisés pour ce faire, on trouve notamment :\ncat : pour afficher le contenu des fichiers, sed : pour les transformations textuelles, grep : pour rechercher et filtrer des lignes. Avec grep, vous pouvez filtrer un texte pour ne conserver que les lignes contenant un mot ou une expression donnée, ou bien les exclure. Mais comment faire si vous souhaitez rechercher des motifs plus complexes, comme des adresses e-mail ou des numéros de téléphone ? C’est ici qu’interviennent les expressions régulières, un outil puissant pour décrire des motifs précis et identifier des textes ayant une structure particulière.\nExemple : URL Web Un exemple d’expression régulière pour capturer une URL Web :\nhttps?://[a-zA-Z0-9\\.-]+\\.[a-zA-Z]{2,4}(/\\S*)?\rPremiers pas avec les expressions régulières Voici quelques motifs de base et leurs significations :\nMotif Description Exemple Contre-exemple ab Recherche la chaîne exacte “ab”. “ab” “a”, “b”, chaîne vide . Correspond à n’importe quel caractère. “a”, “b” “ab”, chaîne vide ^ Indique le début d’une ligne. ^a : un “a” au début. Toute ligne ne commençant pas par “a”. $ Indique la fin d’une ligne. a$ : un “a” à la fin. Toute ligne ne se terminant pas par “a”. Commandes pratiques avec egrep La commande egrep est une version avancée de grep, qui prend en charge les expressions régulières étendues (ERE).\nRechercher les lignes contenant “ssh” dans un fichier :\n$ egrep 'ssh' /etc/services\rRechercher uniquement les commentaires (lignes commençant par #) :\n$ egrep '^#' /etc/services\rRechercher les lignes se terminant par “s” :\n$ egrep 's$' /etc/services\rRechercher les lignes contenant “a” et “z” séparées par un caractère quelconque :\n$ egrep 'a.z' /etc/services\rOpérateurs logiques Le OU (|) L’opérateur | permet de rechercher des lignes contenant l’une ou l’autre des expressions spécifiées.\nExemple : Filtrer les lignes contenant “ssh” ou “ftp” :\n$ egrep 'ssh|ftp' /etc/services\rFiltrer les commentaires ou les lignes se terminant par “s” :\n$ egrep '^#|s$' /etc/services\rEnsembles de caractères Les ensembles permettent de rechercher plusieurs possibilités similaires en regroupant des caractères entre crochets [ ].\nExemple : Rechercher “loucher”, “toucher”, “doucher”, ou “coucher” :\n$ egrep '[ltdc]oucher' fichier\rExclure ces mots tout en recherchant ceux contenant “oucher” :\n$ egrep '[^ltdc]oucher' fichier\rIntervalles Ensemble Description [a-z] Toutes les lettres minuscules. [A-Z] Toutes les lettres majuscules. [0-9] Tous les chiffres. [a-zA-Z0-9] Tous les caractères alphanumériques. Important\rUn ensemble décrit un seul caractère. Rechercher des mots contenant un “f” et un “p” séparés par une lettre minuscule :\n$ egrep 'f[a-z]p' /etc/services\rRechercher les lignes commençant par un chiffre :\n$ egrep '^[0-9]' /etc/services\rExclure les commentaires :\n$ egrep '^[^#]' /etc/services\rQuantificateurs Les quantificateurs précisent le nombre de répétitions d’un motif.\nQuantificateur Signification ? 0 ou 1 fois. + 1 ou plusieurs fois. * 0 ou plusieurs fois. {n} Exactement n fois. {n,m} Entre n et m fois. {n,} Au moins n fois. Rechercher “www” dans un texte :\n$ egrep 'w{3}' fichier\rRechercher “http” ou “https” :\n$ egrep 'https?' fichier\rRechercher une lettre minuscule répétée entre 3 et 6 fois :\n$ egrep '[a-z]{3,6}' fichier\rGroupes Les groupes permettent de regrouper des parties d’expressions avec des parenthèses ( ). Cela permet d’appliquer un quantificateur ou de réutiliser le groupe.\nExemple : (ab)*c\rCorrespond à : “zéro ou plusieurs ‘ab’, suivi d’un ‘c’”. Cela capture “c”, “abc”, “ababc”, etc. Échappement Pour rechercher des caractères ayant une signification spéciale dans les expressions régulières (., +, *, etc.), il faut les échapper avec un antislash ().\nExemple : Rechercher les lignes se terminant par un point : $ egrep '\\.$' fichier\rExercices pratiques Trouvez les numéros de cartes de crédit valides (16 chiffres, commençant par 4540 et sans 9 dans le dernier groupe) :\n4540 6010 4510 8888\r5440 5010 6610 1010\r4540 7010 4428 5490\r4540 8523 4013 1314\r4540 8710 5410 1012 1314\rIdentifiez les noms de variables valides (lettres, chiffres, underscores, mais ne commençant pas par un chiffre) :\nAbcd\rabcd_\rvar123\r_var2\r1nombre\rRecherchez les adresses IPv4 valides (quatre nombres entre 0 et 255, séparés par des points) :\n1.240.40.15\r2.256.20.190\r192.168.255.255\r300.200.100.10\r30.40.50.60\r192.168.2\r10.10.10.10.10",
    "description": "Introduction aux expressions régulières Dans l’univers Linux, la manipulation des fichiers texte est une tâche essentielle. Parmi les outils utilisés pour ce faire, on trouve notamment :\ncat : pour afficher le contenu des fichiers, sed : pour les transformations textuelles, grep : pour rechercher et filtrer des lignes. Avec grep, vous pouvez filtrer un texte pour ne conserver que les lignes contenant un mot ou une expression donnée, ou bien les exclure. Mais comment faire si vous souhaitez rechercher des motifs plus complexes, comme des adresses e-mail ou des numéros de téléphone ? C’est ici qu’interviennent les expressions régulières, un outil puissant pour décrire des motifs précis et identifier des textes ayant une structure particulière.",
    "tags": [],
    "title": "Les expressions régulières",
    "uri": "/semaine6/cours/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Les expressions régulières",
    "content": "Objectif de l’atelier Maîtriser les bases des expressions régulières. Renforcer la capacité à manipuler des fichiers texte. Renforcer la précision dans la recherche et le filtrage de données. Atelier Important\rUtiliser le fichier expr.txt se trouvant sur Moodle. Utiliser seulement la matière vue dans le cours (semaines 1 à 6). Utiliser des expressions régulières courtes et simples au lieu d’expressions complexes et longues. Dans le fichier fourni:\nTrouvez les codes postaux canadiens :\nFormat attendu : Lettre-Chiffre-Lettre Chiffre-Lettre-Chiffre. Identifiez les codes d’employés composés de :\nDeux lettres majuscules suivies de quatre chiffres. Comptez les lignes ne se terminant pas par une lettre :\nIdentifier les numéros de téléphone aux formats : (xxx)xxx-xxxx ou +1(xxx)xxx-xxxx.\nTrouver les URLs comme :\nhttp://www.domaine.tld ou http://www.domaine.tld/ https://www.domaine.tld ou https://www.domaine.tld/ Rechercher des adresses e-mail valides. Elles contiennent : des lettres majuscules ou minuscules, des chiffres et possiblement un ou plusieurs ‘_’ (tiret bas) et un ou plusieurs ‘.’ . Ensuite il y a forcément un ‘@’ puis d’autres caractères (lettres majuscules ou minuscules, chiffres, ‘.’, tiret bas ‘_’) Ensuite il y a obligatoirement un ‘.’ puis pour finir, Entre 2 et 6 lettres minuscules (.qc.ca) et Possiblement un ‘.’ à la fin Dans le fichier /etc/services:\nTrouver les lignes contenant “ssh” sans espace après.\nCompter les lignes totales et celles non vides.\nTrouver les lignes contenant soit udp soit tcp avec un numéro à trois chiffres.\nRechercher les mots de quatre lettres entourés d’espaces.\nIdentifier les mots avec exactement deux “a”.\nDans le fichier /etc/passwd:\nAssurez-vous que toutes les lignes contiennent deux nombres entre “:”.\nCompter les utilisateurs sans bash comme shell.",
    "description": "Objectif de l’atelier Maîtriser les bases des expressions régulières. Renforcer la capacité à manipuler des fichiers texte. Renforcer la précision dans la recherche et le filtrage de données. Atelier Important\rUtiliser le fichier expr.txt se trouvant sur Moodle. Utiliser seulement la matière vue dans le cours (semaines 1 à 6). Utiliser des expressions régulières courtes et simples au lieu d’expressions complexes et longues. Dans le fichier fourni:",
    "tags": [],
    "title": "ATELIER #6: Les expressions régulières",
    "uri": "/semaine6/atelier/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "Plan de la leçon Théorie :\nLes bases de l’utilisation de vim. Les principes de certains fichiers de configuration Linux. Présentation de vim. Atelier :.",
    "description": "Plan de la leçon Théorie :\nLes bases de l’utilisation de vim. Les principes de certains fichiers de configuration Linux. Présentation de vim. Atelier :.",
    "tags": [],
    "title": "Vim et les fichiers de configuration",
    "uri": "/semaine7/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Vim et les fichiers de configuration",
    "content": "L’éditeur de texte VIM Dans les systèmes Linux, la majorité des configurations s’effectuent à l’aide de fichiers texte.\nPour modifier ces fichiers texte, nous utiliserons l’éditeur de texte vim. c’est un éditeur puissant avec de nombreux avantages : • Disponible sur tous les systèmes basés sur UNIX, • Très léger, idéal pour les systèmes sans interface graphique, • Fonctionne en local ou à distance.\nApprendre à utiliser vim est indispensable pour travailler efficacement sous Linux.\nLes principaux modes de VIM vim propose 3 modes principaux pour travailler :\nMode normal (par défaut) : Interprète les touches comme des commandes (ex. copier, supprimer, naviguer). Utilisez la touche Échap (ESC) pour revenir à ce mode à tout moment. Mode visuel : Permet de sélectionner du texte. Activez-le avec : v : pour sélectionner des caractères, V : pour sélectionner des lignes entières. Mode insertion : Permet d’ajouter ou modifier du texte. Activez-le avec : i : insérer à l’endroit du curseur, a : insérer après le curseur, I : insérer au début de la ligne, A : insérer à la fin de la ligne. Navigation dans vim Voici les principales commandes pour se déplacer rapidement :\nAction Commande Un caractère à gauche h Un caractère à droite l Une ligne en bas j Une ligne en haut k Un mot à droite w Un mot à gauche b Début de la ligne 0 Fin de la ligne $ Aller à une ligne précise :numéro (ex. :100) Astuce\rVous pouvez ajouter un quantificateur pour répéter une commande. Exemple : 3w pour avancer de 3 mots, 50j pour descendre de 50 lignes.\nCommandes de base 1. Copier (commande y pour yank)\nÀ copier Commande Une ligne yy Jusqu’à la fin du mot yw Trois lignes 3yy 2. Coller (commande p ou P)\nAction Commande Coller après p minuscule Coller avant P majuscule Exemples avec Copier et Coller\nAction Commande Copier 3 mots y3w Coller 3 fois 3p 3. Modifier du texte\nAction Commande Remplacer un caractère r + (caractère) Remplacer plusieurs caractères R (mode remplacement, taper jusqu’à Échap) 4. Annuler et répéter\nAction Commande Annuler u (undo) Répéter la dernière commande . (point) 5. Supprimer du texte (couper)\na) Supprimer un caractère\nAction Commande Sous le curseur x minuscule Avant le curseur X majuscule b) Autres suppressions\nTexte à supprimer Commande Une ligne dd Jusqu’à la fin du mot dw Jusqu’à la fin de la ligne d$ Fichiers de configuration Linux Sous Linux, les fichiers texte sont utilisés pour gérer la configuration des systèmes. Voici les fichiers les plus courants.\nRéseau Fichier Rôle Exemple /etc/resolv.conf Configure les serveurs DNS nameserver 8.8.8.8 nameserver 8.8.4.4 /etc/hosts Associe des noms de machine à des adresses IP 192.168.1.1 serveur1 Personnalisation du shell Fichier Rôle Exemple ~/.bashrc Permet de créer des alias pour simplifier les commandes alias lh=\"ls -lh\" Autres fichiers utiles Fichier Rôle /etc/selinux/config Configure SELinux (sécurité). /etc/passwd et /etc/group Gèrent les utilisateurs et groupes. /etc/locale.conf Définit la langue du système. /etc/fstab Configure le montage des partitions. /etc/httpd/conf/httpd.conf Configure le serveur Apache. /etc/grub2.cfg Configure le gestionnaire de démarrage.",
    "description": "L’éditeur de texte VIM Dans les systèmes Linux, la majorité des configurations s’effectuent à l’aide de fichiers texte.\nPour modifier ces fichiers texte, nous utiliserons l’éditeur de texte vim. c’est un éditeur puissant avec de nombreux avantages : • Disponible sur tous les systèmes basés sur UNIX, • Très léger, idéal pour les systèmes sans interface graphique, • Fonctionne en local ou à distance.\nApprendre à utiliser vim est indispensable pour travailler efficacement sous Linux.",
    "tags": [],
    "title": "Vim et les fichiers de configuration",
    "uri": "/semaine7/cours/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Vim et les fichiers de configuration",
    "content": "Objectif de l’atelier Approfondir l’utilisation de VIM pour modifier des fichiers de configuration Linux de manière efficace. Modifier des fichiers de configuration Linux efficacement : Utiliser un minimum de touches. Ne pas utiliser la souris. Compléter les exercices : 10 exercices de type A (le curseur est déjà placé). 5 exercices de type B (le curseur commence au début du fichier). Instructions de remise Fournissez les captures d’écran des exercices réussis via Moodle.\nChaque capture doit montrer :\nLa modification effectuée. Le fichier sauvegardé dans l’état final. Exemple de capture attendue :\nUne vidéo de démonstration est disponible :\nAtelier Préparation Installation des outils Créez un fichier vim.sh avec le contenu suivant :\n#!/bin/bash wget http://gyoukou.ca/vimrc.dot || echo ERREUR mv vimrc.dot ~/.vimrc sudo yum install -y epel-release sudo yum install -y meld sudo yum groupinstall -y \"Development Tools\" sudo yum install -y git automake mkdir ~/tmp cd ~/tmp git clone https://github.com/kernc/logkeys.git cd logkeys ./autogen.sh cd build ../configure make sudo make install || echo ERREUR\rExécutez le script pour installer les outils requis :\n$ bash vim.sh\rTéléchargement des exercices Dans votre répertoire personnel, exécutez les commandes suivantes :\n$ cd ~ $ wget http://gyoukou.ca/atelier_06.tar.gz || echo ERREUR $ tar zxvf atelier_06.tar.gz $ cd atelier_06\rExercices de type A (curseur déjà placé) Exercice a01 Fichier de configuration /etc/default/grub\nModification à apporter Avant :\nGRUB_CMDLINE_LINUX=\"rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet\"\rAprès :\nGRUB_CMDLINE_LINUX=\"rd.lvm.lv=centos/root rd.lvm.lv=centos/swap quiet\"\rSupprimez rhgb pour désactiver le démarrage graphique.\nPerformances attendues Record à battre Maximum acceptable 4 touches 9 touches Commandes pour lancer l’exercice $ sh afficher_objectif.sh a01 $ sh exercice_vim.sh a01\rExercice a02 Fichier de configuration /etc/selinux/config\nModification à apporter Avant :\nSELINUX=enforcing\rAprès :\nSELINUX=disabled\rDésactivez SELinux.\nPerformances attendues Record à battre Maximum acceptable 7 touches 25 touches Commandes pour lancer l’exercice $ sh afficher_objectif.sh a02 $ sh exercice_vim.sh a02\rRépétez cette structure pour les autres exercices.\nExercices de type B (curseur au début du fichier) Exercice b01 Fichier de configuration /etc/ssh/sshd_config\nModification à apporter Avant :\n#X11Forwarding yes Après :\nX11Forwarding yes\rDécommentez la ligne pour activer la redirection graphique.\nPerformances attendues Record à battre Maximum acceptable 7 touches 18 touches Commandes pour lancer l’exercice $ sh afficher_objectif.sh b01 $ sh exercice_vim.sh b01\rContinuez avec cette structure pour les exercices restants.\n=====================================================\nAtelier 7b: vim avancé Cet atelier et l’atelier précédent forment l’atelier 7.\nObjectif Effectuer efficacement des modifications à des fichiers de configuration Linux NOTE: efficacement veut dire en moins de X touches, sans utiliser la souris Vous devez réussir: 10 exercices de type A (curseur déjà placé) 5 exercices de type B (curseur au début du fichier) Remise À remettre sur Moodle: Les captures d’écran:\nChaque capture d’écran correspond à un exercice réussi, p.ex:\nVoici un exemple d’exercice réussi: Voici comment l’exercice ci-haut s’est déroulé:\nAstuces: Utilisez ZZ pour sauvegarder et quitter dans vim.\nUtilisez les commandes données dans les images Aide mémoire en fin du cours pour avoir le record.\nTravail à effectuer Préambule Installation des outils nécessaires Copiez le texte suivant dans un script nommé vim.sh\n#!/bin/bash wget http://gyoukou.ca/vimrc.dot || echo ERREUR mv vimrc.dot ~/.vimrc sudo yum install -y epel-release sudo yum install -y meld sudo yum groupinstall -y \"Development Tools\" sudo yum install -y git automake mkdir ~/tmp cd ~/tmp git clone https://github.com/kernc/logkeys.git cd logkeys ./autogen.sh cd build ../configure make sudo make install || echo ERREUR\rExécutez le script :\nTélécharger et décompresser les exercices Exercices A: le curseur est déjà placé IMPORTANT: ne pas éditer directement les vrais fichiers de configuration. Editer plutôt la copie qui se trouve dans le dossier atelier téléchargé Exercice a01 Fichier de configuration /etc/default/grub\nConfiguration de grub (outil de démarrage) En particulier: options à donner au noyau Linux au démarrage Modification à apporter AVANT:\n1GRUB_CMDLINE_LINUX=\"rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet\"\rAPRÈS:\n1GRUB_CMDLINE_LINUX=\"rd.lvm.lv=centos/root rd.lvm.lv=centos/swap quiet\"\rEnlever rhgb désactive le démarrage graphique au profit de l’affichage d’un log (rhgb signifie Red Hat Graphical Boot) Nombre de touches Pour visualiser avec meld et lancer l’exercice Exercice a02 Fichier de configuration /etc/selinux/config\nselinux est un pare-feu d’application qui permet de contrôler ou limiter un grand nombre d’opérations sur un serveur Linux (selinux veut dire Security Enhanced Linux) Modification à apporter AVANT:\n1SELINUX=enforcing\rAPRÈS:\n1SELINUX=disabled\rOn déscative selinux (généralement préférable sur une machine usager) Nombre de touches Pour visualiser avec meld et lancer l’exercice Exercice a03 Fichier de configuration /etc/fstab\nListe des partitions utilisées dans le système Par défaut, chaque partition est montée au démarrage Modification à apporter AVANT:\n1/dev/mapper/centos-tmp /tmp xfs defaults 0 0\rAPRÈS:\nEn retirant une ligne, on efface la définition d’une partition Le répertoire /tmp devient un sous-répertoire de / (partition centos-root) Nombre de touches Pour visualiser avec meld et lancer l’exercice Exercice a04 Fichier de configuration /etc/locale.conf\nRégionalisation du système: langue, date, etc. Modification à apporter AVANT:\n1LC_TIME=\"\"\rAPRÈS:\n1LC_TIME=\"fr_CA.UTF-8\"\rOn veut copier fr_CA.UTF-8 entre les \" afin de définir aussi le format de date Nombre de touches Pour visualiser avec meld et lancer l’exercice Exercice a05 Fichier de configuration /etc/mime.types\nDéfinition des types de fichier et de leur extensions NOTE: la commande file affiche le type d’un fichier Modification à apporter AVANT:\n1application/3gpp-ims+xml 2application/activemessage 3application/andrew-inset\rAPRÈS:\n1application/3gpp-ims+xml\tinconnu 2application/activemessage\tinconnu 3application/andrew-inset\tinconnu\rOn ajoute l’extension inconnu pour les trois premiers types de fichier NOTE: il y a trois tabulations entre le type et l’extension Nombre de touches Pour visualiser avec meld et lancer l’exercice Exercice a06 Fichier de configuration /etc/hosts\nAssocie un nom réseau à son adresse Pour ces noms, le système ne fera pas de requête DNS (aussi avantageux pour faire des tests) NOTE: ce fichier existe aussi en Windows Modification à apporter AVANT:\n1206.167.24.30 ciboulot.ca 2#172.17.0.30 ciboulot.ca APRÈS:\n1#206.167.24.30 ciboulot.ca 2172.17.0.30 ciboulot.ca\rOn met en commentaire l’adresse publique de ciboulot.ca On active l’adresse locale (seulement valide au Collège) Nombre de touches Pour visualiser avec meld et lancer l’exercice Exercice a07 Fichier de configuration /etc/firewalld/direct.xml\nRègles de pare-feu directes (écrites à la main) NOTE: l’autre option est de générer les règles via la commande firewall-cmd Modification à apporter AVANT:\n1 \u003crule priority=\"0\" table=\"filter\" ipv=\"ipv4\" chain=\"FORWARD\"\u003e-i PRIVE -o PUBLIC -j ACCEPT\u003c/rule\u003e 2 \u003crule priority=\"0\" table=\"filter\" ipv=\"ipv4\" chain=\"FORWARD\"\u003e-i PUBLIC -o PRIVE -m state --state RELATED,ESTABLISHED -j ACCEPT\u003c/rule\u003e 3 \u003crule priority=\"0\" table=\"nat\" ipv=\"ipv4\" chain=\"POSTROUTING\"\u003e-o PUBLIC -j MASQUERADE\u003c/rule\u003e\rAPRÈS:\n1 \u003crule priority=\"0\" table=\"filter\" ipv=\"ipv4\" chain=\"FORWARD\"\u003e-i 192.168.1.4 -o 10.33.50.3 -j ACCEPT\u003c/rule\u003e 2 \u003crule priority=\"0\" table=\"filter\" ipv=\"ipv4\" chain=\"FORWARD\"\u003e-i 10.33.50.3 -o 192.168.1.4 -m state --state RELATED,ESTABLISHED -j ACCEPT\u003c/rule\u003e 3 \u003crule priority=\"0\" table=\"nat\" ipv=\"ipv4\" chain=\"POSTROUTING\"\u003e-o 10.33.50.3 -j MASQUERADE\u003c/rule\u003e\rOn insère des vraies adresses IP à partir d’un patron NOTE: ces règles indique au système de faire du NAT Nombre de touches Pour visualiser avec meld et lancer l’exercice Exercice a08 Fichier de configuration ~/.bashrc\nPersonnalisation du SHELL Fichier lu à chaque ouverture du SHEL Modification à apporter AVANT:\nAPRÈS:\n1alias la=\"ls -a\"\rOn ajoute la ligne pour créer un alias NOTE: un alias est un raccourci pour une commande fréquemment utilisée. Nombre de touches Pour visualiser avec meld et lancer l’exercice Exercice a09 Fichier de configuration /etc/resolv.conf\nLe ou les serveur DNS à utiliser Modification à apporter AVANT:\n1nameserver 10.33.50.1\rAPRÈS:\n1nameserver 192.168.1.1\rOn change l’adresse DNS à 192.168.1.1 Nombre de touches Pour visualiser avec meld et lancer l’exercice Exercice a10 Fichier de configuration /etc/ssh/sshd_config\nConfiguration du serveur SSH Modification à apporter AVANT:\n1#X11Forwarding yes APRÈS:\n1X11Forwarding yes\rCertaines options sont déjà inscrites au fichier. Pour les activer, il suffit de les décommenter Ici, on active la redirection graphique Nombre de touches Pour visualiser avec meld et lancer l’exercice Exercices B: le curseur est au début du fichier IMPORTANT: ne pas éditer directement le fichier\nExercice b01 Fichier de configuration /etc/ssh/sshd_config\nConfiguration du serveur SSH Modification à apporter AVANT:\n1#X11Forwarding yes APRÈS:\n1X11Forwarding yes\rMême modification que a10, sauf que cette fois-ci le curseur n’est pas déjà placé Nombre de touches Pour visualiser avec meld et lancer l’exercice Exercice b02 Fichier de configuration /etc/default/grub\nConfiguration de grub (outil de démarrage) En particulier: options à donner au noyau Linux au démarrage Modification à apporter AVANT:\n1GRUB_CMDLINE_LINUX=\"rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet\"\rAPRÈS:\n1GRUB_CMDLINE_LINUX=\"rd.lvm.lv=centos/root rd.lvm.lv=centos/swap quiet\"\rMême modification que a01, sauf que le curseur n’est pas déjà placé Nombre de touches Pour visualiser avec meld et lancer l’exercice Exercice b03 Fichier de configuration /etc/services\nListe des services réseau, protocoles et ports Modification à apporter AVANT:\n1systat 11/tcp users 2systat 11/udp users 3daytime 13/tcp 4daytime 13/udp 5qotd 17/tcp quote 6qotd 17/udp quote 7msp 18/tcp # message send protocol (historic) 8msp 18/udp # message send protocol (historic) 9chargen 19/tcp ttytst source 10chargen 19/udp ttytst source 11ftp-data 20/tcp\rAPRÈS:\nEffacer les services du ports 11 jusqu’au port 20 (inclusif) Nombre de touches Pour visualiser avec meld et lancer l’exercice Exercice b04 Fichier de configuration /etc/passwd\nInformation sur les usagers Linux Modification à apporter AVANT:\n1gnome-initial-setup:x:984:977::/run/gnome-initial-setup/:/sbin/nologin 2tcpdump:x:72:72::/:/sbin/nologin 3avahi:x:70:70:Avahi mDNS/DNS-SD Stack:/var/run/avahi-daemon:/sbin/nologin 4apache:x:48:48:Apache:/usr/share/httpd:/sbin/nologin\rAPRÈS:\nOn efface les 4 dernières lignes NOTE: habituellement, ces lignes sont effacées par la commande userdel Nombre de touches Pour visualiser avec meld et lancer l’exercice Exercice b05 Fichier de configuration /etc/group\nListe des groupes d’usagers Linux Chaque usager est membre de son propre groupe Un usager membre d’un autre groupe obtient des droits supplémentaires Modification à apporter AVANT:\n1wheel:x:10:\rAPRÈS:\n1wheel:x:10:mbergeron\rOn ajoute l’usager mbergeron au groupe wheel Le groupe wheel est le groupe qui peut faire la commande sudo Nombre de touches Pour visualiser avec meld et lancer l’exercice",
    "description": "Objectif de l’atelier Approfondir l’utilisation de VIM pour modifier des fichiers de configuration Linux de manière efficace. Modifier des fichiers de configuration Linux efficacement : Utiliser un minimum de touches. Ne pas utiliser la souris. Compléter les exercices : 10 exercices de type A (le curseur est déjà placé). 5 exercices de type B (le curseur commence au début du fichier). Instructions de remise Fournissez les captures d’écran des exercices réussis via Moodle.",
    "tags": [],
    "title": "ATELIER #7: VIM et les fichiers de configuration (À MODIFIER)",
    "uri": "/semaine7/atelier/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e DNF et CRON",
    "content": "Planification des tâches avec cron Cron est un outil qui permet de planifier et d’automatiser des tâches sur un système Linux. Chaque utilisateur peut définir ses propres tâches planifiées.\nPoints essentiels : Les tâches planifiées par un utilisateur sont stockées dans le fichier :\n/var/spool/cron/\u003cuser\u003e Le démon responsable de l’exécution des tâches planifiées s’appelle : crond On peut planifier des tâches complexes grâce aux nombreuses options disponibles. Commandes de base pour gérer les tâches planifiées Afficher la liste des tâches planifiées :\ncrontab -l\rSupprimer toutes les tâches planifiées :\ncrontab -r\rModifier les tâches d’un autre utilisateur (nécessite les droits root) :\ncrontab -u \u003cutilisateur\u003e\rImporter un fichier contenant des tâches planifiées :\ncrontab \u003cfichier\u003e\r⚠️ Chaque import écrase toutes les tâches existantes.\nModifier ou créer des tâches (commande la plus courante) :\ncrontab -e\rSyntaxe d’une tâche cron Une tâche dans une crontab se compose de deux parties :\nLa planification : Décrit quand la tâche doit s’exécuter (5 champs). La commande ou script à exécuter : Peut être une commande bash. Recommandation : utilisez un script, spécifié avec son chemin absolu. Exemple d’une crontab :\n15 * * * * bash /home/user/monscript.sh 30 0 * * * bash /usr/local/bin/autrescript.sh 0 * * * * echo \"Nouvelle heure\" \u003e\u003e /home/user/heure.txt\rLes erreurs de syntaxe dans le fichier crontab sont détectées au moment de l’enregistrement. Si une tâche génère des erreurs lors de l’exécution, elles sont enregistrées dans :\n/var/mail/\u003cuser\u003e\nComprendre la planification La planification utilise 5 champs :\nMinutes Heures Jour du mois Mois Jour de la semaine 0-59 0-23 1-31 1-12 0-7 (dimanche à dimanche) Symboles utiles * : Tous les moments possibles (ex. : toutes les heures). , : Énumération de valeurs (ex. : 1,5,6). - : Intervalle de valeurs (ex. : 1-10). */n : Sauts réguliers (ex. : */2 toutes les 2 heures). Exemples de planifications Tous les jours à 14h30 : 30 14 * * * bash /chemin/script.sh\rChaque heure (25ème minute) en mars uniquement : 25 * * 3 * bash /chemin/script.sh\rLundi, mercredi et vendredi à midi : 0 12 * * 1,3,5 bash /chemin/script.sh\rGestion des paquets avec dnf DNF est un gestionnaire de paquets pour les systèmes basés sur Red Hat (comme AlmaLinux). Il simplifie :\nL’installation. La mise à jour. La suppression de logiciels. Contrairement à l’installation manuelle ou avec des fichiers RPM, dnf gère automatiquement les dépendances.\nCommandes de base Rechercher un paquet Rechercher un paquet par nom ou description :\ndnf search \u003cmot-clé\u003e\rVérifier si un fichier ou commande fait partie d’un paquet :\ndnf provides \u003cfichier/commande\u003e\rInstallation d’un paquet Pour installer un paquet :\nsudo dnf install \u003cnom_du_paquet\u003e\rMettre à jour un paquet ou tout le système Mettre à jour un paquet spécifique : sudo dnf update \u003cnom_du_paquet\u003e\rMettre à jour tous les paquets installés : sudo dnf update\rSupprimer un paquet Pour désinstaller un paquet :\nsudo dnf remove \u003cnom_du_paquet\u003e\rGestion des dépôts Les dépôts sont des serveurs qui contiennent des paquets. Ils sont configurés dans :\n/etc/yum.repos.d\nCommandes utiles Lister les dépôts actifs : dnf repolist\rLister tous les dépôts (actifs ou non) : dnf repolist all\rAjouter un nouveau dépôt Par exemple, pour ajouter le dépôt remi :\nsudo dnf install -y https://rpms.remirepo.net/enterprise/remi-release-9.rpm\rGestion des groupes de paquets Certaines applications ou environnements sont regroupés en groupes pour simplifier leur gestion.\nCommandes importantes Lister les groupes disponibles :\ndnf grouplist\rInstaller un groupe :\nExemple pour installer l’environnement Xfce :\nsudo dnf groupinstall \"Xfce\"\rObtenir des informations sur un groupe :\ndnf groupinfo \"\u003cnom_du_groupe\u003e\"\rAutomatisation avec le shell dnf Le shell dnf permet d’exécuter plusieurs commandes à la suite.\nCréer un fichier avec les commandes (ex. : installations.txt) :\ninstall nmap install zsh run\rExécuter le fichier avec dnf :\ndnf shell installations.txt",
    "description": "Planification des tâches avec cron Cron est un outil qui permet de planifier et d’automatiser des tâches sur un système Linux. Chaque utilisateur peut définir ses propres tâches planifiées.\nPoints essentiels : Les tâches planifiées par un utilisateur sont stockées dans le fichier :\n/var/spool/cron/\u003cuser\u003e Le démon responsable de l’exécution des tâches planifiées s’appelle : crond On peut planifier des tâches complexes grâce aux nombreuses options disponibles. Commandes de base pour gérer les tâches planifiées Afficher la liste des tâches planifiées :",
    "tags": [],
    "title": "CRON et DNF",
    "uri": "/semaine8/cours/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e WSL installation et manipulation (Ubuntu, VS Code)",
    "content": "+++ title = “Installation et manipulation de WSL avec Ubuntu et VS Code” weight = 141 +++\nLe Windows Subsystem for Linux (WSL) est une fonctionnalité de Windows qui permet d’exécuter un environnement Linux directement sur un système Windows sans avoir besoin d’une machine virtuelle.\nNous allons voir comment installer et utiliser WSL avec Ubuntu et Visual Studio Code (VS Code).\nPrérequis Un PC sous Windows 10 (version 2004 ou ultérieure) ou Windows 11. Accès à une connexion Internet. 1. Activation de WSL Activer les fonctionnalités Windows :\nOuvrez “Panneau de configuration” \u003e “Programmes” \u003e “Activer ou désactiver des fonctionnalités Windows”. Cochez les cases suivantes : Sous-système Windows pour Linux Plateforme de machine virtuelle Cliquez sur “OK” et redémarrez votre PC. Installer WSL 2 :\nOuvrez PowerShell en mode administrateur. Exécutez la commande suivante pour définir WSL 2 comme version par défaut : wsl --set-default-version 2\r2. Installation d’Ubuntu sur WSL Installer Ubuntu :\nOuvrez le Microsoft Store. Recherchez “Ubuntu” et choisissez une version (par ex., “Ubuntu 22.04 LTS”). Cliquez sur “Installer”. Configurer Ubuntu :\nLancez l’application Ubuntu depuis le menu Démarrer. Créez un utilisateur et un mot de passe lors du premier démarrage. 3. Installation de Visual Studio Code Installer VS Code :\nTéléchargez et installez Visual Studio Code depuis le site officiel : code.visualstudio.com. Installer l’extension WSL :\nOuvrez VS Code. Accédez à l’onglet des extensions (icône de carré à gauche ou Ctrl+Shift+X). Recherchez et installez l’extension Remote - WSL. 4. Configuration de l’environnement Accéder à WSL depuis VS Code :\nLancez Ubuntu (WSL) et naviguez jusqu’à votre répertoire de projet ou créez-en un : mkdir mon_projet\rcd mon_projet\rTapez code . pour ouvrir VS Code directement dans ce répertoire. Configurer le terminal :\nDans VS Code, allez dans Fichier \u003e Préférences \u003e Paramètres. Recherchez “terminal.integrated.defaultProfile.windows” et sélectionnez “WSL” comme terminal par défaut. 5. Manipulation de l’environnement Ubuntu dans WSL Installer des outils de développement :\nUtilisez apt pour installer des packages : sudo apt update\rsudo apt install build-essential git curl\rCloner un projet Git :\nUtilisez la commande suivante pour cloner un projet : git clone https://github.com/utilisateur/projet.git\rExécuter un projet :\nPar exemple, pour un projet Node.js : sudo apt install nodejs npm\rnpm install\rnpm start\r6. Conseils et Astuces Partage de fichiers entre Windows et WSL : Les fichiers créés sous WSL sont accessibles dans l’explorateur Windows sous : \\\\wsl$\\Ubuntu\\. Performances : Pour des performances optimales, stockez vos fichiers de projet dans le système de fichiers Linux (dans WSL) plutôt que dans le système de fichiers Windows. Mises à jour : Pensez à mettre à jour régulièrement WSL et Ubuntu : sudo apt update \u0026\u0026 sudo apt upgrade\rConclusion Avec WSL, Ubuntu et VS Code, vous disposez d’un environnement puissant pour le développement sous Linux, tout en conservant la commodité de Windows.",
    "description": "+++ title = “Installation et manipulation de WSL avec Ubuntu et VS Code” weight = 141 +++\nLe Windows Subsystem for Linux (WSL) est une fonctionnalité de Windows qui permet d’exécuter un environnement Linux directement sur un système Windows sans avoir besoin d’une machine virtuelle.\nNous allons voir comment installer et utiliser WSL avec Ubuntu et Visual Studio Code (VS Code).\nPrérequis Un PC sous Windows 10 (version 2004 ou ultérieure) ou Windows 11. Accès à une connexion Internet. 1. Activation de WSL Activer les fonctionnalités Windows :",
    "tags": [],
    "title": "WSL installation et manipulation (Ubuntu, VS Code)",
    "uri": "/semaine14/cours/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Solutions de ateliers",
    "uri": "/solutions/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/categories/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/tags/index.html"
  }
]
