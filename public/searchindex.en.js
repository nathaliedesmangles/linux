var relearn_searchindex = [
  {
    "breadcrumb": "",
    "content": "Pondération : 2-2-2\nDescription du cours :\nLinux est le système d’exploitation qui constitue la colonne vertébrale des entreprises les plus puissantes et les plus innovantes au monde. Dès lors, l’étudiante ou l’étudiant sera initié aux principes de base des systèmes d’exploitation libre (Linux) et à l’installation et l’exploitation d’une distribution libre de Linux (p. ex. Fedora, Ubuntu, AlmaLinux, OpenSource).\nPour cela, l’étudiant ou l’étudiante devra exploiter l’interface graphique et la puissance de la ligne de commande pour gérer une station de travail, explorer les systèmes de fichiers et le partitionnement des disques, gérer les processus, l’automatisation des tâches et la programmation de scripts shell.\nObjectifs du cours : Effectuer l’installation et la gestion d’ordinateurs.",
    "description": "Pondération : 2-2-2\nDescription du cours :\nLinux est le système d’exploitation qui constitue la colonne vertébrale des entreprises les plus puissantes et les plus innovantes au monde. Dès lors, l’étudiante ou l’étudiant sera initié aux principes de base des systèmes d’exploitation libre (Linux) et à l’installation et l’exploitation d’une distribution libre de Linux (p. ex. Fedora, Ubuntu, AlmaLinux, OpenSource).",
    "tags": [],
    "title": "420-ZG4-MO Système d’exploitation Linux",
    "uri": "/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "Plan de la leçon Présentation du cours (plan de cours).\nPondération. Objectifs. Contexte d’apprentissage et méthodes pédagogiques. Evaluations formatives. Évaluations sommatives. Politiques institutionnelles (absences, retards, plagiat, etc.). Règlements en classe et hors classe. Théorie :\nGénéralités sur le système d’exploitation Linux. Atelier :\nInstallation de Linux sur une machine virtuelle.",
    "description": "Plan de la leçon Présentation du cours (plan de cours).\nPondération. Objectifs. Contexte d’apprentissage et méthodes pédagogiques. Evaluations formatives. Évaluations sommatives. Politiques institutionnelles (absences, retards, plagiat, etc.). Règlements en classe et hors classe. Théorie :\nGénéralités sur le système d’exploitation Linux. Atelier :\nInstallation de Linux sur une machine virtuelle.",
    "tags": [],
    "title": "Introduction à Linux",
    "uri": "/semaine1/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Introduction à Linux",
    "content": "Qu’est-ce qu’un système d’exploitation? Un système d’exploitation (SE) est un logiciel essentiel qui agit comme un intermédiaire entre l’utilisateur et le matériel de l’ordinateur. Il gère les ressources matérielles et logicielles de l’ordinateur et fournit des services communs pour les programmes informatiques. Voici quelques-unes de ses principales fonctions:\nGestion des ressources matérielles: Le système d’exploitation contrôle et coordonne l’utilisation du processeur, de la mémoire, des périphériques de stockage, et des périphériques d’entrée/sortie comme le clavier, la souris et l’écran.\nGestion des fichiers: Il organise les données en fichiers et dossiers, permettant aux utilisateurs de stocker, récupérer et manipuler des informations de manière efficace.\nGestion des processus: Le système d’exploitation gère l’exécution des programmes, en allouant du temps processeur et en assurant que les tâches s’exécutent sans conflit.\nInterface utilisateur: Il fournit une interface utilisateur, qui peut être en ligne de commande (CLI) ou graphique (GUI), permettant aux utilisateurs d’interagir facilement avec l’ordinateur.\nSécurité et gestion des utilisateurs: Le système d’exploitation protège les données et les ressources de l’ordinateur contre les accès non autorisés et permet la gestion des comptes utilisateurs.\nExemples de systèmes d’exploitation Windows: Développé par Microsoft, c’est l’un des systèmes d’exploitation les plus utilisés dans le monde. macOS: Développé par Apple, il est utilisé sur les ordinateurs Mac. Linux: Un système d’exploitation open-source utilisé principalement par les développeurs et les serveurs. Android: Utilisé principalement sur les smartphones et les tablettes. iOS: Le système d’exploitation d’Apple pour ses appareils mobiles comme l’iPhone et l’iPad. Pourquoi est-ce important? Le système d’exploitation est crucial car il permet à l’utilisateur d’exploiter pleinement les capacités de l’ordinateur sans avoir à gérer directement les complexités matérielles. Il offre une plateforme stable et sécurisée pour exécuter des applications et effectuer des tâches quotidiennes.\nQu’est-ce que Linux ? Définition\rLinux est un système d’exploitation puissant et flexible qui offre de nombreux avantages, notamment en termes de sécurité, de stabilité, et de personnalisation.\nQue ce soit pour un usage personnel, professionnel, ou pour des serveurs, Linux est une option solide et fiable.\nUn peu d’histoire 1991 : Créé par Linus Torvalds et est basé sur le système Unix. 1992 : Le noyau Linux a été re-licencié sous la licence publique générale GNU GPL (GNU’s Not Unix General Public Licence), ce qui a renforcé son statut de logiciel libre. 1994 : La version 1.0 du noyau Linux a été publiée, marquant une étape importante dans son développement. Depuis sa création, Linux est devenu l’un des systèmes d’exploitation les plus populaires, notamment pour les serveurs, les superordinateurs, et les appareils embarqués.\nCaractéristiques principales Open Source : Le code source de Linux est disponible gratuitement, permettant aux utilisateurs de le modifier et de le distribuer. Sécurité : Linux est réputé pour sa robustesse et sa sécurité. Les mises à jour régulières et la communauté active contribuent à maintenir un haut niveau de sécurité. Stabilité : Linux est connu pour sa stabilité et sa capacité à fonctionner pendant de longues périodes sans nécessiter de redémarrage. Personnalisation : Les utilisateurs peuvent personnaliser leur environnement Linux selon leurs besoins, grâce à une multitude de distributions et d’outils disponibles. Distributions Linux Définition\rUne distribution Linux est une version de Linux qui inclut le noyau Linux ainsi que divers logiciels et outils.\nVoici quelques-unes des distributions les plus populaires :\nUbuntu : Connue pour sa convivialité et son support communautaire.\nSite d’Ubuntu Fedora : Souvent utilisée par les développeurs et les administrateurs système.\nSite de Fedora Red Hat : L’une des premières distributions commerciales de Linux. Elle est particulièrement populaire dans les environnements d’entreprise.\nSite de Red Hat Debian : Réputée pour sa stabilité et sa large collection de logiciels.\nsite de Debian Arch Linux : Appréciée par les utilisateurs avancés pour sa flexibilité et sa simplicité.\nSite d’Arch Linux Utilisations de Linux Serveurs : Linux est largement utilisé pour les serveurs web, les serveurs de bases de données, et les serveurs de fichiers en raison de sa fiabilité et de sa sécurité. Superordinateurs : La majorité des superordinateurs dans le monde fonctionnent sous Linux. Appareils embarqués : De nombreux appareils, tels que les routeurs, les téléviseurs intelligents, et les smartphones (via Android), utilisent Linux. Postes de travail : Bien que moins courant que Windows ou macOS, Linux est utilisé par de nombreux développeurs et professionnels de l’informatique pour ses capacités de personnalisation et ses outils puissants. Répartition des SE chez les développeurs Répartition des systèmes d’exploitation pour le développement de logiciels dans le monde de 2018 à 2023\nAvantages Inconvénients Très souvent le même environnement que la machine de production (surtout pour la portion serveur d’une application) Accès très limité aux outils Microsoft : pas de Visual Studio, seulement VS Code et un support minimal pour C# Très facile d’installer des nouveaux outils de développement :\n$ dnf install nodejs\n$ dnf install nodejs Une bonne console (ligne de commande) est souvent un bon dépanneur pour un développeur (p.ex. les messages d’erreur sont souvent plus explicites à la ligne de commande que dans l’IDE) Plus facile d’automatiser des tâches de compilation et de tests Systèmes plus légers qui laissent la place aux outils de développement (p.ex. mon Linux prend moins de 1Go de mémoire, alors le reste est pour les outils, VM, etc.). Dans le cours Android p.ex., l’environnement de développement prend 15Go de mémoire (pour l’IDE + deux émulateurs de téléphone). Part de marché des SE pour les serveurs Part de marché des systèmes d’exploitation pour les serveurs",
    "description": "Qu’est-ce qu’un système d’exploitation? Un système d’exploitation (SE) est un logiciel essentiel qui agit comme un intermédiaire entre l’utilisateur et le matériel de l’ordinateur. Il gère les ressources matérielles et logicielles de l’ordinateur et fournit des services communs pour les programmes informatiques. Voici quelques-unes de ses principales fonctions:\nGestion des ressources matérielles: Le système d’exploitation contrôle et coordonne l’utilisation du processeur, de la mémoire, des périphériques de stockage, et des périphériques d’entrée/sortie comme le clavier, la souris et l’écran.",
    "tags": [],
    "title": "Qu'est-ce que Linux ?",
    "uri": "/semaine1/cours/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Introduction à Linux",
    "content": "Objectifs Installation du logiciel de virtualisation VMware workstation Pro. Création d’une machine virtuelle (VM). Installation de Linux sur la VM. Prérequis pour l’atelier Avoir Windows 11 installé sur votre disque SSD (sur une seule partition). Télécharger un logiciel de virtualisation tel que VMWare Workstation Pro 17. Télécharger la dernière version d’Almalinux (janvier 2025 c’est la version 9.5). Rappels (Cours ZE5 Virtualisation) VMWare permet d’installer différents systèmes d’exploitation sur une même machine. Le nombre de machines virtuelles (VM) que l’on peut installer dépend de la puissance en terme de CPU et de mémoire de la machine hôte. La machine hôte est celle qui héberge les machines virtuelles aussi appelées les invités. La machine hôte peut être Windows ou Linux et les invités peuvent être une grande variété de systèmes d’exploitation. Format de la remise Attention\rVous devrez prendre des captures d’écran de vos installations. Pour plus de détails, voir les documents ci-dessous:.\nAtelier Étape 1: Réinstallation de Windows Utiliser la procédure obtenue dans le cours 420-ZC5-MO de la session d’automne.\nAttention\rVous devez installer Windows 11 et sur une seule partition.\nÉtape 2: Téléchargement et installation de VMWare sur la machine hôte (votre SSD Windows) Guide - Téléchargement WMWare\nGuide - Installation de VMWare\nÉtape 3: Création d’une VM et installation d’Almalinux Télécharger l’image d’Almalinux Site Almalinux\nNote\rChoisir AlmaLinux OS 9.5 DVD ISO\nVous obtiendrez le fichier AlmaLinux-9.5-x86_64-dvd.iso\nCréer une VM pour y installer Almalinux Attention\rNe pas sauvegarder le fichier .iso sur OneDrive, ni dans le répertoire Téléchargements (Downloads), Sauvegardez le sur votre disque dur (en général c’est le lecteur C:).\nGuide - Création d’une VM Almalinux\nEn cas de problème Cas #1: Il arrive parfois que le serveur X ne démarre pas dans le temps imparti, ce qui force l’installation à basculer en mode texte. Vous le résolvez en augmentant le délai avec inst.xtimeout=180 en début d’installation.\nPour résoudre le problème:\nmenu installation - choisir troubleshooting touche tab ajouter inst.xtimeout=valeur en seconde en bas ( comme l’image ci bas) Cas #2: Si le processus d’installation exécute le Check et que c’est très long, il suffit d’appuyer plusieurs fois sur la touche Esc pour sauter la vérification et poursuivre l’installation.\nCas #3: Sur certains postes/SSD, la configuration ci-dessous règle les problèmes encourus pendant l’installation d’Almalinux.\nConfiguration de la VM:\n40 Gb au lieu de 20 Gb 4096 en mémoire 1 processeur et 4 Coeurs",
    "description": "Objectifs Installation du logiciel de virtualisation VMware workstation Pro. Création d’une machine virtuelle (VM). Installation de Linux sur la VM. Prérequis pour l’atelier Avoir Windows 11 installé sur votre disque SSD (sur une seule partition). Télécharger un logiciel de virtualisation tel que VMWare Workstation Pro 17. Télécharger la dernière version d’Almalinux (janvier 2025 c’est la version 9.5). Rappels (Cours ZE5 Virtualisation) VMWare permet d’installer différents systèmes d’exploitation sur une même machine. Le nombre de machines virtuelles (VM) que l’on peut installer dépend de la puissance en terme de CPU et de mémoire de la machine hôte. La machine hôte est celle qui héberge les machines virtuelles aussi appelées les invités. La machine hôte peut être Windows ou Linux et les invités peuvent être une grande variété de systèmes d’exploitation. Format de la remise Attention\rVous devrez prendre des captures d’écran de vos installations. Pour plus de détails, voir les documents ci-dessous:.",
    "tags": [],
    "title": "ATELIER #1: Installation de Linux sur une VM",
    "uri": "/semaine1/atelier/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "Plan de la leçon Théorie :\nLe système de fichiers de Linux. Le Shell Bash. La ligne de commandes. Les commandes de base. Introduction à VIM. Atelier :\nUtilisation des commandes de base et Vim.",
    "description": "Plan de la leçon Théorie :\nLe système de fichiers de Linux. Le Shell Bash. La ligne de commandes. Les commandes de base. Introduction à VIM. Atelier :\nUtilisation des commandes de base et Vim.",
    "tags": [],
    "title": "Système de fichiers, Shell, commandes de base, Vim",
    "uri": "/semaine2/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Système de fichiers, Shell, commandes de base, Vim",
    "content": "La structure du système de fichiers Linux est hiérarchique et organisée sous la forme d’un arbre inversé, où la racine (root) est représentée par /. Tous les fichiers et répertoires sont situés sous cette racine.\nLa structure du système de fichiers Linux est conçue pour être logique et organisée, facilitant ainsi la gestion et la navigation.\nComprendre cette structure est essentiel pour naviguer et gérer efficacement un système Linux.\nTout est fichier Sous Linux, TOUT les éléments visibles dans l’arborescence du système de fichiers sont des fichiers.\nUn fichier est un fichier Un répertoire est un fichier Une clé USB est un fichier Une partition est un fichier Un disque dur est un fichier etc. Répertoires principaux Important\rChaque répertoire a un rôle spécifique et contient des types de fichiers bien définis.\n/ (Racine) Le point de départ de l’arborescence du système de fichiers. Tous les autres répertoires et fichiers sont situés sous ce répertoire. /bin Contient les binaires essentiels nécessaires au démarrage du système et à l’exécution des commandes de base, comme ls, cp, mv, etc. /boot Contient les fichiers nécessaires au démarrage du système, y compris le noyau Linux et les fichiers de configuration du chargeur de démarrage (bootloader). /dev Contient les fichiers de périphériques. Chaque périphérique matériel (comme les disques durs, les clés USB, etc.) est représenté par un fichier dans ce répertoire. /etc Contient les fichiers de configuration du système. Par exemple, les fichiers de configuration des services, des utilisateurs, des réseaux, etc. /home Contient les répertoires personnels des utilisateurs. Chaque utilisateur a son propre répertoire sous /home, par exemple /home/ndesmangles. /lib Contient les bibliothèques partagées nécessaires pour les binaires situés dans /bin et /sbin. /media Point de montage pour les périphériques amovibles comme les CD-ROM, les clés USB, etc. /mnt Utilisé pour monter temporairement des systèmes de fichiers. Par exemple, pour monter un disque dur externe. /opt Contient les logiciels optionnels et les paquets additionnels qui ne sont pas inclus dans la distribution standard. /proc Système de fichiers virtuel qui contient des informations sur les processus en cours et le système. Par exemple, /proc/cpuinfo contient des informations sur le processeur. /root Répertoire personnel de l’utilisateur root (administrateur du système). /run Contient des informations sur l’état du système depuis le dernier démarrage. Utilisé pour stocker des fichiers temporaires nécessaires au fonctionnement du système. /sbin Contient les binaires essentiels pour l’administration du système, comme fdisk, ifconfig, etc. /srv Contient les données spécifiques aux services fournis par le système. Par exemple, les fichiers de données pour un serveur web peuvent être stockés ici. /tmp Contient les fichiers temporaires créés par les utilisateurs et les applications. Ce répertoire est souvent vidé au redémarrage du système. /usr Contient les applications et les fichiers utilisés par les utilisateurs. Sous-répertoires importants : /usr/bin : Contient les binaires des applications utilisateur. /usr/lib : Contient les bibliothèques partagées pour les applications utilisateur. /usr/local : Contient les logiciels installés localement par l’administrateur du système. /var Contient les fichiers variables, tels que les journaux système, les fichiers de spool, et les fichiers temporaires des applications. Par exemple, /var/log contient les fichiers journaux. Les chemins absolu et relatif Chemin absolu Un chemin absolu est un chemin complet qui commence à la racine du système de fichiers. Il indique l’emplacement exact d’un fichier ou d’un répertoire, peu importe où vous vous trouvez dans le système de fichiers. Par exemple :\n/home/utilisateur/Documents/fichier.txt\rDans cet exemple, le chemin commence par /, qui est la racine du système de fichiers, et suit l’arborescence jusqu’au fichier fichier.txt.\nChemin relatif Un chemin relatif, quant à lui, est un chemin qui est relatif à votre répertoire de travail actuel. Il ne commence pas par /. Par exemple, si vous êtes dans le répertoire /home/utilisateur, et que vous voulez accéder à fichier.txt dans le sous-répertoire Documents, vous pouvez utiliser :\nDocuments/fichier.txt\rOu, si vous voulez remonter d’un niveau dans l’arborescence, vous pouvez utiliser .. pour représenter le répertoire parent. Par exemple, si vous êtes dans /home/utilisateur/Documents et que vous voulez accéder à un fichier dans /home/utilisateur, vous pouvez utiliser :\n../fichier.txt\rEn résumé\nChemin absolu : Commence à la racine / et donne l’emplacement complet. Chemin relatif : Dépend de votre répertoire de travail actuel et ne commence pas par /. Qu’est-ce que le SHELL? Le terme Shell désigne un programme qui interprète les commandes que vous tapez et les exécute. Il existe plusieurs types de shells, comme le Bourne Shell (sh), le C Shell (csh), le Korn Shell (ksh), et bien d’autres.\nLe shell Bash Bash (Bourne Again Shell) est le shell par défaut sur de nombreuses distributions Linux. Il agit comme une interface entre l’utilisateur et le système d’exploitation, permettant d’exécuter des commandes, des scripts, et d’automatiser des tâches.\nFonctionnalités clés de Bash Historique des commandes : Bash conserve un historique des commandes entrées, ce qui permet de les réutiliser facilement. Redirection : Les flux d’entrée et de sortie peuvent être redirigés pour enregistrer des résultats ou chaîner des commandes. Variables : Bash prend en charge les variables, qui peuvent stocker des données pour une utilisation ultérieure. Alias : Vous pouvez créer des alias pour simplifier des commandes longues ou fréquemment utilisées. La ligne de commande La ligne de commande est l’interface où vous tapez vos commandes. Elle est souvent représentée par un symbole $ ou #:\n$ signifie que vous êtes un utilisateur standard # signifie que vous êtes le super-utilisateur root (administrateur du système). ~ signifie le répertoire personnel, les symboles $ et # seront précédés du symbole tilde: ~$ ou ~#. Une commande dans le shell suit généralement cette structure :\ncommande [options] [arguments]\rcommande : Le programme ou l’outil que vous souhaitez exécuter. options : Des paramètres supplémentaires qui modifient le comportement de la commande. arguments : Les cibles sur lesquelles la commande doit agir (fichiers, répertoires, etc.). Lorsque vous êtes prêt à exécuter une commande, appuyez sur la touche Entrée. Tapez chaque commande sur une ligne séparée. Le résultat de la commande est affiché avant l’invite du shell suivante.\nExemple de commande sans option :\n[ndesmangles@localhost ~]$ whoami ndesmangles [ndesmangles@localhost ~]$\rExemple de commande avec une option :\n[ndesmangles@localhost ~]$ date -R Fri, 17 Jan 2025 20:19:50 -0500 [ndesmangles@localhost ~]$ date +%R 20:19 Vous avez perdu la ligne de commande ?\rSi vous appuyer ‘Entrée’ avant d’avoir terminé d’écrire une commande, vous perdrez la ligne de commande. Le symbole \u003e s’affichera à la place. Pour retrouver la ligne de commande, faites Ctrl+C.\n[ndesmangles@localhost ~]$ commande_incomplète \u003e ^C [ndesmangles@localhost ~]$ Pour exécuter une commande avec des privilèges de super-utilisateur (root), on la précède de sudo:\n[ndesmangles@localhost ~]$ sudo ls /root\rCommandes de base en Bash Bash propose une variété de commandes puissantes pour interagir avec le système. Ces commandes de base sont essentielles pour naviguer, gérer des fichiers, et interagir avec votre système sous Bash.\nNavigation dans le système de fichiers Les commandes :\npwd (Print Working Directory) cd (Change Directory) ls (List) Commande Description Exemple pwd Affiche le chemin absolu du répertoire courant. /home/user $ pwd /home/user cd Change le répertoire courant pour Documents. /home/user $ cd Documents /home/user/Documents cd ~ Change vers le répertoire personnel de l’utilisateur. /home/user/Documents $ cd ~ /home/user cd .. Remonte d’un niveau dans l’arborescence des répertoires. /home/user/Documents $ cd .. /home/user cd ../../ Remonte de deux niveaux dans l’arborescence. /home/user/Documents/Projects $ cd ../../ /home/user ls Affiche le contenu d’un répertoire. /home/user/Documents $ ls fichier.txt dossier ls -l Affiche la liste des fichiers dans un répertoire. L’option -l affiche les détails des fichiers dans un répertoire. /home/user/Documents $ ls -l -rw-r--r-- 1 user user 1234 Jan 1 12:00 fichier.txt Quelques explications du résultat de ls -l Premier caractère: -, d ou l représente le type de fichier (fichier standard, répertoire ou lien symbolique respectivement) Neuf caractères suivants: par exemple rwxr-xr-x représentent les droits d’accès au fichier/répertoire (abordés en détail dans un prochain cours). Bon à savoir\rLa commande clear permet d’effacer l’écran du terminal.\nManipulation de fichiers et répertoires Les commandes :\ntouch mkdir (Make Directory) rm (Remove) : rmdir (Remove Directory) cp (Copy) mv (Move) Commande Description Exemple touch Crée un fichier vide ou met à jour la date de modification d’un fichier existant. /home/user $ touch fichier.txt $ ls fichier.txt mkdir Crée un nouveau répertoire. /home/user $ mkdir mon_dossier $ ls mon_dossier rm Supprime des fichiers. Utilisez -r pour supprimer des répertoires et leur contenu. /home/user $ rm fichier.txt $ rm -r mon_dossier rmdir Supprime un répertoire vide (ne fonctionne pas s’il contient des fichiers). $ rmdir mon_dossier cp Copie des fichiers ou des répertoires (avec -r pour copier des dossiers entiers). $ cp fichier.txt copie.txt $ ls fichier.txt copie.txt $ cp -r mon_dossier copie_dossier $ ls mon_dossier copie_dossier mv Déplace ou renomme des fichiers et des répertoires. $ mv fichier.txt nouveau_nom.txt $ ls nouveau_nom.txt Affichage et lecture de fichiers Les commandes :\ncat less head tail Commande Description Exemple cat Affiche le contenu complet d’un ou de plusieurs fichiers. $ cat fichier.txt $ cat fichier1.txt fichier2.txt less Permet de lire un fichier page par page. Contrôles : Espace : Page suivante q : Quitter $ less fichier.txt head Affiche les premières lignes d’un fichier. 10 lignes par défaut. L’option -n permet de spécifier le nombre de lignes $ head fichier.txt $ head -n 5 fichier.txt tail Affiche les dernières lignes d’un fichier. 10 lignes par défaut. L’option -n permet de spécifier le nombre de lignes $ tail fichier.txt $ tail -n 5 fichier.txt Informations système et historique Commande Description Exemple date Affiche la date et l’heure actuelles. $ date Thu Jan 9 20:42:36 EST 2025 $ date \"+%Y-%m-%d %H:%M:%S\" 2025-01-09 20:42:43 history Liste les commandes précédemment exécutées. Options utiles : n : Pour spécifier le nombre de commandes précédentes à afficher. ! : Pour exécuter une commande spécifique de l’historique, par son numéro. c : Pour effacer l’historique de la session. $ history $ history 5 $ history -c Commande date quelques options utiles :\n+ : Il faut précéder l’option du symbole + pour spécifier un format personnalisé. Formats: %Y : Année complète (ex. 2025). %m : Mois (01-12). %d : Jour (01-31). %H : Heure (00-23). %M : Minutes (00-59). %S : Secondes (00-59). %r : Heure au format 12h (ex. 11:11:04 PM) %R : Heure au format 24h (ex. 23:11 sans les secondes) %p : Heure avec AM ou PM Exemples avec la commande history :\n[ndesmangles@localhost ~]$ history\t# Affiche l'historique complet de la session. 1 date -R 2 pwd 3 cd /etc 4 cd .. 5 cd etc 6 cd ../.. 7 ls 8 ls -a 9 ls -l 10 date 11 date \"+%Y-%m-%d %H:%M:%S\" 12 cd ~ 13 history [ndesmangles@localhost ~]$ history 5\t# Affiche les 5 dernières commandes effectuées. 10 date 11 date \"+%Y-%m-%d %H:%M:%S\" 12 cd ~ 13 history 14 history 5 [ndesmangles@localhost ~]$ !11\t# Exécute la commande #11 dans l'historique date \"+%Y-%m-%d %H:%M:%S\" 2025-01-09 20:47:03 [ndesmangles@localhost ~]$ !da\t# Exécute la commande la plus récente, dont le nom commence par 'da'. date \"+%Y-%m-%d %H:%M:%S\"\t2025-01-18 20:48:22\t[ndesmangles@localhost ~]$ history -c\t# Efface l'historique. [ndesmangles@localhost ~]$ history 1 history\rCommandes utiles echo man (Manual) Commande Description Exemple echo Affiche un message ou une variable dans le terminal. $SHELL doit être écrit en respectant la casse. $ echo \"Bonjour, monde!\" Bonjour, monde! $ echo $SHELL /bin/bash man Affiche le manuel d’aide pour une commande. $ man ls Structure d’une page de manuel Une page de manuel typique contient plusieurs sections, telles que :\nNAME : Le nom de la commande et une brève description. SYNOPSIS : La syntaxe de la commande. DESCRIPTION : Une description détaillée de la commande et de ses options. OPTIONS : Les options disponibles pour la commande. EXAMPLES : Des exemples d’utilisation. SEE ALSO : Des références à d’autres commandes ou documents pertinents. Options utiles man -k keyword : Recherche des pages de manuel contenant le mot-clé spécifié. man -f command : Affiche une brève description de la commande (équivalent à whatis command). Autocompletion d’une commande Bash La touche Tab du clavier, permet de compléter rapidement les commandes et les noms de fichiers après avoir entré un nombre de caractères suffisant pour réduire les possibilités à une seule. Si les caractères saisis ne sont pas uniques, appuyez deux fois sur la touche de tabulation pour afficher toutes les commandes correspondantes. [ndesmangles@localhost ~]$ cat /etc/serTab\t# `cat /etc/ser` suivi de la touche `Tab` complète le nom du fichier. [ndesmangles@localhost ~]$ cat /etc/services [ndesmangles@localhost ~]$ passTabTab\t# `pass` suivi de 2 fois la touche `Tab` propose les commande dont le nom commence par `pass`. passt passt.avx2 passwd [ndesmangles@localhost ~]$ pass\rIntroduction à l’éditeur de texte VIM VIM (Vi IMproved) est un éditeur de texte, souvent utilisé dans les environnements Unix/Linux. Bien qu’il puisse sembler intimidant au premier abord, il devient très efficace une fois maîtrisé.\nPourquoi utiliser vim ? Disponibilité : Installé par défaut sur presque tous les systèmes Unix/Linux. Léger et rapide : Idéal pour éditer des fichiers même sur des systèmes limités en ressources. Puissant : Supporte des fonctionnalités avancées comme la recherche, la substitution, et l’édition de plusieurs fichiers simultanément. Premiers pas avec vim Pour ouvrir un fichier avec vim, utilisez la commande suivante :\n$ vim nom_du_fichier\rSi le fichier n’existe pas, vim le créera.\nLorsque vous ouvrez vim, il commence en mode commande. Vous ne pouvez pas directement écrire du texte. Vous devez d’abord passer au mode insertion en tapant la lettre i. En bas de la fenêtre Vim, le mot INSERTION s’affichera.\nRevenir au mode Normal\rSi avant de taper i ou n’importe quel autre mode, vous n’êtes plus dans le mode Normal, il suffit de tapper la touche ESC pour revenir au mode Normal.\nModes principaux de vim Ces modes sont les bases du fonctionnement de vim. Vous pouvez basculer entre eux selon vos besoins pour éditer et manipuler vos fichiers.\nMode Description Action Commande Normal Mode par défaut lorsque vous ouvrez vim. Appuyez sur Esc pour revenir à ce mode. ESC Insertion Permet d’insérer ou de modifier du texte. Passer en mode insertion où se trouve le curseur. i Commande Permet de sauvegarder un fichier. Sauvegarde :w Permet de quitter Vim, si aucun changement n’a été effectué dans le fichier en cours. Quitter :q Permet de forcer la fermeture de vim sans sauvegarder les modifications. Quitter sans sauvegarder les modifications. :q! Permet de sauvegarder et fermer le fichier. Sauvegarde et quitter. :wq Exercices pratiques Ouvrez un fichier nommé test.txt avec la commande :\n$ vim test.txt\rPassez en mode insertion (i), écrivez quelques lignes, puis sauvegardez et quittez avec :wq.\nRecherchez du texte : Ouvrez un fichier existant, cherchez un mot avec /mot, puis naviguez entre les occurrences avec n.\nTestez l’annulation : Modifiez une ligne, annulez avec u, puis rétablissez avec Ctrl+r.",
    "description": "La structure du système de fichiers Linux est hiérarchique et organisée sous la forme d’un arbre inversé, où la racine (root) est représentée par /. Tous les fichiers et répertoires sont situés sous cette racine.\nLa structure du système de fichiers Linux est conçue pour être logique et organisée, facilitant ainsi la gestion et la navigation.\nComprendre cette structure est essentiel pour naviguer et gérer efficacement un système Linux.",
    "tags": [],
    "title": "Système de fichiers, Shell et commandes de base et VIM",
    "uri": "/semaine2/cours/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Système de fichiers, Shell, commandes de base, Vim",
    "content": "Objectifs de l’atelier Se familiariser avec la ligne de commandes. Naviguer dans l’arborescence Linux à l’aide de commandes. Gerer des fichiers et répertoires à l’aide de commandes. Format de la remise sur Moodle Attention\rPour chaque exercice, vous devrez prendre une capture d’écran. Sur les captures, on doit pouvoir voir : Votre nom d’utilisateur (Ne travaillez donc pas avec l’utilisateur root, ni la commande sudo). La ligne de commande et la commande. Le résultat de la commande. Si le résultat fait plus de 10 lignes, capturer juste les 10 premières lignes. Nommer les fichiers image, tel qu’indiqué pour chaque question. Remettre toutes vos images dans 1 seul fichier compressé (ex:.zip). Tout autre format ne sera pas corrigé. Pour l’exercice #3, quelques questions devront ètre répondues dans un fichier texte à remettre sur Moodle en plus du .zip. Atelier Préparation Sur votre machine Almalinux, avec votre utilisateur standard, allez sur votre cours sur Moodle, dans la semaine 2. On vous demande de télécharger le fichier fichier.txt. Vous en aurez besoin pour l’exercice #3.\nCliquez sur fichier1. Sur la fenêtre qui s’ouvre, faites un clic droit et choisissez Enregistrez-sous. Le fichier va être enregistré par défaut dans le dossier Téléchargements. Fermer la fenêtre.\nCliquez sur le bouton Activités sur le bureau.\nCliquer sur l’icône Fichiers. Attention\rAvant de commencer chaque exercice, assurez vous que vous travaillez dans votre répertoire personnel et ne vous déplacez pas que lorsque demandé. À moins d’indication contraire, utiliser TOUJOURS des chemins relatifs. Allez maintenant sur votre terminal. Placez-vous dans votre répertoire personnel.\nExercice 1 : Explorer l’arborescence Linux Afficher le chemin de votre répertoire courant. Prendre une capture d’écran et nommez-la 1-1.png. Allez dans le répertoire /usr/share/doc, puis vérifiez le chemin de votre répertoire courant. Prendre une capture d’écran et nommez-la 1-2.png. Remontez dans le répertoire parent. Prendre une capture d’écran et nommez-la 1-3.png. Allez dans votre répertoire personnel. Prendre une capture d’écran et nommez-la 1-4.png. Listez les fichiers présents du répertoire courant. Prendre une capture d’écran et nommez-la 1-5.png. Toujours en étant dans votre dossier personnel, listez les fichiers du répertoire /usr. Prendre une capture d’écran et nommez-la 1-6.png. Exercice 2: Commandes Linux simples Commande date\nAfficher la date et l’heure actuelles du système. Afficher l’heure actuelle sur une horloge de douze heures (par exemple, 11:42:11 AM). Prendre une capture d’écran et nommez-la 2-1.png. Commande head\nAffichez les 10 premières lignes du fichier /etc/services Prendre une capture d’écran et nommez-la 2-2.png. Commande tail\nAffichez les 10 dernières lignes du fichier /etc/services. Prendre une capture d’écran et nommez-la 2-3.png. Commande tail\nRépéter la commande précédente avec exactement trois frappes de touches. Prendre une capture d’écran et nommez-la 2-4.png. Commande tail et les flèches vers le haut et vers la gauche\nRépéter la commande précédente, mais afficher les 20 dernières lignes du fichier. Prendre une capture d’écran et nommez-la 2-5.png. Commande history\nUtiliser l’historique du shell pour exécuter à nouveau la commande effectuée pour la question #3 Prendre une capture d’écran et nommez-la 2-6.png. Exercice 3: Commandes de base Important\rUtilisez pas l’interface graphique d’Almalinux QUE LORSQUE demandé (#6). Autrement, utilisez uniquement des commandes pour répondre aux questions. Après chaque question (sauf #6, #12a, #15 à #20), n’oubliez pas de prendre une capture d’écran et de la nommer 3-X.png où X est le numéro de la question. Créer un répertoire Atelier2 dans le répertoire courant. Copier le fichier téléchargé fichier.txt dans le répertoire Atelier2. Créer un autre répertoire nommé Rep2. Déplacer Atelier2 dans Rep2. Déplacez-vous dans Atelier2. Avec vim, ouvrez le fichier fichier.txt et écrivez écrivez votre nom complet dans le fichier. Enregistrer la modification et fermer le fichier. Afficher le contenu du fichier à l’aide de la commande cat. Créer un autre fichier nommé fichier2.txt dans Atelier2. Avec une seule commande cat afficher le contenu de fichier.txt et fichier2.txt. Revenir dans votre répertoire personnel. Supprimer le répertoire Rep2. a) Dans quel répertoire vous trouvez-vous? b) Utiliser une commande pour voir le répertoire courant. Créer un dossier avec le nom Rep3 dans le dossier /root(en utilisant un chemin absolu). Avez-vous réussi ? Si non, pourquoi ? Afficher le contenu du répertoire /etc en utilisant l’option -l. Par quels caractères, les lignes affichées débutent ? Quelles est leur signification ? Qu’est-ce qui distingue le répertoire /proc des autres répertoires de l’arborescence linux ? Qu’est ce qui distingue le répertoire /bin et /sbin ? Quel est le répertoire qui est utilisé pour charger le noyau du système d’exploitation au démarrage ? Dans Linux, tout est fichier. Si on connecte une clé usb à une machine linux, dans quel répertoire de l’arborescence, on va trouver la référence à cette clé ? Si on installe un serveur web apache sur une machine linux, dans quel répertoire de l’arborescence le dossier contenant les fichiers de configuration du serveur se trouvera-t-il ?",
    "description": "Objectifs de l’atelier Se familiariser avec la ligne de commandes. Naviguer dans l’arborescence Linux à l’aide de commandes. Gerer des fichiers et répertoires à l’aide de commandes. Format de la remise sur Moodle Attention\rPour chaque exercice, vous devrez prendre une capture d’écran. Sur les captures, on doit pouvoir voir : Votre nom d’utilisateur (Ne travaillez donc pas avec l’utilisateur root, ni la commande sudo). La ligne de commande et la commande. Le résultat de la commande. Si le résultat fait plus de 10 lignes, capturer juste les 10 premières lignes. Nommer les fichiers image, tel qu’indiqué pour chaque question. Remettre toutes vos images dans 1 seul fichier compressé (ex:.zip). Tout autre format ne sera pas corrigé. Pour l’exercice #3, quelques questions devront ètre répondues dans un fichier texte à remettre sur Moodle en plus du .zip. Atelier Préparation Sur votre machine Almalinux, avec votre utilisateur standard, allez sur votre cours sur Moodle, dans la semaine 2. On vous demande de télécharger le fichier fichier.txt. Vous en aurez besoin pour l’exercice #3.",
    "tags": [],
    "title": "ATELIER #2: Commandes Linux de base",
    "uri": "/semaine2/atelier/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "Plan de la leçon Théorie :\nLa séquence de démarrage de Linux. Les cibles (niveaux d’exécution). Les variables utilisateur. Itération avec la boucle FOR. Atelier :\nGestion des cibles. Création et utilisation de variables. Utilisation de la boucle FOR.",
    "description": "Plan de la leçon Théorie :\nLa séquence de démarrage de Linux. Les cibles (niveaux d’exécution). Les variables utilisateur. Itération avec la boucle FOR. Atelier :\nGestion des cibles. Création et utilisation de variables. Utilisation de la boucle FOR.",
    "tags": [],
    "title": "Processus de démarrage, variables et FOR",
    "uri": "/semaine3/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Processus de démarrage, variables et FOR",
    "content": "Le processus de démarrage Le processus de démarrage d’un système Linux suit plusieurs étapes essentielles, impliquant différents composants du système :\nÉtape Description 1. Activation du BIOS/UEFI Au démarrage, le BIOS (Basic Input Output System) ou l’UEFI (Unified Extensible Firmware Interface) s’active. Il vérifie le matériel et cherche le secteur de démarrage sur le disque (MBR ou GPT). 2. Chargement du chargeur d’amorçage Le MBR (Master Boot Record) définit le chargeur de démarrage, comme GRUB (GRand Unified Bootloader). GRUB affiche un menu permettant de choisir le système à démarrer. 3. Chargement du noyau Linux (Kernel) Après sélection de Linux, GRUB charge le noyau, qui initialise les pilotes, périphériques et la gestion de la mémoire. Il charge aussi un disque temporaire (initrd ou initramfs) contenant les modules nécessaires au démarrage. 4. Lancement du processus d’initialisation (init ou systemd) Le noyau lance le premier processus du système : init ou systemd (selon la distribution Linux). Ce processus démarre les services et scripts de configuration (réseau, interface graphique, gestion des utilisateurs, etc.). 5. Affichage de l’écran de connexion Une fois les services chargés, l’écran de connexion s’affiche, demandant un nom d’utilisateur et un mot de passe. 6. Utilisation du système Après authentification, vous pouvez utiliser Linux, lancer des applications et exécuter des commandes. Vous pouvez aussi arrêter ou redémarrer votre système avec shutdown, reboot ou halt. Les niveaux d’exécution (Runlevels) et cibles (Targets) Autrefois, Linux utilisait des niveaux d’exécution (runlevels), qui définissaient les services actifs selon le mode de fonctionnement. Avec systemd, ces niveaux sont remplacés par des cibles (targets). Cependant, la compatibilité avec les anciens niveaux est conservée.\nChanger temporairement le niveau d’exécution Utilisez la commande suivante pour modifier le niveau d’exécution temporairement :\n$ systemctl isolate \u003cnom_niveau\u003e\rCorrespondance entre les niveaux d’exécution et les cibles systemd Niveau d’exécution Cible systemd Description Commande associée 0 poweroff Arrêt du système $ systemctl isolate poweroff 1 rescue Mode utilisateur unique (maintenance) $ systemctl isolate rescue 3 multi-user Mode multi-utilisateur (ligne de commande) $ systemctl isolate multi-user 5 graphical Mode graphique complet $ systemctl isolate graphical 6 reboot Redémarrage du système $ systemctl isolate reboot Afficher et modifier le niveau d’exécution Pour afficher le niveau d’exécution actuel utiliser la commande who -r :\n$ who -r niveau d'exécution 5 2025-02-01 10:09 $ runlevel N 5\rÀ propos de Runlevel\rLa commande runlevel affiche deux valeurs : le niveau précédent et le niveau d’exécution actuel. Ici, N indique qu’il n’y avait pas de niveau précédent (au démarrage), et 5 est le niveau actuel graphique.\nCommande Description Exemple systemctl get-default Affiche le niveau d’exécution par défaut. $ systemctl get-default graphical.target systemctl set-default \u003cnom_niveau\u003e Modifie le niveau d’exécution par défaut. $ systemctl set-default multi-user systemctl default Revient au niveau d’exécution par défaut. $ systemctl default systemctl isolate default Bascule immédiatement vers le niveau d’exécution par défaut. $ systemctl isolate default Difference entre isolate et set-default\rLa différence entre les commandes est que la commande avec “isolate” est exécutée immédiatement, tandis que la commande avec “set-default” spécifie la cible obtenue après le redémarrage.\nSubstitution de commande La substitution de commande permet d’exécuter une commande et d’utiliser directement son résultat dans une autre commande.\nSyntaxe : $(commande)\rExemple 1 :\nBash exécute d’abord la commande whoami pour obtenir le nom de l’utilisateur, remplace $(whoami) par ce résultat, puis exécute touch pour créer un fichier portant ce nom.\n$ touch $(whoami).txt $ ls bonjour.txt Documents groupe4 Images Musique ndesmangles.txt Téléchargements titi toto tutu Vidéos Bureau fichier.txt groupe6 Modèles nathalie.txt Public test titi.txt toto.txt tutu.txt\rExemple 2 :\nL’exemple ci-dessous affiche les fichiers du dossier personnel :\n$ echo \"Les fichiers de mon dossier personnel sont : $(ls)\" Les fichiers de mon dossier personnel sont : bonjour.txt Bureau Documents Images Modèles Musique ndesmangles.txt Public Téléchargements titi titi.txt toto toto.txt tutu tutu.txt Vidéos\rLes variables En Bash, il est possible de définir des variables. Certaines sont définies par le système au démarrage ou à l’ouverture de la session ; ce sont les variables d’environnement (ex: SHELL). Nous pouvons aussi créer nos propres variables (variables utilisateur).\nDéfinir une variable utilisateur Un utilisateur peut créer ou modifier ses propres variables.\nAttention\rIl ne faut pas mettre d’espace autour du =. Les noms sont sensibles à la casse: VAR1 ≠ var1\n$ variable=valeur\rExemples :\nUne variable peut contenir un booléen, une chaîne de caractères ou une valeur numérique :\n$ variable=true $ variable=\"Ceci est un texte\" $ variable=45\rAccéder au contenu d’une variable Pour afficher la valeur d’une variable, il faut la préfixer avec $ :\n$ echo $variable 45\rExpansion des variables L’expansion des variables permet d’utiliser une variable dans une commande en remplaçant son nom par sa valeur réelle avant l’exécution de la commande.\nExemple: Imaginons que nous souhaitons lister trois fichiers : toto, titi, tutu. Nous pouvons stocker ces noms dans une variable :\n$ fichiers=\"toto titi tutu\"\rEnsuite, nous pouvons utiliser cette variable dans une commande :\n$ ls -l $fichiers -rw-r--r--. 1 ndesmangles ndesmangles 0 1 fév 10:37 titi -rw-r--r--. 1 ndesmangles ndesmangles 0 1 fév 10:37 toto -rw-r--r--. 1 ndesmangles ndesmangles 0 1 fév 10:37 tutu\rQue se passe-t-il ?\nAvant d’exécuter la commande, Bash remplace $fichiers par sa valeur réelle, puis exécute la commande résultante :\n$ ls -l toto titi tutu\rStocker le résultat d’une commande dans une variable Il est possible d’affecter à une variable le résultat d’une commande :\n$ ma_variable=$(ls /home)\rExemple 1 : Stocker la date actuelle\n$ x=\"La date est : $(date)\" $ echo $x La date est : ven 31 jan 2025 15:39:37 EST\rExemple 2 : Stocker le contenu d’un fichier\n$ x=$(cat /etc/passwd) $ echo $x root:x:0:0:root:/root:/bin/bash bin:x:1:1:bin:/bin:/sbin/nologin daemon:x:2:2:daemon:/sbin:/sbin/nologin ...\rÀ savoir\rLe résultat d’une commande stocké dans une variable est retourné sur une seule ligne, ce qui peut poser problème pour les fichiers avec plusieurs lignes.\nExpansion de noms de fichiers à l’aide de caractères génériques Lorsque l’on ne connaît pas précisément le nom d’un fichier ou que l’on veut rechercher plusieurs fichiers ayant un point commun, il est possible d’utiliser des caractères génériques. L’expansion des caractères génériques permet de manipuler facilement plusieurs fichiers sans avoir à taper leurs noms en entier.\nLes principaux caractères génériques Caractère Signification * Remplace n’importe quelle chaîne de caractères de n’importe quelle longueur ? Remplace un seul caractère Le shell effectue une expansion des noms de fichiers en remplaçant les caractères génériques avant d’exécuter la commande.\nExemple 1 : Lister tous les fichiers .txt\n$ ls *.txt\rSi les fichiers toto.txt, titi.txt et tutu.txt existent, la commande devient :\n$ ls toto.txt titi.txt tutu.txt titi.txt toto.txt tutu.txt\rSachez que…\rSi lors de la création des fichiers, l’extension (.txt) était absente, la commande précédente ls retournera une erreur:\nls: impossible d'accéder à 'toto.txt': Aucun fichier ou dossier de ce type ls: impossible d'accéder à 'titi.txt': Aucun fichier ou dossier de ce type ls: impossible d'accéder à 'tutu.txt': Aucun fichier ou dossier de ce type\rExemple 2 : Lister les fichiers avec un format spécifique\n$ ls t?t?.txt\rLe ? remplace un seul caractère, donc cette commande affichera tous les fichiers du répertoire courant correspondant à ce modèle, par exemple : tata.txt, titi.txt, mais pas tututu.txt.\nL’expansion d’accolades L’expansion d’accolades est une fonctionnalité de Bash qui permet de créer plusieurs chaînes de caractères en utilisant une syntaxe abrégée. Elle est particulièrement utile pour la création de fichiers, de répertoires ou pour l’exécution de commandes répétitives.\nL’expansion d’accolades utilise la syntaxe suivante :\n{élément1,élément2,...}\roù élément1, élément2, etc. sont les différentes chaînes de caractères que vous souhaitez combiner. Bash va alors générer toutes les combinaisons possibles de ces éléments.\nAttention\rNe mettez aucun espace à l’intérieur des accolades.\nExemples concrets Exemple 1 : Création de fichiers multiples\nSupposons que vous souhaitez créer les fichiers patata, patate, patati et patatu. Sans l’expansion d’accolades, vous devriez exécuter la commande touch quatre fois ou écrire au complet tous les noms des fichiers :\n$ touch patata $ touch patate $ touch patati $ touch patatu\rou\n$ touch patata patate patati patatu\rAvec l’expansion d’accolades, vous pouvez faire tout cela en une seule ligne :\n$ touch patat{a,e,i,u}\rBash va alors générer les chaînes patata, patate, patati et patatu, puis exécuter la commande touch pour chaque chaîne.\nExemple 2 : Création de séquences numériques\nVous pouvez également utiliser l’expansion d’accolades pour créer des séquences numériques. Par exemple, si vous souhaitez créer les fichiers test1.txt, test2.txt, test3.txt, …, test12.txt, vous pouvez utiliser la commande suivante :\n$ touch test{1..12}.txt\rBash va générer les nombres de 1 à 12, puis créer les fichiers correspondants.\nAutres exemples d’utilisation Exemple 1 : Création de fichiers dans un dossier spécifique\nPour créer la structure suivante :\ndossier1/\r│── test1.txt/\r│── test2.txt/\r│── test3.txt/\rSi dossier1 esxiste déjà $ touch dossier1/test{1..3}.txt\rSi dossier1 n’existe pas utiliser plutôt la commande mkdir -p. $ mkdir -p dossier1/test{1..3}.txt\rL’option -p\rL’option -p de mkdir signifie parents. Elle indique à la commande de créer tous les répertoires parents nécessaires pour atteindre le répertoire cible, s’ils n’existent pas déjà. Attention, l’option -p ne vérifie pas l’existence des fichiers. Utiliser avec précaution pour éviter d’écraser des fichiers existants.\nExemple 2 : Combinaison de chaînes et de séquences\nPour créer la structure suivante:\nboite1/\r│── patata\r│── patate\r│── patati\rboite2/\r│── patata\r│── patate\r│── patati\rSi boite1 et boite2 existent déjà. $ touch boite{1,2}/patat{a,e,i}\rou si boite1 et boite2 n’existent pas.\n$ mkdir -p boite{1,2}/patat{a,e,i}\rProtection contre l’expansion Dans certains cas, vous pouvez souhaiter empêcher l’expansion d’accolades. Pour cela, vous pouvez utiliser le caractère d’échappement \\ ou les guillemets simples (').\nUtilisation du caractère d’échappement Le caractère \\ est un caractère d’échappement dans le shell Bash. Il permet de protéger le caractère qui le suit de son expansion. Par exemple :\n$ echo je veux afficher \\* et afficher \\$x je veux afficher * et afficher $x\rUtilisation des guillemets simples Les guillemets simples (') arrêtent tous les types d’expansion. Par exemple :\n$ echo 'je veux afficher * et afficher $x' je veux afficher * et afficher $x\rUtilisation des guillemets doubles Les guillemets doubles (\") permettent uniquement l’expansion de variables et la substitution de commandes. Par exemple :\n$ x=5 $ echo \"je veux afficher * et afficher la valeur de $x\" je veux afficher * et afficher la valeur de 5\rLa commande find La commande find est un outil essentiel pour naviguer dans le système de fichiers et localiser des fichiers ou répertoires spécifiques. Elle suit la structure générale suivante :\nfind \u003crépertoire_de_départ\u003e \u003coptions\u003e\r\u003crépertoire_de_départ\u003e: Indique le répertoire où la recherche doit commencer. La commande explorera ce répertoire et tous ses sous-répertoires. \u003coptions\u003e: Définissent les critères de recherche, tels que le nom du fichier, le type, la date de modification, etc. Recherche par nom L’option -name est la plus courante pour rechercher des fichiers par leur nom.\nCommande Description $ find / -name services Recherche un fichier nommé services dans tout le système (à partir de la racine). $ find . -name \"*.txt\" Recherche tous les fichiers se terminant par .txt dans le répertoire courant. $ find . -name \"p*\" Recherche tous les fichiers commençant par p dans le répertoire courant et ses sous-répertoires. $ find /var/log -name \"???n\" Recherche tous les fichiers de 4 caractères se terminant par n dans /var/log. Pièges à éviter Lors de l’utilisation de find, il est crucial de comprendre comment Bash gère l’expansion des variables et les guillemets. Voici quelques points importants :\nCommande find et l’expansion\rAvec la commande find, l’expansion de variables et de noms de fichiers ne se font pas. Cela permet à find d’interpréter correctement les motifs avec des caractères génériques comme *.txt. Il est souvent nécessaire d’utiliser des guillemets pour protéger les caractères spéciaux et éviter des erreurs d’interprétation. Le tableau suivant illustre les différences de comportement :\nCommande Résultat ls *.txt Affiche tous les fichiers se terminant par .txt. Si aucun fichier .txt n’est trouvé, la commande s’exécute comme si les guillemets étaient présents. ls \"*.txt\" Affiche le fichier nommé exactement *.txt. find . -name *.txt L’expansion a lieu avant la recherche. Trois cas sont possibles :- Aucun fichier .txt : La commande s’exécute comme si les guillemets étaient présents.- Un fichier .txt : Seul ce fichier est recherché.- Plusieurs fichiers .txt : La commande échoue. find . -name \"*.txt\" Recherche tous les fichiers .txt à partir du répertoire courant. Exercices Manipulation de variables et de ls :\nCréez une variable variable_etc contenant la liste des fichiers de /etc et affichez-la. Observez le résultat et évaluez sa lisibilité. Essayez d’exécuter ls suivi du nom de votre variable. Expliquez le comportement observé. Recherche de fichiers de configuration :\nTrouvez tous les fichiers se terminant par .conf et stockez leurs noms dans une variable. Essayez d’exécuter ls suivi du nom de votre variable. Utilisez la commande du -sh \u003cfichier\u003e pour afficher la taille de chaque fichier de configuration. Création de fichiers avec factorisation :\nCréez un répertoire et utilisez la commande touch avec la syntaxe de factorisation pour créer les fichiers suivants : test1.txt, test2.txt, test3.txt, test1.doc, test2.doc, test3.doc, test1.tot, test2.tot, test3.tot. Utilisation de caractères génériques :\nAffichez uniquement les fichiers .txt commençant par test (trouvez plusieurs solutions). Affichez tous les fichiers .txt et .tot. Affichez tous les fichiers test1. Solution\rManipulation de variables et de ls : variable_etc=$(ls /etc) echo $variable_etc ls $variable_etc # Affiche les fichiers séparés par des espaces\rRecherche de fichiers de configuration : fichiers_conf=$(find /etc -name \"*.conf\") ls $fichiers_conf # Affiche les fichiers séparés par des espaces for fichier in $fichiers_conf; do du -sh $fichier done\rCréation de fichiers avec factorisation : mkdir repertoire_test touch repertoire_test/test{1..3}.{txt,doc,tot}\rUtilisation de caractères génériques : ls repertoire_test/test*.txt # Solution 1 ls repertoire_test/test[1-3].txt # Solution 2 ls repertoire_test/*.{txt,tot} ls repertoire_test/test1*\rItération sur le résultat d’une commande avec la boucle for La syntaxe de base d’une boucle for est la suivante :\nfor i in arg1 arg2 ...; do commande; done\ri : Variable qui prendra successivement la valeur de chaque argument. arg1 arg2 ... : Liste des éléments sur lesquels itérer. commande : Commande à exécuter pour chaque élément de la liste. Exemples d’utilisation Exemple 1 : Affichage du contenu de fichiers .txt\nSupposons que vous ayez les fichiers suivants :\nfichier1.txt\t# contient le mot 'Bonjour'\rfichier2.txt\t# contient le mot 'tout'\rfichier3.txt\t# contient le mot 'le'\rfichier4.txt\t# contient le mot 'monde'\rPour afficher le contenu de chaque fichier, vous pouvez utiliser une boucle for :\n$ for i in fichier1.txt fichier2.txt fichier3.txt fichier4.txt; do cat $i; done Bonjour tout le monde\rExemple 2 : Utilisation d’une variable pour stocker le résultat d’une commande\nVous pouvez stocker le résultat d’une commande dans une variable, puis itérer sur cette variable :\n$ fichiers=$(ls fichier*.txt) $ for i in $fichiers; do cat $i; done Bonjour tout le monde\rExemple 3 : Passage direct de la commande à la boucle for\nIl est également possible de passer directement la commande à la boucle for :\n$ for i in $(ls fichier*.txt) ; do cat $i; done Bonjour tout le monde\rExemple 4 : Utilisation de l’expansion de noms de fichiers\nPour simplifier l’itération sur des fichiers, vous pouvez utiliser l’expansion de noms de fichiers :\n$ for i in fichier*.txt; do cat $i; done Bonjour tout le monde\rFormatage de la boucle for dans un script Dans un script, il est recommandé d’écrire la boucle for sur plusieurs lignes pour une meilleure lisibilité. Les sauts de ligne remplacent le ; dans ce cas :\nfor i in $var do echo $i done\rExercices Liste des fichiers de /bin :\nCréez une variable contenant la liste des fichiers du répertoire /bin. Affichage des fichiers :\nParcourez cette variable à l’aide d’une boucle for et affichez chaque fichier sur une ligne différente. Taille des fichiers :\nSachant que vous pouvez concaténer des chaînes de caractères comme ceci : echo /bin/$i\rEssayez d’afficher la taille des fichiers du répertoire /bin. Utilisez la commande du -sh \u003cfichier\u003e pour afficher la taille d’un fichier. Solution\rListe des fichiers de /bin : fichiers_bin=$(ls /bin)\rAffichage des fichiers : for i in $fichiers_bin; do echo $i done\rTaille des fichiers : for i in $fichiers_bin; do echo /bin/$i du -sh /bin/$i done\rQuand utiliser l’expansion d’accolades { } vs la boucle for Utiliser {} pour les opérations simples et statiques (création, copie, expansion). Utiliser for dès qu’il y a des conditions, des manipulations avancées, ou une liste dynamique (suppression, renommage). En bref\rSi une simple expansion suffit, il vaut mieux l’utiliser pour gagner en lisibilité et en performance.",
    "description": "Le processus de démarrage Le processus de démarrage d’un système Linux suit plusieurs étapes essentielles, impliquant différents composants du système :\nÉtape Description 1. Activation du BIOS/UEFI Au démarrage, le BIOS (Basic Input Output System) ou l’UEFI (Unified Extensible Firmware Interface) s’active. Il vérifie le matériel et cherche le secteur de démarrage sur le disque (MBR ou GPT). 2. Chargement du chargeur d’amorçage Le MBR (Master Boot Record) définit le chargeur de démarrage, comme GRUB (GRand Unified Bootloader). GRUB affiche un menu permettant de choisir le système à démarrer. 3. Chargement du noyau Linux (Kernel) Après sélection de Linux, GRUB charge le noyau, qui initialise les pilotes, périphériques et la gestion de la mémoire. Il charge aussi un disque temporaire (initrd ou initramfs) contenant les modules nécessaires au démarrage. 4. Lancement du processus d’initialisation (init ou systemd) Le noyau lance le premier processus du système : init ou systemd (selon la distribution Linux). Ce processus démarre les services et scripts de configuration (réseau, interface graphique, gestion des utilisateurs, etc.). 5. Affichage de l’écran de connexion Une fois les services chargés, l’écran de connexion s’affiche, demandant un nom d’utilisateur et un mot de passe. 6. Utilisation du système Après authentification, vous pouvez utiliser Linux, lancer des applications et exécuter des commandes. Vous pouvez aussi arrêter ou redémarrer votre système avec shutdown, reboot ou halt. Les niveaux d’exécution (Runlevels) et cibles (Targets) Autrefois, Linux utilisait des niveaux d’exécution (runlevels), qui définissaient les services actifs selon le mode de fonctionnement. Avec systemd, ces niveaux sont remplacés par des cibles (targets). Cependant, la compatibilité avec les anciens niveaux est conservée.",
    "tags": [],
    "title": "Processus de démarrage, cibles, variables et boucle For",
    "uri": "/semaine3/cours/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Processus de démarrage, variables et FOR",
    "content": "Objectifs de l’atelier Se familiariser avec les cibles (niveaux d’exécution). Comprendre les bases des variables utilisateur en Bash. Apprendre à manipuler et utiliser des variables pour stocker des résultats de commandes. Format de la remise sur Moodle Attention\rPour chaque exercice, vous devez prendre une capture d’écran. Sur les captures, on doit pouvoir voir : Votre nom d’utilisateur (Ne travaillez donc pas avec l’utilisateur root, ni la commande sudo). La ligne de commande et la commande. Le résultat de la commande. Si le résultat fait plus de 10 lignes, capturer juste les 10 premières lignes. Dans votre remise, l’enseignant/e doit pouvoir facilement identifier les captures d’écran et la question (de quel exercice) correspondante. Atelier Exercice 1 : Niveaux d’exécution Modifier le niveau d’exécution par défaut de votre machine virtuelle (VM) pour passer en mode multi-utilisateurs sans interface graphique.\nRedémarrer la VM pour appliquer les changements à l’aide de la commande shutdown -r now.\nAprès le redémarrage, se connecter à votre VM . Vérifier que l’interface graphique ne démarre pas. Utiliser la commande systemctl pour connaître le niveau d’exécution actuel.\nRétablir le mode graphique par défaut. N’oubliez pas de redémarrer la VM pour que les changements soient pris en compte.\nExercice 2 : Caractères génériques et commande find Aller dans le répertoire /etc. Notez qu’il est demandé de ne pas se déplacer pour le reste de cet exercice.\nUtiliser la commande find pour rechercher les fichiers dont le nom commence par la lettre r dans le répertoire courant.\nUtiliser la commande find pour rechercher les fichiers contenant la chaîne rc dans le répertoire courant.\nUtiliser la commande find pour rechercher les fichiers dont le nom comporte exactement trois caractères sur l’ensemble du système de fichiers (à partir de la racine).\nExercice 3 : Expansion d’accolades et boucle for Important\rAssurez-vous d’être revenu dans votre répertoire personnel avant de commencer cet exercice.\nUtiliser l’expansion d’accolades pour créer l’arborescence de dossiers suivante en une seule commande. Astuce\rUtiliser l’option -p de la commande mkdir.\nToujours en utilisant l’expansion d’accolades, créer un fichier vide nommé priseNote dans chaque répertoire lab en une seule commande\nUtiliser une boucle for pour renommer tous les fichiers priseNote en priseNote.txt.\nUtiliser une boucle for pour déplacer les fichiers priseNote.txt des répertoires lab vers les répertoires lecon correspondants.\nVérification des résultats\rUtilisez la commande tree pour vérifier que l’arborescence des dossiers et les fichiers ont été créés et déplacés correctement. Par exemple :\n$ tree semaine1\rLa structure qui devrait s’afficher :\nsemaine1\r├── lab\r│ └── ├── lecon\r│ └── priseNote.txt",
    "description": "Objectifs de l’atelier Se familiariser avec les cibles (niveaux d’exécution). Comprendre les bases des variables utilisateur en Bash. Apprendre à manipuler et utiliser des variables pour stocker des résultats de commandes. Format de la remise sur Moodle Attention\rPour chaque exercice, vous devez prendre une capture d’écran. Sur les captures, on doit pouvoir voir : Votre nom d’utilisateur (Ne travaillez donc pas avec l’utilisateur root, ni la commande sudo). La ligne de commande et la commande. Le résultat de la commande. Si le résultat fait plus de 10 lignes, capturer juste les 10 premières lignes. Dans votre remise, l’enseignant/e doit pouvoir facilement identifier les captures d’écran et la question (de quel exercice) correspondante. Atelier Exercice 1 : Niveaux d’exécution Modifier le niveau d’exécution par défaut de votre machine virtuelle (VM) pour passer en mode multi-utilisateurs sans interface graphique.",
    "tags": [],
    "title": "ATELIER #3: Cibles et variables utilisateurs et for",
    "uri": "/semaine3/atelier/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "Plan de la leçon Théorie : lundi 24 février (dû à la levée des cours du 13/02)\nQuelques commandes utiles (tree, grep, sep cut, more, less et sort). Les entrées et sorties et la redirection des commandes. Le chainage de commandes (Pipelines). Les commandes de filtrage courantes. La boucle while. Test 1: Correction (si le temps le permet)\nTest #1 : jeudi 20 février (dû à la levée des cours du 17/02) Durée: 1h45, 20 questions Format: Test sur Moodle Écrire la commande (1 ligne) Écrire la commande (plus d’une ligne) Matière: Semaine 2: Système de fichiers, shell, commandes de base, Vim. Semaine 3: Processus de démarrage, niveaux, variables, commande find et boucle for Documentation permise: Seulement 1 feuille 8.5 x 11 recto-verso manuscrite ou imprimée. Test 1: Correction (jeudi 27)\nLes critères de correction seront disponibles sur le site sous “Solutions: ateliers et tests”. Atelier : jeudi 27 février\nUtilisation des diverses commandes. Redirection des entrées et sorties. Enchainer les commandes. Itération avec While.",
    "description": "Plan de la leçon Théorie : lundi 24 février (dû à la levée des cours du 13/02)\nQuelques commandes utiles (tree, grep, sep cut, more, less et sort). Les entrées et sorties et la redirection des commandes. Le chainage de commandes (Pipelines). Les commandes de filtrage courantes. La boucle while. Test 1: Correction (si le temps le permet)\nTest #1 : jeudi 20 février (dû à la levée des cours du 17/02) Durée: 1h45, 20 questions Format: Test sur Moodle Écrire la commande (1 ligne) Écrire la commande (plus d’une ligne) Matière: Semaine 2: Système de fichiers, shell, commandes de base, Vim. Semaine 3: Processus de démarrage, niveaux, variables, commande find et boucle for Documentation permise: Seulement 1 feuille 8.5 x 11 recto-verso manuscrite ou imprimée. Test 1: Correction (jeudi 27)",
    "tags": [],
    "title": "Commandes utiles, redirection, chainage et filtrage de commandes et While",
    "uri": "/semaine4/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Commandes utiles, redirection, chainage et filtrage de commandes et While",
    "content": "Commandes diverses Information\rLes guillemets simples (’) ou doubles (\") peuvent tous les deux être utilisés, lorsque des guillemets sont nécessaires.\ntree: Afficher l’arborescence des dossiers La commande tree affiche les fichiers et dossiers sous forme d’arborescence.\nL’option -d permet d’afficher uniquement les répertoires (et pas les fichiers).\nL’option -L permet de limiter l’affichage à N niveaux de profondeur.\nAfficher uniquement les dossiers :\n$ tree -d\t# `d` pour directory\rAfficher les dossiers d’un endroit précis :\n$ tree /etc\rLimiter l’affichage aux 2 premiers niveaux :\n$ tree -L 2\rgrep : Rechercher du texte dans un fichier L’option -r permet de rechercher de manière récursive dans un répertoire et tous ses sous-dossiers.\nLe caractère ^ est utilisé pour faire correspondre le début d’une ligne dans un fichier lorsqu’il est placé au début d’une chaine.\nTrouver “ssh” dans /etc/services :\n$ grep ssh /etc/services\rChercher dans tous les fichiers d’un dossier :\n$ grep -r \"ssh\" /etc/\rChercher uniquement au début des lignes :\n$ grep \"^root\" /etc/passwd\rsed: Remplacer du texte dans un fichier Le préfixe s dans sed signifie substitution. Il est utilisé pour rechercher et remplacer une chaîne de caractères dans un fichier ou un flux de texte. L’option -i permet de modifier un fichier sans créer de fichier temporaire. Par défaut, sed ne remplace que la première occurrence d’un motif sur une ligne. En ajoutant g, il remplace toutes les occurrences. `s/ancien/nouveau/`\t# Remplace 'ancien' par 'nouveau' (`s` pour \"substitute\").\r`s/ancien/nouveau/g`\t# Remplace toutes les occurrences 'd'ancien' par 'nouveau' (`g` pour \"global\").\rChanger « root » en « admin » (affichage uniquement) :\n$ sed 's/root/admin/' /etc/passwd\rChanger toutes les occurrences :\n$ sed 's/root/admin/g' /etc/passwd\rChanger et enregistrer directement dans le fichier :\n$ sed -i 's/ancien/nouveau/g' fichier_non_temporaire.txt\rcut: Extraire des colonnes d’un fichier L’option -d permet de définir le délimiteur utilisé pour diviser les champs d’une ligne.\nL’option -f est utilisée pour sélectionner un ou plusieurs champs après avoir défini un délimiteur avec -d.\nDélimiteur par défaut\rPar défaut, cut utilise la tabulation comme délimiteur.\nExtraire le 6e champ d’un fichier où les champs sont séparés par : :\n$ cut -d':' -f6 /etc/passwd\rExtraire plusieurs colonnes (1re ET 6e) :\nAVANT l’extraction: 3 premières lignes du fichier passwd\nroot:x:0:0:root:/root:/bin/bash\rbin:x:1:1:bin:/bin:/sbin/nologin\rdaemon:x:2:2:daemon:/sbin:/sbin/nologin\r$ cut -d':' -f1,6 /etc/passwd\rAPRÈS l’extraction:\nroot:/root bin:/bin daemon:/sbin\rmore: Lire un fichier page par page (ou less) more affiche le fichier page par page, mais on ne peut pas remonter. less permet d’aller en avant et en arrière. $ less /etc/passwd\rCommandes utiles dans less :\nAller en bas : ↓ ou Entrée Aller en haut : ↑ Aller au début du fichier : g Aller à la fin du fichier : G Descendre d’une page : Espace Monter d’une page : b Rechercher un mot : /mot puis Entrée Rechercher en arrière: ?mot puis Entrée Aller à la prochaine occurrence : n Revenir à l’occurrence précédente : N Quitter : q sort: Trier des lignes L’option -k permet de spécifier la colonne (ou champ) à utiliser pour le tri.\nLes colonnes sont séparées par des espaces ou des tabulations par défaut. L’option -n permet de trier des nombres correctement (plutôt qu’en mode texte).\nTrier un fichier alphabétiquement :\n$ sort fruits.txt\rTrier par colonne (exemple : fichier avec noms et numéros) :\n$ sort -k2 profs.txt\rTrier numériquement (sinon, 10 est avant 2) :\n$ sort -k2 -n profs.txt\rou\n$ sort -k2n profs.txt\rRediriger la sortie d’une commande L’entrée standard (\u003c) est une source d’information qu’une commande peut utiliser. Par défaut, l’entrée provient du clavier. Elle peut aussi provenir d’un fichier.\nLa sortie standard (1\u003e ou \u003e) est le flux par défaut où un programme écrit ses résultats, généralement affiché à l’écran (Terminal), sauf si redirigé vers un fichier ou un autre processus.\nEnregistrer la sortie standard dans un fichier:\n$ find / -name services 1\u003e resultats.txt\rSi le fichier resultats.txt n’existe pas, il sera crée.\nInformation\rIci, le chiffre 1 n’est pas obligatoire. Si on ne le met pas, la sortie standard est utilisée par défaut. La commande précédente peut s’écrire aussi comme cela:\n$ find / -name services \u003e resultats.txt\rLa sortie standard (1\u003e) n’inclut pas les erreurs. Les erreurs sont envoyées vers la sortie d’erreur standard (2\u003e). Le fichier resultats.txt ne contiendra pas les lignes ayant une mention d’erreur comme par exemple: “Permission non accordée”.\nIgnorer les erreurs à l’aide de 2\u003e:\n$ find / -name services 2\u003e/dev/null\rEnvoyer la sortie standard ET les erreurs dans un fichier:\n$ find / -name services 1\u003e resultats.txt 2\u003e\u00261\rExplications :\nCette commande find recherche un fichier ou dossier nommé “services” dans tout le système (/).\n1\u003e resultats.txt : Redirige la sortie normale (résultats trouvés) vers resultats.txt. 2\u003e\u00261 : Redirige les erreurs (ex. : permissions non accordées) vers le même fichier. Ainsi, tout (résultats et erreurs) est enregistré dans resultats.txt.\nAjouter du texte à un fichier sans l’écraser à l’aide de \u003e\u003e:\n$ echo \"Bonjour\" \u003e\u003e fichier.txt\rLa ligne Bonjour est ajoutée à la fin du fichier fichier.txt sans écraser son contenu existant (si le fichier n’existe pas, il est crée).\nEnchaîner des commandes avec | (pipe) Le | envoie le résultat d’une commande à une autre commande. La 2ème commande récupère le résultat de la 1ère commande pour travailler dessus.\nLe nombre de commandes que l’on peut ainsi enchainer n’a pas de limite.\nAfficher le fichier avec less :\n$ cat /etc/services | less\rChercher « ssh » dans un fichier et afficher :\n$ cat /etc/services | grep ssh\rCompter le nombre de lignes d’un fichier :\n$ cat fichier.txt | wc -l\rExercice 1 Sans être root et sans utiliser sudo, rechercher le fichier services sur tout le disque dur. Est-ce facile de le trouver dans la sortie de la commande ? Faites la même recherche mais en redirigeant les lignes “Accès refusé” vers le fichier /dev/null. Est-ce plus facile de trouver le résultat de la commande ? Sauvegardez le résultat dans le fichier ~/services.txt à l’aide d’une redirection. Solution\r$ find / -name services\rC’est difficile de lire la sortie car les résultats sont noyés au milieu de nombreux messages d’erreurs.\nPour rediriger les messages d’erreur:\n$ find / -name services 2\u003e/dev/null\rMaintenant la lecture est beaucoup plus facile: Pour sauvegarder le résultat dans un fichier:\n$ find / -name services 2\u003e/dev/null \u003e~/services.txt\rLes filtres Enchainer des commandes permet d’appliquer de nombreux filtres sur le résultat d’une commande:\nCommande Résutats cat fichier.txt | wc -l Compte le nombre de lignes du fichier (wc : word count, -l pour les lignes) cat fichier | grep [-iv] recherche Permet de garder (ou éliminer -v) les lignes contenant la recherche, sans tenir compte des majuscules -i. find / -name “*.conf” | sort classe le résultat de la commande find par ordre alphabétique. cat /etc/passwd | sed ’s/root/admin/’ Remplace la 1ère occurrence de root par admin dans l’affichage (pas dans le fichier) cat /etc/passwd | cut -d’:’ -f1 | sort Affiche uniquement le 1er champs de chaque ligne du fichier /etc/passwd en utilisant : comme séparateur de champs et les classe par ordre alphabétique. D’autres commandes utiles Remplacer des lettres avec la commande tr\n$ echo sAlut | tr 'A' 'a' salut\rSupprimer les doublons (nécessite sort) avec la commande uniq\n$ cat fichier | sort | uniq\rTransformer $PATH en liste triée\n$ echo $PATH | tr ':' '\\n' | sort\rCela affiche chaque dossier du PATH sur une ligne et le trie.\nExercice 2 Trouver le numéro de port de zephyr-srv dans /etc/services. Combien de lignes dans /etc/services n’ont pas de e? Combien de lignes n’ont ni e ni a ? Solution\rPour trouver le numéro de port:\ncat /etc/services | grep \"zephyr-srv\"\rLe numéro du port est 2102. Pour trouver le nombre de lignes ne contenant pas ’e':\ncat /etc/services | grep -v e | wc -l\rPour les lignes ne contenant ni ’e’ ni ‘a’:\ncat /etc/services | grep -v e | grep -v a | wc -l\rLa boucle while La boucle while permet de traiter chaque ligne d’une commande une par une.\nLa syntaxe de base d’une boucle while en Bash est la suivante :\nwhile condition; do Commandes à exécuter tant que la condition est vraie; done\rou sur plusieurs lignes\nwhile condition do Commandes à exécuter tant que la condition est vraie done\rExemple 1 : Lire un fichier ligne par ligne\nwhile read ligne; do echo \"Ligne: $ligne\"; done \u003c fichier.txt\rExemple 2 : connaître la taille de chaque dossier dans la variable d’environnement $PATH.\n$ echo $PATH | tr ':' '\\n' | while read i; do du -sh $i; done\rtr ':' '\\n' ➡ Remplace : par un saut de ligne. while read i; do ... done ➡ Lit chaque ligne et exécute du -sh dessus. Résultat : La taille de chaque dossier dans $PATH.\nInformation\rLorsqu’on étudiera les opérateurs logiques et de comparaison, on pourra spécifier des conditions à l’aide d’expressions booléennes.\nExercices 3 Recherchez tous les fichiers de configuration du système (on considère qu’ils se terminent par .conf) puis n’affichez que le nom du fichier sans le chemin. La commande basename /rep1/rep2/…/fichier.txt affiche seulement fichier.txt. Une fois l’exercice terminé, classez les résultats par ordre alphabétique. Avec une boucle while, parcourez le fichier /etc/services et pour chaque ligne, ne garder que le 1er champs en utilisant comme délimiteur (espace). Une fois terminé, éliminez les doublons et comptez le nombre de lignes. Solution\rPremière partie: Pour trouver les fichiers de configuration:\nfind / -name \"*.conf\" 2\u003e/dev/null\rPour afficher seulement le nom sans le chemin:\nfind / -name \"*.conf\" 2\u003e/dev/null | while read i; do basename \"$i\"; done\rPour classer par ordre alphabétique:\nfind / -name \"*.conf\" 2\u003e/dev/null | while read i; do basename \"$i\"; done | sort\rDeuxième partie:\ncat /etc/services | while read i; do echo \"$i\" | cut -d' ' -f1 ; done\rPour enlever les doublons et compter le nombre de ligne:\ncat /etc/services | while read i; do echo \"$i\" | cut -d' ' -f1 ; done | sort | uniq | wc -l",
    "description": "Commandes diverses Information\rLes guillemets simples (’) ou doubles (\") peuvent tous les deux être utilisés, lorsque des guillemets sont nécessaires.\ntree: Afficher l’arborescence des dossiers La commande tree affiche les fichiers et dossiers sous forme d’arborescence.\nL’option -d permet d’afficher uniquement les répertoires (et pas les fichiers).\nL’option -L permet de limiter l’affichage à N niveaux de profondeur.\nAfficher uniquement les dossiers :\n$ tree -d\t# `d` pour directory\rAfficher les dossiers d’un endroit précis :",
    "tags": [],
    "title": "Commandes utiles, redirection, chainage, filtres et boucle While",
    "uri": "/semaine4/cours/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Commandes utiles, redirection, chainage et filtrage de commandes et While",
    "content": "Objectifs de l’atelier Utiliser les commandes tree, grep, sep, cut, more, less et sort. Rediriger les résultats de commandes. Enchainer les commandes. Filtrer des données de fichiers ou répertoires. Itérer sur des résultats de commandes avec la boucle While. Atelier Astuce\rPour réaliser les exercices, vous aurez besoin de regarder les différentes commandes vues en cours (commandes et boucles). Vous devrez consulter les pages de manuel (commande man) des différentes commandes pour trouver la façon de réaliser ce que vous souhaitez. Pour effectuer des opérations simple, vous pouvez utiliser la commande bc de cette façon: $ echo 7-3 | bc\rExercice 1 Ouvrir une session avec l’utilisateur standard et reproduire, dans le répertoire courant, l’arborescence suivante et ce en utilisant un maximum de trois commandes : ├── H2025\r│ ├── Linux\r│ │ ├── Cours\r│ │ └── Ateliers\r│ └── Virtualisation\r│ └── machines\r└── Icones\rChanger de répertoire en allant dans le dossier Cours. Pour le reste des question de cet exercice, rester dans le répertoire Cours.\nEn saisissant une seule commande, créer, à l’intérieur du répertoire courant, les dossiers semaine1, semaine2, …, semaine15. Vous ne devez pas entrer tous les noms de semaines dans la commande (hint: expansion d’accolades).\nÀ l’aide d’une boucle for, à l’intérieur de chaque dossier semaine, créer un fichier .txt qui contient la phrase suivante : Ce cours concerne la semaineN\nOù N correspond au numéro de la semaine.\nToujours à partir du répertoire courant, utiliser un chemin relatif pour copier dans le dossier ateliers le fichier passwd qui est dans /etc.\nToujours à partir du répertoire courant et en utilisant le chemin relatif, renommer le fichier copié en ajoutant “Copie” à son nom (passwdCopie).\nChanger toutes les occurrences du caractère délimiteur : (deux points) du fichier passwdCopie par ; (point-virgule).\nTrier le contenu du fichier passwdCopie en ordre croissant du numéro de groupe, soit le quatrième champ. On veut que le fichier soit trié et non uniquement le résultat retourné par la commande. Hint\rUtilisez la commande man pour trouver les options de la commande sort qui vous aideront à accomplir la tâche demandée.\nExercice 2 Attention\rRevenir dans votre dossier personnel.\nÉcrire la commande qui permet de compter le nombre d’utilisateurs qui ont pour shell le /bin/bash. Vous trouverez cette information dans le fichier /etc/passwd. À l’exécution de la commande, on veut un résultat comme ceci: 11 utilisateurs ont pour shell /bin/bash\rNotez que…\rLe nombre d’utilisateurs pourrait être différent. Utilisez la commande man pour trouver l’ option de la commande grep qui vous aidera à accomplir la tâche demandée.\nMaintenant on veut écrire la ligne de commande qui permet d’afficher le nombre d’utilisateurs qui ont pour shell par défaut un des shells disponibles sur votre machine. Pour cela, il faut parcourir le fichier /etc/shells ligne par ligne (hint: boucle). Vous y trouverez les shells disponibles. À l’exécution de la commande, on aurait pour chacun des shells un résultat de la même forme que le suivant: 0 utilisateurs ont pour shell /bin/sh 11 utilisateurs ont pour shell /bin/bash 0 utilisateurs ont pour shell /usr/bin/sh 0 utilisateurs ont pour shell /usr/bin/bash\rAttention\rVous ne devez pas indiquer manuellement les noms des shells..\nExercice 3 Attention\rRevenir dans votre dossier personnel.\nPour cet exercice:\nnomdurépertoire est affiché automatiquement. N est le nombre trouvé. Référez-vous au cours de la semaine 2 sur la commande ls -l\nEn une seule ligne de commande, on veut savoir combien de fichiers et dossiers contient le répertoire courant. Le résultat doit être affiché comme suit : Le répertoire `nomdurépertoire` contient N fichiers et dossiers\rEn une seule ligne de commande, on veut savoir combien de fichiers standards contient le répertoire courant. Le résultat doit être affiché comme suit : Le répertoire `nomdurépertoire` contient N fichiers standards\rEn une seule ligne de commande, on veut savoir combien d’éléments ne sont ni des dossiers ni des fichiers standards dans le répertoire courant. Le résultat doit être affiché comme suit : Le répertoire `nomdurépertoire` contient N fichiers qui ne sont ni standards ni des répertoires\rÉcrire une commande qui récupère le nom du dernier utilisateur qui a été créé sur votre machine (c’est celui qu’on retrouve à la dernière ligne du fichier /etc/passwd). Le résultat doit être stocké dans une variable nommée nomUtilisateur.\nEn utilisant la variable nomdurépertoire qui contient le nom du dernier utilisateur défini dans /etc/passwd, écrivez une commande permettant de :\nRechercher tous les fichiers à partir de /home (find) Lister leurs détails avec ls -l Filtrer uniquement les fichiers appartenant à cet utilisateur. Filtrer uniquement les fichiers standards. La commande doit être une seule ligne en utilisant un pipe (|) et une boucle while read. Hint\rUtilisez la commande man pour trouver les options des commandes find et ls qui vous aideront à accomplir la tâche demandée.\nExercice 4 Hint\rPour les #2 et #3, Utilisez la commande man pour trouver les options de la commande sort qui vous aideront à accomplir la tâche demandée.\nEn tant qu’utilisateur standard, On veut trouver tous les fichiers .txt sur votre disque dur (ne pas utiliser sudo). Écrire la commande qui permet de retrouver cette information sans afficher les erreurs.\nRécupérer la sortie standard de la commande précédente et à partir de son résultat, lire chaque ligne et à l’aide de la commande ls, afficher la taille de ces fichiers suivi du chemin vers les fichiers.(en une seule commande sans utiliser de variable) Résultat attendu:\n0 /home/mot/dossier2/fichier4.txt 0 /home/mot/dossier3/fichier2.txt 0 /home/mot/dossier3/fichier3.txt 0 /home/mot/dossier3/fichier4.txt 79 /home/mot/prof.txt\rRécupérer la sortie standard de la commande précédente et trier le résultat par ordre croissant de taille. (en une seule commande sans utiliser de variable)",
    "description": "Objectifs de l’atelier Utiliser les commandes tree, grep, sep, cut, more, less et sort. Rediriger les résultats de commandes. Enchainer les commandes. Filtrer des données de fichiers ou répertoires. Itérer sur des résultats de commandes avec la boucle While. Atelier Astuce\rPour réaliser les exercices, vous aurez besoin de regarder les différentes commandes vues en cours (commandes et boucles). Vous devrez consulter les pages de manuel (commande man) des différentes commandes pour trouver la façon de réaliser ce que vous souhaitez. Pour effectuer des opérations simple, vous pouvez utiliser la commande bc de cette façon: $ echo 7-3 | bc\rExercice 1 Ouvrir une session avec l’utilisateur standard et reproduire, dans le répertoire courant, l’arborescence suivante et ce en utilisant un maximum de trois commandes : ├── H2025\r│ ├── Linux\r│ │ ├── Cours\r│ │ └── Ateliers\r│ └── Virtualisation\r│ └── machines\r└── Icones\rChanger de répertoire en allant dans le dossier Cours. Pour le reste des question de cet exercice, rester dans le répertoire Cours.",
    "tags": [],
    "title": "ATELIER #4: Commandes utiles, redirection, chainage, filtres et boucle while",
    "uri": "/semaine4/atelier/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "Plan de la leçon Théorie : Lundi 10 mars\nQu’est-ce qu’un processus ? Exemples de processus. L’exécution en arrière-plan. Visualiser les processus. Les états des processus. La gestion des processus. Le code de retour des commandes. Les combinaison de commandes. La création de scripts bash. Atelier : Jeudi 13 mars\nGestion et manipulation de processus à l’aide de scripts.",
    "description": "Plan de la leçon Théorie : Lundi 10 mars\nQu’est-ce qu’un processus ? Exemples de processus. L’exécution en arrière-plan. Visualiser les processus. Les états des processus. La gestion des processus. Le code de retour des commandes. Les combinaison de commandes. La création de scripts bash. Atelier : Jeudi 13 mars\nGestion et manipulation de processus à l’aide de scripts.",
    "tags": [],
    "title": "Les processus Linux",
    "uri": "/semaine5/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Les processus Linux",
    "content": "Les processus Chaque application, chaque commande est un processus.\nCertains processus vont s’exécuter jusqu’à ce que vous les arrêtiez, d’autres vont réaliser une tâche et s’arrêter tout seul.\nExemple:\nCommande Comportement ls S’exécute et se termine immédiatement. firefox Ouvre Firefox et reste en exécution empêchant l’utilisation du terminal, jusqu’à la fermeture de Firefox. Quand une commande empêche l’utilisation du terminal pendant son exécution, elle s’exécute au premier plan.\nPour permettre l’utilisation du terminal, il faut lancer l’application bloquante en arrière-plan.\nExécution en arrière-plan Deux possibilités :\nAu lancement : Ajouter \u0026 à la fin de la commande : $ firefox \u0026\rAprès lancement : Suspendre avec Ctrl-z Reprendre en arrière-plan avec bg Repasser au premier plan avec fg Exercice 1 Lancez Firefox, passez-le en arrière-plan et ramenez-le au premier plan.\nSolution…\r$ firefox \u0026 # Lancement en arrière-plan $ fg # Ramène au premier plan\rPour arrêter une commande au premier plan : Ctrl-c\nAffichage et gestion des processus Chaque processus est identifié par :\nIdentifiant Description pid Identifiant unique du processus. ppid Identifiant du processus parent. Exemple:\nSi vous lancez une commande à partir du terminal, celui-ci est le parent du processus créé.\nCommande Description ps -f Affiche les processus en cours d’exécution depuis le terminal. ps -ef Affiche les détails de tous les processus du système. pstree Affiche l’arborescence des processus. top Affiche les processus en temps réel. kill pid Termine un processus avec son pid. kill -9 pid Termine immédiatement un processus. killall nom_processus Termine tous les processus portant un certain nom. Exercice 2 Utilisez ps pour :\nNoter le pid de votre shell. Lancer Firefox an arrière-plan et observer son pid ainsi que son ppid. Solution…\r$ ps -ef | grep bash $ firefox \u0026 $ ps -ef | grep firefox # Trouver le PID et PPID\rLe pid du parent de Firefox doit être le pid de votre SHELL.\nÉtats des processus État Description Élu En cours d’exécution sur le processeur. Prêt En attente d’exécution, sans attente de ressource. Bloqué En attente d’une ressource autre que le processeur. Zombie Terminé mais non encore récupéré par son processus parent. Ces états sont gérés par l’ordonnanceur.\nL’ordonnanceur\rC’est la partie du noyau du système d’exploitation responsable du choix du processus élu qui va pouvoir bénéficier du service du processeur (et globalement toutes les tâches annexes qui en découlent). Cette tâche se nomme l’ordonnancement.\nExercice 3 Lancez Firefox en arrière-plan et notez son pid et ppid. Tuez son parent. Quel est le ppid de Firefox maintenant ? Solution…\r$ firefox \u0026 $ ps -ef | grep firefox # Noter PID et PPID $ kill -9 \u003cPPID\u003e # Tuer le parent $ ps -ef | grep firefox # Observer le nouveau PPID (probablement systemd, ou une instance)\rLe ppid de firefox est le pid de votre terminal.\nComment se nomme le processus 1?\rinit\nExécution persistante des processus Si un terminal est fermé, ses processus sont arrêtés. Pour éviter cela :\nCommande Effet disown \u003cpid\u003e Si le processus est en cours, il se détachera de son terminal. nohup \u003ccommande\u003e Lance une commande en ignorant les signaux de fermeture du terminal. Exercice 4 Exécuter grep \u003cfichier\u003e, puis:\nNoter que cette commande ne se termine pas. Ouvrir un autre terminal. Trouver le pid de la commande grep. Tuer la commande. Ouvrir un nouveau terminal,\na) Lancer Firefox en arrière-plan, fermer le terminal. Que se passe-t-il ? b) Exécuter disown \u003cpid firefox\u003e, puis lancer Firefox en arrière-plan, fermer le terminal. Que se passe-t-il ? c) Exécuter nohup firefox, puis lancer Firefox en arrière-plan, fermer le terminal. Que se passe-t-il ? Solution…\r1\n$ grep fichier $ ps -ef | grep egrep # Trouver le PID de egrep $ kill -9 \u003cPID de egrep\u003e # Terminer depuis un autre terminal\r2 a)\n$ firefox \u0026\rAprès avoir fermé le terminal, Firefox se ferme aussi.\n2 b)\n$ disown \u003cPID\u003e $ firefox \u0026\r2 c)\n$ nohup $ firefox \u0026\rAvec l’utilisation de disown et nohup, le terminal peut être fermé mais Firefox reste ouvert.\nCodes de retour et variables système Variable Description $? Code de retour de la dernière commande (0 = succès, autre = erreur). $! PID de la dernière commande exécutée en arrière-plan. Exemple:\n$ test -e fichier $ echo $? # Affiche 0 si le fichier existe, un autre chiffre sinon\rExercice 5 Lancez ls. Quel est son code de retour ? Est-ce un succès ou un échec ? Lancez find / -name \"*.conf\" sans être root. Quel est le code de retour ? Pourquoi ? Solution…\r1.\n$ ls $ echo $?\rLe code de retour est 0, car ls se termine avec succès.\n2.\n$ find / -name \"*.conf\" $ echo $? # Probablement 1 à cause des permissions\rLe code de retour est différent de 0 (probablement 1), car il y a eu une erreur (permission: accès refusé)\nOpérateurs de comparaison en Bash Les opérateurs de comparaison permettent de tester des valeurs numériques dans des conditions.\nOpérateur Signification Exemple -eq Égalité (equal) test $var -eq 0 -ne Différence (not equal) test $var -ne 0 -lt Strictement inférieur (less than) test $var -lt 0 -gt Strictement supérieur (greater than) test $var -gt 0 -le Inférieur ou égal (less or equal) test $var -le 0 -ge Supérieur ou égal (greater or equal) test $var -ge 0 Attente de la fin d’exécution d’une commande Il est possible d’attendre qu’une commande en arrière-plan se termine avant de poursuivre l’exécution d’autres commandes.\nExemple :\n$ cp dossierVolumineux/* destination \u0026 $ wait $!\rwait attend que la copie en arrière-plan soit terminée avant de poursuivre.\nDans un script, on peut attendre plusieurs commandes exécutées en arrière-plan :\n#!/bin/bash cp dossier1/* destination1 \u0026 cp dossier2/* destination2 \u0026 wait echo \"Toutes les copies sont terminées.\"\rCombinaison et synchronisation des commandes Opérateurs logiques Opérateur Exemple Fonctionnement ; $ commande1 ; commande2 commande2 s’exécute une fois que commande1 se termine, indépendamment du succès ou de l’échec. \u0026 $ commande1 \u0026 commande2 \u0026 Les commandes s’exécutent en parallèle, simultanément. \u0026\u0026 $ commande1 \u0026\u0026 commande2 commande2 s’exécute si commande1 réussit. || $ commande1 || commande2 commande2 s’exécute si commande1 échoue. Exemples :\nTester l’existence d’un fichier avant d’exécuter une commande :\n$ test -e fichier \u0026\u0026 commande\rAfficher “OK” si la commande réussit :\n$ commande \u0026\u0026 echo \"OK\"\rAfficher “ERREUR” si la commande échoue :\n$ commande || echo \"ERREUR\"\rAfficher “OK” si la commande réussit, sinon “ERREUR” :\n$ test $var -eq 0 \u0026\u0026 echo \"OK\" || echo \"ERREUR\"\rC’est l’équivalent d’un SI var = 0 ALORS affiche “OK”, SINON affiche “ERREUR”.\nExercice 6 : Expérimentation des opérateurs logiques Exécutez :\n$ find / -name \"*.conf\" \u0026\u0026 ls\rLes deux commandes s’exécutent elles ? Inversez-les et observez le résultat. Exécutez :\n$ find / -name \"*.conf\" || ls\rLes deux commandes s’exécutent elles ? Inversez-les et observez le résultat. Exécutez :\n$ find / -name \"*.conf\" \u0026 ls \u0026\rLes deux commandes s’exécutent elles en parallèle ? Solution…\r$ find / -name \"*.conf\" \u0026\u0026 ls ls s’exécute si find réussit.\n$ find / -name \"*.conf\" || ls\rls s’exécute si find échoue\n$ find / -name \"*.conf\" \u0026 ls \u0026\rLes deux commendes s’exécutent simultanément.\nPriorité des opérateurs On peut utiliser des parenthèses pour organiser l’ordre d’exécution des opérateurs :\nExemple :\n$ (find / -name \"*.conf\" 2\u003e/dev/null || ls) | grep a\rDans cet exemple :\nfind est exécuté en premier. Si une erreur survient, ls prend le relais. Ensuite, grep filtre les résultats. Si on écrit :\n$ find / -name \"*.conf\" 2\u003e/dev/null || (ls | grep a)\rSeul le résultat de ls sera filtré par grep en cas d’échec de find.\nCréation et exécution d’un script Bash Un script Bash est un fichier .sh contenant une série de commandes.\nCréation d’un script Ouvrir un fichier avec Vim : $ vim monscript.sh\rAjouter l’en-tête (1re ligne) du script : #!/bin/bash\rElle n’est pas obligatoire, mais pour ce cours, cette ligne DOIT TOUJOURS être présente. Il faut aussi comprendre son utilité. Écrire les commandes et ajouter des commentaires (précédés de #). Exemple : fichier monscript.sh\n#!/bin/bash echo \"Bonjour tout le monde\" pwd touch fiche{1..5}.txt\rExécution d’un script $ bash chemin_vers_monscript.sh\rScripts concurrents Un script concurrent contient des commandes exécutées en arrière-plan.\nExemple :\n#!/bin/bash (echo \"Début copie dossier 1\"; cp dossier1/* destination1; echo \"Fin copie\") \u0026 (echo \"Début copie dossier 2\"; cp dossier2/* destination2; echo \"Fin copie\") \u0026 wait echo \"Toutes les copies sont terminées.\"\rDans cet exemple :\nChaque copie est lancée en arrière-plan avec \u0026. wait garantit que le script affiche “Toutes les copies sont terminées” uniquement après la fin des copies. Un autre exemple avec sleep :\n#!/bin/bash (sleep 15; echo \"Pause de 15 secondes terminée\") \u0026 (sleep 20; echo \"Pause de 20 secondes terminée\") \u0026 (sleep 3; echo \"Pause de 3 secondes terminée\") \u0026 wait echo \"Réveillez-vous, toutes les pauses sont terminées !\"\rCe script Bash lance trois commandes sleep en parallèle, chacune suivie d’un message indiquant la fin de la pause.\nExplication :\nLancement en arrière-plan (\u0026) :\nsleep 15 attend 15 secondes avant d’afficher “Pause de 15 secondes terminée”. sleep 20 attend 20 secondes avant d’afficher “Pause de 20 secondes terminée”. sleep 3 attend 3 secondes avant d’afficher “Pause de 3 secondes terminée”. Chaque commande est exécutée en arrière-plan grâce au \u0026, ce qui signifie qu’elles démarrent immédiatement et ne bloquent pas l’exécution du script.\nwait :\nCette commande attend que toutes les tâches en arrière-plan soient terminées avant de poursuivre. Affichage final :\nUne fois toutes les pauses terminées, appuyer sur Entrée, le script affiche \"Réveillez-vous, toutes les pauses sont terminées !\". Exercice 7 Exécutez un script avec sleep 15, sleep 20, et sleep 3 en parallèle. Dans quel ordre s’afficheront les messages ? Que se passe-t-il si vous retirez wait ? Solution…\rL’ordre d’affichage: Après 3 secondes → \"Pause de 3 secondes terminée\" Après 15 secondes → \"Pause de 15 secondes terminée\" Après 20 secondes → \"Pause de 20 secondes terminée\" Enfin, lorsque toutes les commandes sont terminées → `“Réveillez-vous, toutes les pauses sont terminées !” Si on enlève wait, le script pourrait afficher immédiatement le dernier message avant la fin des sleep. `",
    "description": "Les processus Chaque application, chaque commande est un processus.\nCertains processus vont s’exécuter jusqu’à ce que vous les arrêtiez, d’autres vont réaliser une tâche et s’arrêter tout seul.\nExemple:\nCommande Comportement ls S’exécute et se termine immédiatement. firefox Ouvre Firefox et reste en exécution empêchant l’utilisation du terminal, jusqu’à la fermeture de Firefox. Quand une commande empêche l’utilisation du terminal pendant son exécution, elle s’exécute au premier plan.\nPour permettre l’utilisation du terminal, il faut lancer l’application bloquante en arrière-plan.",
    "tags": [],
    "title": "Les processus de Linux",
    "uri": "/semaine5/cours/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Les processus Linux",
    "content": "Objectifs de l’atelier Dans cet atelier, vous allez créer deux versions d’un script Bash :\nUne version séquentielle, où les commandes s’exécutent les unes après les autres. nombre_de_fichiers_seq.sh : Affiche le nombre de fichiers par type. Une version asynchrone, où plusieurs commandes s’exécutent simultanément en arrière-plan. nombre_de_fichiers_conc.sh : Réécriture du script précédent avec des commandes asynchrones (\u0026). Remise Vous devez remettre sur Moodle :\nVos deux fichiers .sh Deux captures d’écran illustrant le fonctionnement des scripts : Capture Contenu 01_nombre_de_fichiers_seq.png Exécution du script nombre_de_fichiers_seq.sh et résultats 02_nombre_de_fichiers_conc.png Exécution du script nombre_de_fichiers_conc.sh et son résultat Quelques rappels utiles\rStocker une valeur dans une variable nb=$(ls | wc -l)\rCette commande stocke le nombre de fichiers du répertoire courant dans la variable nb.\nTester la valeur d’une variable Pour comparer la valeur d’une variable à un chiffre :\ntest $nb -eq 10\rCette commande compare nb à 10. Si les deux valeurs sont égales, le code de retour sera 0, sinon il sera différent de 0.\nOn peut alors utiliser cette comparaison dans une condition :\ntest $nb -eq 10 \u0026\u0026 echo \"Les deux valeurs sont égales\" || echo \"Les deux valeurs sont différentes\"\rParcourir une variable avec une boucle for Si vous avez une liste de serveurs dans une variable et souhaitez les parcourir :\nserveurs=\"google.com facebook.com youtube.com\" for i in $serveurs; do echo $i; done\rAtelier Exercice 1 : Script séquentiel Créer un script nombre_de_fichiers_seq.sh contenant des commandes séquentielles.\nLe script doit :\nCompter le nombre de fichiers pour les extensions suivantes : java, conf, txt, png, tiff. Afficher le nombre de fichiers pour chaque type. Si aucun fichier d’un type donné n’existe, afficher : Il n’y a aucun fichier .\u003cextension\u003e\rNe pas afficher d’autres informations. À inclure au début du script\ntypes=\"java conf txt png tiff\"\rExemple de résultat\nDécompte des fichiers java conf txt png tiff Il y a 50718 fichiers .java Il y a 1171 fichiers .conf Il y a 6999 fichiers .txt Il y a 67296 fichiers .png Il n’y a aucun fichier .tiff Exercice 2 : Script concurrent Créer un script nombre_de_fichiers_conc.sh, qui est une version asynchrone du script précédent.\nSpécifications du script\nEffectuer exactement les mêmes opérations que le script séquentiel. Utiliser le symbole \u0026 pour exécuter les commandes en arrière-plan. Exécuter toutes les commandes find simultanément. Regrouper les commandes avec (CMD1; CMD2; …) \u0026 pour les exécuter en parallèle. Ajouter une commande wait à la fin du script pour s’assurer que tous les processus se terminent avant la fin du script. Exemple de résultat\nL’ordre des lignes peut être différent en raison de l’exécution parallèle.\nDécompte des fichiers java conf txt png tiff Il y a 1171 fichiers .conf Il n’y a aucun fichier .tiff Il y a 67296 fichiers .png Il y a 50718 fichiers .java Il y a 6999 fichiers .txt",
    "description": "Objectifs de l’atelier Dans cet atelier, vous allez créer deux versions d’un script Bash :\nUne version séquentielle, où les commandes s’exécutent les unes après les autres. nombre_de_fichiers_seq.sh : Affiche le nombre de fichiers par type. Une version asynchrone, où plusieurs commandes s’exécutent simultanément en arrière-plan. nombre_de_fichiers_conc.sh : Réécriture du script précédent avec des commandes asynchrones (\u0026). Remise Vous devez remettre sur Moodle :\nVos deux fichiers .sh Deux captures d’écran illustrant le fonctionnement des scripts : Capture Contenu 01_nombre_de_fichiers_seq.png Exécution du script nombre_de_fichiers_seq.sh et résultats 02_nombre_de_fichiers_conc.png Exécution du script nombre_de_fichiers_conc.sh et son résultat Quelques rappels utiles\rStocker une valeur dans une variable nb=$(ls | wc -l)\rCette commande stocke le nombre de fichiers du répertoire courant dans la variable nb.",
    "tags": [],
    "title": "ATELIER #5: Gestion des processus Linux",
    "uri": "/semaine5/atelier/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "Revenez me voir\rD’ici le test #2 (jeudi 20 mars), revenez sur cette page fréquemment, pour prendre connaissance des ajouts et/ou modifications.\nNe vous limitez pas à cette page pour vous préparer au test #2, car certaines notions du cours ne s’y trouvent pas.\n1. La commande tree La commande tree permet d’afficher la structure des dossiers sous forme d’arbre. Elle est utile pour visualiser rapidement l’organisation des fichiers.\nExemple :\ntree mon_dossier/\rAffiche tous les fichiers et sous-dossiers de mon_dossier.\n2. La commande grep La commande grep est utilisée pour rechercher un mot ou une expression dans un fichier ou une sortie de commande.\nExemple :\ngrep \"erreur\" journal.log\rAffiche toutes les lignes contenant “erreur” dans le fichier journal.log.\n3. La commande sed La commande sed permet de modifier un fichier en remplaçant du texte sans l’ouvrir manuellement.\nExemple :\nsed 's/ancien/nouveau/g' fichier.txt\rRemplace toutes les occurrences de “ancien” par “nouveau” dans fichier.txt.\n4. La commande cut La commande cut est utilisée pour extraire des parties spécifiques d’une ligne de texte, généralement des colonnes dans un fichier CSV ou un tableau.\nExemple :\ncut -d',' -f2 fichier.csv\rAffiche la deuxième colonne du fichier fichier.csv, en supposant que les colonnes sont séparées par des virgules.\n5. La commande sort La commande sort permet de trier les lignes d’un fichier dans un ordre spécifique.\nExemple :\nsort noms.txt\rTrie les lignes du fichier noms.txt par ordre alphabétique.\n6. Redirection des résultats Les résultats des commandes peuvent être redirigés vers un fichier ou enchaînés avec d’autres commandes.\n\u003e : Écrit dans un fichier (écrase le contenu existant) ls \u003e liste_fichiers.txt\r\u003e\u003e : Ajoute au fichier sans écraser le contenu existant echo \"Nouveau texte\" \u003e\u003e liste_fichiers.txt\r| (pipe) : Enchaîne des commandes ls | grep \"txt\"\rAffiche uniquement les fichiers contenant “txt” dans leur nom. 7. La commande find find permet de rechercher des fichiers dans un répertoire selon divers critères :\nfind /home -name \"*.txt\"\rCe code cherche et affiche tous les fichiers .txt qui se trouvent dans /home.\nAutre exemple :\nfind . -type d Ce code cherche et affiche tous les répertoires qui se trouvent dans le répertoire actuel.\n8. La commande wc wc (word count) permet de compter le nombre de lignes, mots et caractères dans un fichier :\nwc -l fichier.txt # Compte les lignes wc -w fichier.txt # Compte les mots wc -c fichier.txt # Compte les caractères 9. Variables Une variable stocke une valeur, comme du texte ou un nombre ou le résultat d’un commande (voir le point 10.):\nnom=\"Alice\" age=25\rOn accède à la valeur d’une variable avec $ :\necho \"Bonjour, $nom !\"\r10. Stocker le résultat d’une commande dans une variable On peut stocker le résultat d’une commande dans une variable avec $(...) :\ndate_actuelle=$(date) echo \"Nous sommes le $date_actuelle\"\r11. Pipe-line (|) Le pipe (|) permet de transmettre la sortie d’une commande à la commande suivante :\nls -l | grep \"linux\"\rVoici ce que ce code fait:\nls -l: liste les fichiers du répertoire courant grep \"linux\": prends le résultat de la première commande, dans ce résultat, cherche les fichiers qui contiennent le mot “linux” et affiche uniquement ces fichiers. Autre exemple :\ncat fichier.txt | wc -l\rCe code compte le nombre de lignes dans fichier.txt. cat fichier.txt retourne le contenu du fichier à la commande wc -l pour compter les lignes.\n12. Opérateurs de comparaison et logiques Les opérateurs de comparaison permettent de comparer des valeurs :\nEn bash, Il ne faut pas utiliser les opérateurs =, !=, \u003c, \u003c=, \u003e, \u003e=. Il faut plutôt utiliser les opérateurs ci-dessous :\nOpérateur Signification -eq égal à -ne différent de -lt inférieur à -le inférieur ou égal à -gt supérieur à -ge supérieur ou égal à Les opérateurs logiques permettent de combiner des conditions :\ncommande1 \u0026\u0026 commande2 : ET (exécute la commande suivante si la première commande réussit) commande1 || commadne2 : OU (exécute la commande suivante si la première commande échoue) Exemples :\ntest $age -ge 18 \u0026\u0026 echo \"Majeur\" || echo \"Mineur\"\rCas 1: si age=20, test $age -ge 18 réussit, donc c’est “Majeur” qui s’affiche Cas 2: si age=17, test $age -ge 18 échoue, donc c’est “Mineur” qui s’affiche\n13. La commande test test permet d’évaluer des conditions sur des fichiers et des valeurs numériques :\ntest -e \"fichier.txt\" \u0026\u0026 cat fichier.txt || touch fichier.txt test $note ge 60 \u0026\u0026 echo \"Cours réussit\" || echo \"Cours échoué\"\rExplication du premier test :\ntest -e \"fichier.txt\" vérifie si le fichier existe. S’il existe on affiche son contenu avec cat fichier.txt, sinon, on crée le fichier a l’aide de la commande touch fichier.txt. 14. Boucles for et while Les boucles permettent d’exécuter des commandes plusieurs fois.\nBoucle for :\nfor variable in éléments_sur_lesquels_boucler do commande1 commande2 commande3 ... done\rBoucle while :\nwhile condition do commande1 commande2 commande3 ... done\rNB: Dans un fichier .sh, que ce soit pour la boucle for ou la boucle while, on ne mets pas les point-virgule, on les remplace par un saut de ligne.\n15. Processus séquentiels vs concurrents Processus séquentiels :\nLes commandes s’exécutent l’une après l’autre dans l’ordre qu’elles sont écrites :\necho \"S'affiche en premier\" echo \"S'affiche en deuxième\" echo \"S'affiche en premier\"\rProcessus concurrents :\nOn peut exécuter des commandes en parallèle (simultanément) avec \u0026 :\ncommande1 \u0026 # s'exécute en arrière-plan commande2 \u0026 # s'exécute en arrière-plan commande3 \u0026 # s'exécute en arrière-plan wait # s'assure que les 3 commandes sont terminées avant d'executer le `echo` suivant echo \"Autre tâche en cours\"\rOn peut utiliser les parenthèses ( ) pour grouper des commandes à executer en parallèle. Exemples:\nfor i in une_liste_d'éléments do (commande1 commande2 commande3) \u0026 done\rOU\nfor i in une_liste_d'éléments do (commande1) \u0026 (commande2) \u0026 (commande3) \u0026 done\rRappel : La variable i aura comme valeur un élément à la fois de la liste à parcourir, à chaque tour de la boucle. Pour utiliser cette valeur, on devra utiliser $i.",
    "description": "Revenez me voir\rD’ici le test #2 (jeudi 20 mars), revenez sur cette page fréquemment, pour prendre connaissance des ajouts et/ou modifications.\nNe vous limitez pas à cette page pour vous préparer au test #2, car certaines notions du cours ne s’y trouvent pas.\n1. La commande tree La commande tree permet d’afficher la structure des dossiers sous forme d’arbre. Elle est utile pour visualiser rapidement l’organisation des fichiers.\nExemple :",
    "tags": [],
    "title": "TEST #2-Quelques notions à maitriser",
    "uri": "/revisiontest2/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "Plan de la leçon Théorie : lundi 17 mars Rôles des expressions régulières. Quelques motifs de base. La commande egrep. L’opérateur logique OU. Les ensembles de caractères. Les intervalles. Les quantificateurs. Les groupes. L’échappement de caractères spéciaux. Test #2 : jeudi 20 mars Durée: 1h45 Format: Test Moodle (total de 14 questions) Questions à choix multiples Questions à réponses courtes Questions à coder (2 scripts) Matière: Semaine 4 et semaine 5 Documentation permise: 1 feuille de note 8.5x11 recto-verso (manuscrite ou imprimée). Atelier #6: Remise lundi 24 mars 23h59. Utilisation d’expressions régulières.",
    "description": "Plan de la leçon Théorie : lundi 17 mars Rôles des expressions régulières. Quelques motifs de base. La commande egrep. L’opérateur logique OU. Les ensembles de caractères. Les intervalles. Les quantificateurs. Les groupes. L’échappement de caractères spéciaux. Test #2 : jeudi 20 mars Durée: 1h45 Format: Test Moodle (total de 14 questions) Questions à choix multiples Questions à réponses courtes Questions à coder (2 scripts) Matière: Semaine 4 et semaine 5 Documentation permise: 1 feuille de note 8.5x11 recto-verso (manuscrite ou imprimée). Atelier #6: Remise lundi 24 mars 23h59. Utilisation d’expressions régulières.",
    "tags": [],
    "title": "Les expressions régulières",
    "uri": "/semaine6/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Les expressions régulières",
    "content": "Introduction aux expressions régulières Dans l’univers Linux, la manipulation des fichiers texte est une tâche essentielle. Parmi les outils utilisés pour ce faire, on trouve notamment :\ncat : pour afficher le contenu des fichiers, sed : pour les transformations textuelles, grep : pour rechercher et filtrer des lignes. Avec grep, vous pouvez filtrer un texte pour ne conserver que les lignes contenant un mot ou une expression donnée, ou bien les exclure. Mais comment faire si vous souhaitez rechercher des motifs plus complexes, comme des adresses e-mail ou des numéros de téléphone ? C’est ici qu’interviennent les expressions régulières, un outil puissant pour décrire des motifs précis et identifier des textes ayant une structure particulière.\nExemple : URL Web Un exemple d’expression régulière pour capturer une URL (adresse web):\nhttps?://[a-zA-Z0-9\\.-]+\\.[a-zA-Z]{2,4}(/\\S*)?\rExplication…\rhttps?:// → Indique que l’URL commence par http:// ou https://.\nLe s? signifie que le s est facultatif (pour inclure HTTP et HTTPS). [a-zA-Z0-9\\.-]+ → Représente le nom de domaine, qui peut contenir :\nDes lettres (a-z, A-Z), Des chiffres (0-9), Des points (.) et des tirets (-). Le + signifie qu’il doit y avoir au moins un caractère. \\.[a-zA-Z]{2,4} → Désigne l’extension du domaine, comme .com, .org, .net, etc.\nLe \\. correspond au point avant l’extension. [a-zA-Z]{2,4} signifie que l’extension contient entre 2 et 4 lettres (ex. fr, com, info). (/\\S*)? → Capture la partie après le domaine (le chemin).\nLe / signifie que l’URL peut contenir un chemin (ex. /page1). \\S* signifie « zéro ou plusieurs caractères qui ne sont pas des espaces » (le contenu du chemin). Le ? indique que cette partie est facultative (l’URL peut se terminer après l’extension du domaine). Exemple d’URLs valides selon cette regex : http://example.com https://www.mon-site.fr/page1 https://blog.exemple.net/article Premiers pas avec les expressions régulières Voici quelques motifs de base et leurs significations :\nMotif Description Exemple Contre-exemple ab Recherche la chaîne exacte “ab”. “ab” “a”, “b”, chaîne vide . Correspond à n’importe quel caractère. “a”, “b” “ab”, chaîne vide ^ Indique le début d’une ligne. ^a : un “a” au début. Toute ligne ne commençant pas par “a”. $ Indique la fin d’une ligne. a$ : un “a” à la fin. Toute ligne ne se terminant pas par “a”. Commandes pratiques avec egrep La commande egrep est une version avancée de grep, qui prend en charge les expressions régulières étendues (ERE).\nRechercher les lignes contenant “ssh” dans un fichier :\n$ egrep 'ssh' /etc/services\rRechercher uniquement les commentaires (lignes commençant par #) :\n$ egrep '^#' /etc/services\rRechercher les lignes se terminant par “s” :\n$ egrep 's$' /etc/services\rRechercher les lignes contenant “a” et “z” séparées par un caractère quelconque :\n$ egrep 'a.z' /etc/services\rOpérateurs logiques Le OU (|) L’opérateur | permet de rechercher des lignes contenant l’une ou l’autre des expressions spécifiées.\nExemple : Filtrer les lignes contenant “ssh” ou “ftp” :\n$ egrep 'ssh|ftp' /etc/services\rFiltrer les commentaires ou les lignes se terminant par “s” :\n$ egrep '^#|s$' /etc/services\rEnsembles de caractères Les ensembles permettent de rechercher plusieurs possibilités similaires en regroupant des caractères entre crochets [ ].\nExemple : Rechercher “loucher”, “toucher”, “doucher”, ou “coucher” :\n$ egrep '[ltdc]oucher' fichier\rExclure ces mots tout en recherchant ceux contenant “oucher” :\n$ egrep '[^ltdc]oucher' fichier\rIntervalles Ensemble Description [a-z] Toutes les lettres minuscules. [A-Z] Toutes les lettres majuscules. [0-9] Tous les chiffres. [a-zA-Z0-9] Tous les caractères alphanumériques. Important\rUn ensemble décrit un seul caractère dans la chaine recherchée. Par exemple: [a-zA-Z0-9] signifie qu’il y a 1 seule lettre minuscule ou majuscule OU 1 seul chiffre. Rechercher des mots contenant un “f” et un “p” séparés par une lettre minuscule :\n$ egrep 'f[a-z]p' /etc/services\rRechercher les lignes commençant par un chiffre :\n$ egrep '^[0-9]' /etc/services\rExclure les commentaires :\n$ egrep '^[^#]' /etc/services\rQuantificateurs Les quantificateurs précisent le nombre de répétitions d’un motif.\nQuantificateur Signification ? 0 ou 1 fois. + 1 ou plusieurs fois. * 0 ou plusieurs fois. {n} Exactement n fois. {n,m} Entre n et m fois (n et m inclus). {n,} Au moins n fois. Rechercher “www” dans un texte :\n$ egrep 'w{3}' fichier\rRechercher “http” ou “https” :\n$ egrep 'https?' fichier\rRechercher une lettre minuscule répétée entre 3 et 6 fois inclues:\n$ egrep '[a-z]{3,6}' fichier\rGroupes Les groupes permettent de regrouper des parties d’expressions avec des parenthèses ( ). Cela permet d’appliquer un quantificateur ou de réutiliser le groupe.\nContrairement aux intervalles ([ ]), les groupes ( ) représentent plus d’un caractères.\nExemple : (ab)*c\rCorrespond à : “zéro ou plusieurs ‘ab’, suivi d’un ‘c’”. Cela capture “c”, “abc”, “ababc”, etc. Échappement Pour rechercher des caractères ayant une signification spéciale dans les expressions régulières (., +, *, etc.), il faut les échapper avec un antislash (\\).\nExemple : Rechercher les lignes se terminant par un point : $ egrep '\\.$' fichier\rLes caractères blancs et non blancs En expressions régulières, certains raccourcis permettent de rechercher facilement les espaces incluant les tabulations et les retours à la ligne (Entrée).\nExpression Signification \\s Correspond à n’importe quel espace blanc, y compris l’espace ( ), la tabulation (\\t) et le retour de ligne (\\n). \\S Correspond à n’importe quel caractère sauf un espace blanc. Il inclut les lettres, chiffres, ponctuation et symboles. Exemples : Expression Correspondance Non correspondance \\s+ \" \" (espace), \"\\t\" (tabulation) \"abc\", \"123\" \\S+ \"abc\", \"123\", \"@!#\" \" \" (espace), \"\\n\" (saut de ligne) Utilisation pratique : Trouver tous les mots dans un texte (séparés par des espaces) : $ egrep '\\S+' fichier.txt\rExercices pratiques Trouvez les numéros de cartes de crédit valides (16 chiffres, commençant par 4540 et sans 9 dans le dernier groupe) :\n4540 6010 4510 8888\r5440 5010 6610 1010\r4540 7010 4428 5490\r4540 8523 4013 1314\r4540 8710 5410 1012 1314\rSolution…\rRègles à respecter :\n16 chiffres. Commence par “4540”. Le dernier groupe (4 chiffres) ne doit pas contenir le chiffre 9. Cas 1 Expression proposée (format avec espaces obligatoires entre groupes) :\n^4540 [0-9]{4} [0-9]{4} [0-8]{4}$\rExplications :\n^4540 : La chaîne doit commencer par “4540”. [0-9]{4} : Ensuite, un espace suivi de 4 chiffres (de 0 à 9) (deux fois). [0-8]{4} : Un espace puis exactement 4 chiffres, chacun allant de 0 à 8 (ainsi, aucun 9 n’est autorisé dans ce dernier groupe).\n$ : Fin de la chaîne.\nRemarque : Si vous souhaitez accepter des formats avec ou sans espaces, vous pouvez adapter l’expression en rendant les espaces optionnels avec \\s? :\n^4540\\s?[0-9]{4}\\s?[0-9]{4}\\s?[0-8]{4}$\rIdentifiez les noms de variables valides (lettres, chiffres, underscores, mais ne commençant pas par un chiffre) : Abcd abcd_ var123 _var2 1nombre\rSolution…\rRègles à respecter :\nDoit être composé de lettres, chiffres et underscores. Ne peut pas commencer par un chiffre. ^[A-Za-z_][A-Za-z0-9_]*$\rExplications :\n^[A-Za-z_] : Le premier caractère doit être une lettre (majuscule ou minuscule) ou un underscore. [A-Za-z0-9_]* : Les caractères suivants peuvent être des lettres, des chiffres ou des underscores, et ils peuvent apparaître zéro ou plusieurs fois. $ : Fin de la chaîne.\nRecherchez les adresses IPv4 valides (quatre nombres entre 0 et 255, séparés par des points) :\n1.240.40.15\r2.256.20.190\r192.168.255.255\r300.200.100.10\r30.40.50.60\r192.168.2\r10.10.10.10.10\rSolution…\rRègles à respecter :\n4 nombres séparés par des points. Chaque nombre (octet) doit être compris entre 0 et 255. ^(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])(\\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3}$\rExplications :\nPour un octet : 25[0-5] : Correspond aux nombres de 250 à 255. 2[0-4][0-9] : Correspond aux nombres de 200 à 249. 1[0-9]{2} : Correspond aux nombres de 100 à 199. [1-9]?[0-9] : Correspond aux nombres de 0 à 99 (le [1-9]? permet d’éviter un zéro initial non significatif, tout en autorisant le 0 seul). ^ ... $ : Assure que toute la chaîne correspond exactement à ce format. (\\.(...)){3} : Indique qu’après le premier octet, trois autres octets doivent précéder, chacun précédé d’un point.",
    "description": "Introduction aux expressions régulières Dans l’univers Linux, la manipulation des fichiers texte est une tâche essentielle. Parmi les outils utilisés pour ce faire, on trouve notamment :\ncat : pour afficher le contenu des fichiers, sed : pour les transformations textuelles, grep : pour rechercher et filtrer des lignes. Avec grep, vous pouvez filtrer un texte pour ne conserver que les lignes contenant un mot ou une expression donnée, ou bien les exclure. Mais comment faire si vous souhaitez rechercher des motifs plus complexes, comme des adresses e-mail ou des numéros de téléphone ? C’est ici qu’interviennent les expressions régulières, un outil puissant pour décrire des motifs précis et identifier des textes ayant une structure particulière.",
    "tags": [],
    "title": "Les expressions régulières",
    "uri": "/semaine6/cours/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Les expressions régulières",
    "content": "Objectif de l’atelier Maîtriser les bases des expressions régulières. Renforcer la capacité à manipuler des fichiers texte. Renforcer la précision dans la recherche et le filtrage de données. Atelier Important\rUtiliser le fichier expr.txt se trouvant sur Moodle. Faites un copier-coller du contenu du fichier expr.txt dans un nouveau fichier texte. Utiliser uniquement les commandes, les symboles et la matière vue dans le cours (semaines 1 à 6) RegExp: Tableaux récapitulatifs Dans le fichier expr.txt, à l’aide d’expressions régulières:\nTrouvez les codes postaux canadiens :\nFormat attendu : LettreChiffreLettreChiffreLettreChiffre (ex: H7N5H9 ou h7n5h9) Identifiez les codes d’employés composés de :\nDeux lettres majuscules suivies de quatre chiffres. Comptez les lignes ne se terminant pas par une lettre :\nIdentifier les numéros de téléphone aux formats : (xxx)xxx-xxxx ou +1(xxx)xxx-xxxx.\nTrouver les URLs comme :\nhttp://www.domaine.tld ou http://www.domaine.tld/ https://www.domaine.tld ou https://www.domaine.tld/ NB : domaine et tld représentent n’importe quel vrai domaine (ex: google) et n’importe quel sous-dommaine (.com, .ca, .qc.ca, etc.)\nRechercher des adresses e-mail valides. Elles contiennent : des lettres majuscules ou minuscules, des chiffres et possiblement un ou plusieurs ‘_’ (tiret bas) et un ou plusieurs ‘.’ . Ensuite il y a forcément un ‘@’ puis d’autres caractères (lettres majuscules ou minuscules, chiffres, ‘.’, tiret bas ‘_’) Ensuite il y a obligatoirement un ‘.’ puis pour finir, Entre 2 et 6 lettres minuscules (.qc.ca) et Possiblement un ‘.’ à la fin Dans le fichier /etc/services, à l’aide d’expressions régulières:\nTrouver les lignes contenant “ssh” sans espace après.\nCompter les lignes totales et celles non vides.\nTrouver les lignes contenant udp ou tcp avec un numéro à trois chiffres. NB: Affichez le contenu du fichier services situé dans le répertoire /etc pour voir comment se présente l’information et créer la bonne expression régulière.\nRechercher les mots de quatre lettres entourés d’espaces.\nIdentifier les mots avec exactement deux “a” (consécutifs ou non).\nDans le fichier /etc/passwd, à l’aide d’expressions régulières:\na) Avec une première commande, comptez le nombre de lignes du fichier /etc/passwd. b) Avec une deuxième commande, assurez-vous ensuite que toutes les lignes contiennent deux nombres successifs, chacun valant de 0 à n (nombre entier de plusieurs chiffres) et entouré de “:”. c) Comptez le nombre de lignes obtenues et assurez-vous qu’il est égal au nombre précédent.\nCompter les nombre d’utilisateurs qui n’ont pas le shell bash. Rappel: Dans le fichier /etc/passwd, chaque ligne correspond à un utilisateur.",
    "description": "Objectif de l’atelier Maîtriser les bases des expressions régulières. Renforcer la capacité à manipuler des fichiers texte. Renforcer la précision dans la recherche et le filtrage de données. Atelier Important\rUtiliser le fichier expr.txt se trouvant sur Moodle. Faites un copier-coller du contenu du fichier expr.txt dans un nouveau fichier texte. Utiliser uniquement les commandes, les symboles et la matière vue dans le cours (semaines 1 à 6) RegExp: Tableaux récapitulatifs Dans le fichier expr.txt, à l’aide d’expressions régulières:",
    "tags": [],
    "title": "ATELIER #6: Les expressions régulières",
    "uri": "/semaine6/atelier/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "Plan de la leçon Théorie : Lundi 24 mars\nUtilisation avancée de VIM (vimtutor fr). Les principes de certains fichiers de configuration Linux. DNF et CRON semaine 8 Atelier 7: FACULTATIF (pas de remise).\nInstallation d’outils. Utilisation de VIM. Manipulation de fichiers de configuration. Atelier 8: Jeudi 27 mars.\nInstaller des utilitaires et des applications avec dnf. Planifier et automatiser des tâches sur Linux.",
    "description": "Plan de la leçon Théorie : Lundi 24 mars\nUtilisation avancée de VIM (vimtutor fr). Les principes de certains fichiers de configuration Linux. DNF et CRON semaine 8 Atelier 7: FACULTATIF (pas de remise).\nInstallation d’outils. Utilisation de VIM. Manipulation de fichiers de configuration. Atelier 8: Jeudi 27 mars.\nInstaller des utilitaires et des applications avec dnf. Planifier et automatiser des tâches sur Linux.",
    "tags": [],
    "title": "Vim, les fichiers de configuration",
    "uri": "/semaine7/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Vim, les fichiers de configuration",
    "content": "L’éditeur de texte VIM Dans les systèmes Linux, la majorité des configurations s’effectuent à l’aide de fichiers texte.\nPour modifier ces fichiers texte, nous utiliserons l’éditeur de texte vim. c’est un éditeur puissant avec de nombreux avantages :\nDisponible sur tous les systèmes basés sur UNIX, Très léger, idéal pour les systèmes sans interface graphique, Fonctionne en local ou à distance. Apprendre à utiliser vim est indispensable pour travailler efficacement sous Linux.\nTutoriels Tutoriel directement sur VIM Vidéo YouTube Apprendre tout sur Vim\nLes principaux modes de VIM vim propose 3 modes principaux pour travailler :\nMode normal (par défaut) : Interprète les touches comme des commandes (ex. copier, supprimer, naviguer). Utilisez la touche Échap (ESC) pour revenir à ce mode à tout moment. Mode visuel : Permet de sélectionner du texte. Activez-le avec : v : pour sélectionner des caractères, V : pour sélectionner des lignes entières. Mode insertion : Permet d’ajouter ou modifier du texte. Activez-le avec : i : insérer à l’endroit du curseur, a : insérer après le curseur, I : insérer au début de la ligne, A : insérer à la fin de la ligne. Navigation dans vim Voici les principales commandes pour se déplacer rapidement :\nAction Commande Un caractère à gauche h Un caractère à droite l Une ligne en bas j Une ligne en haut k Un mot à droite w Un mot à gauche b Début de la ligne 0 Fin de la ligne $ Aller à une ligne précise :numéro (ex. :100) Astuce\rVous pouvez ajouter un quantificateur pour répéter une commande. Exemple : 3w pour avancer de 3 mots, 50j pour descendre de 50 lignes.\nCommandes de base 1. Copier (commande y pour yank)\nÀ copier Commande Une ligne yy Jusqu’à la fin du mot yw Trois lignes 3yy 2. Coller (commande p ou P)\nAction Commande Coller après p minuscule Coller avant P majuscule Exemples avec Copier et Coller\nAction Commande Copier 3 mots y3w Coller 3 fois 3p 3. Modifier du texte\nAction Commande Remplacer un caractère r + (caractère) Remplacer plusieurs caractères R (mode remplacement, taper jusqu’à Échap) 4. Annuler et répéter\nAction Commande Annuler u (undo) Répéter la dernière commande . (point) 5. Supprimer du texte (couper)\na) Supprimer un caractère\nAction Commande Sous le curseur x minuscule Avant le curseur X majuscule b) Autres suppressions\nTexte à supprimer Commande Une ligne dd Jusqu’à la fin du mot dw Jusqu’à la fin de la ligne d$ Fichiers de configuration Linux Sous Linux, les fichiers texte sont utilisés pour gérer la configuration des systèmes. Voici les fichiers les plus courants.\nRéseau Fichier Rôle Exemple /etc/resolv.conf Configure les serveurs DNS nameserver 8.8.8.8 nameserver 8.8.4.4 /etc/hosts Associe des noms de machine à des adresses IP 192.168.1.1 serveur1 Personnalisation du shell Fichier Rôle Exemple ~/.bashrc Permet de créer des alias pour simplifier les commandes alias lh=\"ls -lh\" Autres fichiers utiles Fichier Rôle /etc/selinux/config Configure SELinux (sécurité). /etc/passwd et /etc/group Gèrent les utilisateurs et groupes. /etc/locale.conf Définit la langue du système. /etc/fstab Configure le montage des partitions. /etc/httpd/conf/httpd.conf Configure le serveur Apache. /etc/grub2.cfg Configure le gestionnaire de démarrage.",
    "description": "L’éditeur de texte VIM Dans les systèmes Linux, la majorité des configurations s’effectuent à l’aide de fichiers texte.\nPour modifier ces fichiers texte, nous utiliserons l’éditeur de texte vim. c’est un éditeur puissant avec de nombreux avantages :\nDisponible sur tous les systèmes basés sur UNIX, Très léger, idéal pour les systèmes sans interface graphique, Fonctionne en local ou à distance. Apprendre à utiliser vim est indispensable pour travailler efficacement sous Linux.",
    "tags": [],
    "title": "Vim et les fichiers de configuration",
    "uri": "/semaine7/cours/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Vim, les fichiers de configuration",
    "content": "Objectif de l’atelier Approfondir l’utilisation de VIM pour modifier des fichiers de configuration Linux de manière efficace. Modifier des fichiers de configuration Linux efficacement : Utiliser un minimum de touches. Ne pas utiliser la souris. Compléter les exercices : 10 exercices de type A (le curseur est déjà placé). 5 exercices de type B (le curseur commence au début du fichier). Instructions de remise Fournissez les captures d’écran des exercices réussis via Moodle.\nChaque capture doit montrer :\nLa modification effectuée. Le fichier sauvegardé dans l’état final. Exemple de capture attendue :\nUne vidéo de démonstration est disponible :\nAtelier Préparation Installation des outils Créez un fichier vim.sh avec le contenu suivant :\n#!/bin/bash wget https://linuxh25.netlify.app/semaine7/atelier/vimrc.dot || echo ERREUR mv vimrc.dot ~/.vimrc sudo yum install -y epel-release sudo yum install -y meld sudo yum groupinstall -y \"Development Tools\" sudo yum install -y git automake mkdir ~/tmp cd ~/tmp git clone https://github.com/kernc/logkeys.git cd logkeys ./autogen.sh cd build ../configure make sudo make install || echo ERREUR\rExécutez le script pour installer les outils requis :\n$ bash vim.sh\rTéléchargement des exercices Dans votre répertoire personnel (cd ~), exécutez les commandes suivantes :\n$ cd ~ $ wget https://linuxh25.netlify.app/semaine7/atelier/atelier_07.tar.gz || echo ERREUR $ tar zxvf atelier_07.tar.gz $ cd atelier_07\rExercices de type A (curseur déjà placé) IMPORTANT\rNe pas éditer directement les vrais fichiers de configuration. Editer plutôt la copie qui se trouve dans le dossier atelier_07 téléchargé\nExercice a01 Fichier de configuration /etc/default/grub\nModification à apporter Avant :\nGRUB_CMDLINE_LINUX=\"rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet\"\rAprès :\nGRUB_CMDLINE_LINUX=\"rd.lvm.lv=centos/root rd.lvm.lv=centos/swap quiet\"\rSupprimez rhgb pour désactiver le démarrage graphique.\nPerformances attendues Record à battre Maximum acceptable 4 touches 9 touches Commandes pour lancer l’exercice $ sh afficher_objectif.sh a01 $ sh exercice_vim.sh a01\rExercice a02 Fichier de configuration /etc/selinux/config\nModification à apporter Avant :\nSELINUX=enforcing\rAprès :\nSELINUX=disabled\rDésactivez SELinux.\nPerformances attendues Record à battre Maximum acceptable 7 touches 25 touches Commandes pour lancer l’exercice $ sh afficher_objectif.sh a02 $ sh exercice_vim.sh a02\rExercice a03 Fichier de configuration /etc/fstab\nListe des partitions utilisées dans le système Par défaut, chaque partition est montée au démarrage Modification à apporter AVANT :\n/dev/mapper/centos-tmp /tmp xfs defaults 0 0\rAPRÈS :\nEn retirant une ligne, on efface la définition d’une partition Le répertoire /tmp devient un sous-répertoire de / (partition centos-root) Nombre de touches Record à battre Maximum acceptable 4 touches 6 touches Pour visualiser avec meld et lancer l’exercice $ sh afficher_objectif.sh a03 $ sh exercice_vim.sh a03\rExercice a04 Fichier de configuration /etc/locale.conf\nRégionalisation du système: langue, date, etc. Modification à apporter AVANT :\nLC_TIME=\"\"\rAPRÈS :\nLC_TIME=\"fr_CA.UTF-8\"\rOn veut copier fr_CA.UTF-8 entre les \" afin de définir aussi le format de date. Nombre de touches Record à battre Maximum acceptable 8 touches 18 touches Pour visualiser avec meld et lancer l’exercice $ sh afficher_objectif.sh a04 $ sh exercice_vim.sh a04\rExercice a05 Fichier de configuration /etc/mime.types\nDéfinition des types de fichier et de leur extensions NOTE : la commande file affiche le type d’un fichier Modification à apporter AVANT :\napplication/3gpp-ims+xml application/activemessage application/andrew-inset\rAPRÈS :\napplication/3gpp-ims+xml\tinconnu application/activemessage\tinconnu application/andrew-inset\tinconnu\rOn ajoute l’extension inconnu pour les trois premiers types de fichier NOTE : il y a trois tabulations entre le type et l’extension Nombre de touches Record à battre Maximum acceptable 18 touches 40 touches Pour visualiser avec meld et lancer l’exercice $ sh afficher_objectif.sh a05 $ sh exercice_vim.sh a05\rExercice a06 Fichier de configuration /etc/hosts\nAssocie un nom réseau à son adresse Pour ces noms, le système ne fera pas de requête DNS NOTE : ce fichier existe aussi sous Windows Modification à apporter AVANT :\n206.167.24.30 ciboulot.ca #172.17.0.30 ciboulot.ca APRÈS :\n#206.167.24.30 ciboulot.ca 172.17.0.30 ciboulot.ca\rOn met en commentaire l’adresse publique de ciboulot.ca On active l’adresse locale (seulement valide au Collège) Nombre de touches Record à battre Maximum acceptable 6 touches 12 touches Pour visualiser avec meld et lancer l’exercice $ sh afficher_objectif.sh a06 $ sh exercice_vim.sh a06\rExercice a07 Fichier de configuration /etc/firewalld/direct.xml\nRègles de pare-feu directes (écrites à la main). NOTE : l’autre option est de générer les règles via la commande firewall-cmd. Modification à apporter AVANT :\n\u003crule priority=\"0\" table=\"filter\" ipv=\"ipv4\" chain=\"FORWARD\"\u003e-i PRIVE -o PUBLIC -j ACCEPT\u003c/rule\u003e \u003crule priority=\"0\" table=\"filter\" ipv=\"ipv4\" chain=\"FORWARD\"\u003e-i PUBLIC -o PRIVE -m state --state RELATED,ESTABLISHED -j ACCEPT\u003c/rule\u003e \u003crule priority=\"0\" table=\"nat\" ipv=\"ipv4\" chain=\"POSTROUTING\"\u003e-o PUBLIC -j MASQUERADE\u003c/rule\u003e\rAPRÈS :\n\u003crule priority=\"0\" table=\"filter\" ipv=\"ipv4\" chain=\"FORWARD\"\u003e-i 192.168.1.4 -o 10.33.50.3 -j ACCEPT\u003c/rule\u003e \u003crule priority=\"0\" table=\"filter\" ipv=\"ipv4\" chain=\"FORWARD\"\u003e-i 10.33.50.3 -o 192.168.1.4 -m state --state RELATED,ESTABLISHED -j ACCEPT\u003c/rule\u003e \u003crule priority=\"0\" table=\"nat\" ipv=\"ipv4\" chain=\"POSTROUTING\"\u003e-o 10.33.50.3 -j MASQUERADE\u003c/rule\u003e\rOn insère des vraies adresses IP à partir d’un patron. NOTE : ces règles indiquent au système de faire du NAT. Nombre de touches Record à battre Maximum acceptable 37 touches 120 touches Pour visualiser avec meld et lancer l’exercice sh afficher_objectif.sh a07 sh exercice_vim.sh a07\rExercice a08 Fichier de configuration ~/.bashrc\nPersonnalisation du SHELL. Fichier lu à chaque ouverture du SHELL. Modification à apporter AVANT : (Fichier initial vide ou sans alias spécifique)\nAPRÈS :\nalias la=\"ls -a\"\rOn ajoute la ligne pour créer un alias. NOTE : un alias est un raccourci pour une commande fréquemment utilisée. Nombre de touches Record à battre Maximum acceptable 12 touches 22 touches Pour visualiser avec meld et lancer l’exercice sh afficher_objectif.sh a08 sh exercice_vim.sh a08\rExercice a09 Fichier de configuration /etc/resolv.conf\nDéfinit le ou les serveurs DNS à utiliser. Modification à apporter AVANT :\nnameserver 10.33.50.1\rAPRÈS :\nnameserver 192.168.1.1\rOn change l’adresse DNS à 192.168.1.1. Nombre de touches Record à battre Maximum acceptable 14 touches 35 touches Pour visualiser avec meld et lancer l’exercice sh afficher_objectif.sh a09 sh exercice_vim.sh a09\rExercice a10 Fichier de configuration /etc/ssh/sshd_config\nConfiguration du serveur SSH. Modification à apporter AVANT :\n#X11Forwarding yes\rAPRÈS :\nX11Forwarding yes\rCertaines options sont déjà inscrites dans le fichier. Pour les activer, il suffit de les décommenter. Ici, on active la redirection graphique. Nombre de touches Record à battre Maximum acceptable 3 touches 8 touches Pour visualiser avec meld et lancer l’exercice sh afficher_objectif.sh a10 sh exercice_vim.sh a10\rExercices de type B (curseur au début du fichier) IMPORTANT\rNe pas éditer directement les vrais fichiers de configuration.\nExercice b01 Fichier de configuration /etc/ssh/sshd_config\nConfiguration du serveur SSH Modification à apporter AVANT :\n#X11Forwarding yes APRÈS :\nX11Forwarding yes\rMême modification que a10, sauf que cette fois-ci le curseur n’est pas déjà placé Nombre de touches Record à battre Maximum acceptable 7 touches 18 touches Pour visualiser avec meld et lancer l’exercice $ sh afficher_objectif b01 $ sh exercice_vim.sh b01\rExercice b02 Fichier de configuration /etc/default/grub\nConfiguration de grub (outil de démarrage) En particulier : options à donner au noyau Linux au démarrage Modification à apporter AVANT :\nGRUB_CMDLINE_LINUX=\"rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet\"\rAPRÈS :\nGRUB_CMDLINE_LINUX=\"rd.lvm.lv=centos/root rd.lvm.lv=centos/swap quiet\"\rMême modification que a01, sauf que le curseur n’est pas déjà placé Nombre de touches Record à battre Maximum acceptable 8 touches 20 touches Pour visualiser avec meld et lancer l’exercice $ sh afficher_objectif b02 $ sh exercice_vim.sh b02\rExercice b03 Fichier de configuration /etc/services\nListe des services réseau, protocoles et ports Modification à apporter AVANT :\nsystat 11/tcp users systat 11/udp users daytime 13/tcp daytime 13/udp qotd 17/tcp quote qotd 17/udp quote msp 18/tcp # message send protocol (historic) msp 18/udp # message send protocol (historic) chargen 19/tcp ttytst source chargen 19/udp ttytst source ftp-data 20/tcp\rAPRÈS :\nEffacer les services du port 11 jusqu’au port 20 (inclusif) Nombre de touches Record à battre Maximum acceptable 11 touches 28 touches Pour visualiser avec meld et lancer l’exercice $ sh afficher_objectif b03 $ sh exercice_vim.sh b03\rExercice b04 Fichier de configuration /etc/passwd\nInformation sur les usagers Linux Modification à apporter AVANT :\ngnome-initial-setup:x:984:977::/run/gnome-initial-setup/:/sbin/nologin tcpdump:x:72:72::/:/sbin/nologin avahi:x:70:70:Avahi mDNS/DNS-SD Stack:/var/run/avahi-daemon:/sbin/nologin apache:x:48:48:Apache:/usr/share/httpd:/sbin/nologin\rAPRÈS :\nOn efface les 4 dernières lignes NOTE : habituellement, ces lignes sont effacées par la commande userdel Nombre de touches Record à battre Maximum acceptable 6 touches 15 touches Pour visualiser avec meld et lancer l’exercice $ sh afficher_objectif b04 $ sh exercice_vim.sh b04\rExercice b05 Fichier de configuration /etc/group\nListe des groupes d’usagers Linux Chaque usager est membre de son propre groupe Un usager membre d’un autre groupe obtient des droits supplémentaires Modification à apporter AVANT :\nwheel:x:10:\rAPRÈS :\nwheel:x:10:mbergeron\rOn ajoute l’usager mbergeron au groupe wheel Le groupe wheel est le groupe qui peut faire la commande sudo Nombre de touches Record à battre Maximum acceptable 10 touches 25 touches Pour visualiser avec meld et lancer l’exercice $ sh afficher_objectif b05 $ sh exercice_vim.sh b05",
    "description": "Objectif de l’atelier Approfondir l’utilisation de VIM pour modifier des fichiers de configuration Linux de manière efficace. Modifier des fichiers de configuration Linux efficacement : Utiliser un minimum de touches. Ne pas utiliser la souris. Compléter les exercices : 10 exercices de type A (le curseur est déjà placé). 5 exercices de type B (le curseur commence au début du fichier). Instructions de remise Fournissez les captures d’écran des exercices réussis via Moodle.",
    "tags": [],
    "title": "ATELIER #7: VIM et les fichiers de configuration",
    "uri": "/semaine7/atelier/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e DNF et CRON",
    "content": "Planification des tâches avec cron Cron est un outil qui permet de planifier et d’automatiser des tâches sur un système Linux. Chaque utilisateur peut définir ses propres tâches planifiées.\nPoints essentiels : Les tâches planifiées par un utilisateur sont stockées dans le fichier :\n/var/spool/cron/\u003cuser\u003e Le démon responsable de l’exécution des tâches planifiées s’appelle : crond On peut planifier des tâches complexes grâce aux nombreuses options disponibles. Commandes de base pour gérer les tâches planifiées Afficher la liste des tâches planifiées :\ncrontab -l\rSupprimer toutes les tâches planifiées :\ncrontab -r\rModifier les tâches d’un autre utilisateur (nécessite les droits root) :\ncrontab -u \u003cutilisateur\u003e\rImporter un fichier contenant des tâches planifiées :\ncrontab \u003cfichier\u003e\r⚠️ Chaque import écrase toutes les tâches existantes.\nModifier ou créer des tâches (commande la plus courante) :\ncrontab -e\rSyntaxe d’une tâche cron Une tâche dans une crontab se compose de deux parties :\nLa planification : Décrit quand la tâche doit s’exécuter (5 champs). La commande ou script à exécuter : Peut être une commande bash. Recommandation : utilisez un script, spécifié avec son chemin absolu. Exemple d’une crontab :\n15 * * * * bash /home/user/monscript.sh 30 0 * * * bash /usr/local/bin/autrescript.sh 0 * * * * echo \"Nouvelle heure\" \u003e\u003e /home/user/heure.txt\rLes erreurs de syntaxe dans le fichier crontab sont détectées au moment de l’enregistrement. Si une tâche génère des erreurs lors de l’exécution, elles sont enregistrées dans :\n/var/mail/\u003cuser\u003e\nComprendre la planification La planification utilise 5 champs :\nMinutes Heures Jour du mois Mois Jour de la semaine 0-59 0-23 1-31 1-12 0-7 (dimanche à dimanche) Symboles utiles * : Tous les moments possibles (ex. : toutes les heures). , : Énumération de valeurs (ex. : 1,5,6). - : Intervalle de valeurs (ex. : 1-10). */n : Sauts réguliers (ex. : */2 toutes les 2 heures). Exemples de planifications Tous les jours à 14h30 : 30 14 * * * bash /chemin/script.sh\rChaque heure (25ème minute) en mars uniquement : 25 * * 3 * bash /chemin/script.sh\rLundi, mercredi et vendredi à midi : 0 12 * * 1,3,5 bash /chemin/script.sh\rGestion des paquets avec dnf DNF est un gestionnaire de paquets pour les systèmes basés sur Red Hat (comme AlmaLinux). Il simplifie :\nL’installation. La mise à jour. La suppression de logiciels. Contrairement à l’installation manuelle ou avec des fichiers RPM, dnf gère automatiquement les dépendances.\nCommandes de base Rechercher un paquet Rechercher un paquet par nom ou description :\ndnf search \u003cmot-clé\u003e\rVérifier si un fichier ou commande fait partie d’un paquet :\ndnf provides \u003cfichier/commande\u003e\rInstallation d’un paquet Pour installer un paquet :\nsudo dnf install \u003cnom_du_paquet\u003e\rMettre à jour un paquet ou tout le système Mettre à jour un paquet spécifique : sudo dnf update \u003cnom_du_paquet\u003e\rMettre à jour tous les paquets installés : sudo dnf update\rSupprimer un paquet Pour désinstaller un paquet :\nsudo dnf remove \u003cnom_du_paquet\u003e\rGestion des dépôts Les dépôts sont des serveurs qui contiennent des paquets. Ils sont configurés dans :\n/etc/yum.repos.d\nCommandes utiles Lister les dépôts actifs : dnf repolist\rLister tous les dépôts (actifs ou non) : dnf repolist all\rAjouter un nouveau dépôt Par exemple, pour ajouter le dépôt remi :\nsudo dnf install -y https://rpms.remirepo.net/enterprise/remi-release-9.rpm\rGestion des groupes de paquets Certaines applications ou environnements sont regroupés en groupes pour simplifier leur gestion.\nCommandes importantes Lister les groupes disponibles :\ndnf grouplist\rInstaller un groupe :\nExemple pour installer l’environnement Xfce :\nsudo dnf groupinstall \"Xfce\"\rObtenir des informations sur un groupe :\ndnf groupinfo \"\u003cnom_du_groupe\u003e\"\rAutomatisation avec le shell dnf Le shell dnf permet d’exécuter plusieurs commandes à la suite.\nCréer un fichier avec les commandes (ex. : installations.txt) :\ninstall nmap install zsh run\rExécuter le fichier avec dnf :\ndnf shell installations.txt",
    "description": "Planification des tâches avec cron Cron est un outil qui permet de planifier et d’automatiser des tâches sur un système Linux. Chaque utilisateur peut définir ses propres tâches planifiées.\nPoints essentiels : Les tâches planifiées par un utilisateur sont stockées dans le fichier :\n/var/spool/cron/\u003cuser\u003e Le démon responsable de l’exécution des tâches planifiées s’appelle : crond On peut planifier des tâches complexes grâce aux nombreuses options disponibles. Commandes de base pour gérer les tâches planifiées Afficher la liste des tâches planifiées :",
    "tags": [],
    "title": "CRON et DNF",
    "uri": "/semaine8/cours/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "Plan de la leçon Théorie/Test :\nValidation de l’atelier #10 Atelier :\nInstallation de WSL et Ubuntu et VS Code",
    "description": "Plan de la leçon Théorie/Test :\nValidation de l’atelier #10 Atelier :\nInstallation de WSL et Ubuntu et VS Code",
    "tags": [],
    "title": "WSL installation et manipulation (Ubuntu, VS Code)",
    "uri": "/semaine14/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e WSL installation et manipulation (Ubuntu, VS Code)",
    "content": "Objectifs de l’atelier Cet atelier a pour but de vous familiariser avec la ligne de commandes en utilisant Ubuntu comme distribution Linux.\nFormat de la remise Attention\rPour chacune des étapes des parties 2 et 3 vous devrez prendre une capture d’écran de vos commandes et résultats. ATTENTION: On doit pouvoir voir votre nom d’utilisateur. Ne travaillez donc pas avec l’utilisateur root.\nAtelier Partie 1: Installations WSL (Windows Subsystem for Linux) Rechercher les fonctionnalités Windows Dans la liste, cocher Sous-Système Windows pour Linux Redémarrer Une fois redémarré, vous pouvez installer la distribution Ubuntu depuis le Microsoft Store.\nPartie 2: Installation d’Ubuntu WSL prend en charge une variété de distributions Linux, y compris la dernière version LTS d’Ubuntu.\nIl existe plusieurs façons d’installer des distributions sur WSL, nous nous concentrons ici sur la méthode via l’application dans Microsoft Store et les commandes WSL exécutées dans le terminal. Le résultat est le même quelle que soit la méthode.\nApplication dans Microsoft Store\nOuvrir Microsoft Store et trouver la dernière version d’Ubuntu. Cliquez sur Free/Gratuit, puis sur Get/Obtenir. Patienter durant l’installation. Ubuntu sera alors installé sur votre machine.\nAvant de commencer, s’assurer qu’Ubuntu est à jour:\n$ sudo apt update\rPrenez une capture d’écran de la fenêtre de la commande avec le résultat et nommez-la 1.png. NOTE: La commande sudo permet d’exécuter une commande en tant qu’administrateur du système.\nUne fois installé, vous pouvez soit lancer l’application directement depuis le Microsoft Store, soit rechercher Ubuntu dans votre barre de recherche Windows.\nPrenez une capture d’écran de la fenêtre de terminal Ubuntu et nommez-la 2.png. References:\nSite Ubuntu WSL Vidéo YouTube",
    "description": "Objectifs de l’atelier Cet atelier a pour but de vous familiariser avec la ligne de commandes en utilisant Ubuntu comme distribution Linux.\nFormat de la remise Attention\rPour chacune des étapes des parties 2 et 3 vous devrez prendre une capture d’écran de vos commandes et résultats. ATTENTION: On doit pouvoir voir votre nom d’utilisateur. Ne travaillez donc pas avec l’utilisateur root.\nAtelier Partie 1: Installations WSL (Windows Subsystem for Linux) Rechercher les fonctionnalités Windows",
    "tags": [],
    "title": "ATELIER #10: WSL, Ubuntu et des commandes Linux simples",
    "uri": "/semaine14/atelier/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e AidesVMs",
    "content": "Ces étapes vous permettront de , texte et images entre votre machine hôte et la VM en utilisant le glisser déposer. Notez que certaines restrictions peuvent s’appliquer selon la configuration de votre environnement VMware.\nPour pouvoir transférer des fichiers, dossiers entre votre machine hôte et une machine virtuelle sous VMware, suivez ces étapes :\nInstaller VMware Tools :\nAssurez-vous que VMware Tools est installé sur la VM. Cette suite d’utilitaires améliore les performances et offre des fonctionnalités comme le glisser déposer. Pour l’installer : Ouvrez VMware Workstation. Sélectionnez votre VM et cliquez sur Lecteur \u003e Gérer \u003e Installer VMware Tools. Suivez les instructions à l’écran pour finaliser l’installation, puis redémarrez la VM. Activer le glisser déposer :\nAprès avoir installé VMware Tools : Allez dans Lecteur \u003e Gérer \u003e Paramètres de la machine virtuelle. Dans l’onglet Options, sélectionnez Isolation des invités. Cochez les cases Activer le glisser déposer et Activer le copier-coller. Cliquez sur OK pour enregistrer les modifications. Redémarrer la VM :\nPour que les modifications prennent effet, redémarrez la machine virtuelle. Références IT Connect informatiweb thewindowsclub.blog techsyncer",
    "description": "Ces étapes vous permettront de , texte et images entre votre machine hôte et la VM en utilisant le glisser déposer. Notez que certaines restrictions peuvent s’appliquer selon la configuration de votre environnement VMware.\nPour pouvoir transférer des fichiers, dossiers entre votre machine hôte et une machine virtuelle sous VMware, suivez ces étapes :\nInstaller VMware Tools :\nAssurez-vous que VMware Tools est installé sur la VM. Cette suite d’utilitaires améliore les performances et offre des fonctionnalités comme le glisser déposer. Pour l’installer : Ouvrez VMware Workstation. Sélectionnez votre VM et cliquez sur Lecteur \u003e Gérer \u003e Installer VMware Tools. Suivez les instructions à l’écran pour finaliser l’installation, puis redémarrez la VM. Activer le glisser déposer :",
    "tags": [],
    "title": "Activer le glisser déposer entre votre VM et votre SSD ?",
    "uri": "/aidesvm/vmwaretools/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Solutions: ateliers et tests",
    "uri": "/solutions/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Solutions: ateliers et tests",
    "content": "Capture d’écran prouvant la réussite de l’installation d’AlmaLinux sur VMware.\nLa capture d’écran doit montrer\nLa fenêtre du Terminal. Votre nom d’utilisateur standard. Votre nom complet écrit sur la ligne de commande. Exemple:",
    "description": "Capture d’écran prouvant la réussite de l’installation d’AlmaLinux sur VMware.\nLa capture d’écran doit montrer\nLa fenêtre du Terminal. Votre nom d’utilisateur standard. Votre nom complet écrit sur la ligne de commande. Exemple:",
    "tags": [],
    "title": "Atelier 1",
    "uri": "/solutions/semaine1/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Solutions: ateliers et tests",
    "content": "Critères de correction appliqués Question Points -100% -75% -50% -25% Réponses 1 3 cd absent cd ../../home/user\ncd root cd /home/user cd /home ~ cd /~ cd ~ 2 2 mkdir absente autre commande mkdir /home/user/projets/python/scripts mkdir projets/python/scripts mkdir -p /home/user/projets/python/scripts mkdir -p projets/python/scripts 3 2 sudo seul Flèche Mauvaise commande (ex: history -!100) history !sudo !sudo sud tab 4 2 Mauvais caractère générique find -name pas assez de ? 8 ? ls log?????.txt ls-l log?????.txt 5 2 Mauvaise commande\nBoucle touch rapport_20{00,01,02, …, 25}.txt mkdir rapport_{2000..2025} touch /rapport_20{00..25}\ntouch rapport_20{00..25} Toutes les années\nExtension manquante touch rapport_{2000..2025}.txt touch rapport_20{00..25}.txt 6 2 Mauvaise syntaxe de la boucle Mauvaise commande (ex : rmdir) Mauvais chemin\npas reutiliser la variable for i in /home/user/Documents/*.bak; do rm “$i”; done 7 2 Commande et chemin erronés (ex: cd ../../var/log) Mauvais chemin relatif (ex: ls ../../var/log) Mauvaise commande et bon chemin (ex: cd /var/log) ls /var/log ls -l /var/log 8 2 Commande et chemin erronés Chemin relatif erroné\nMauvaise commande (ex: mv) cd /home/user/Documents/projets/developpement/scripts\ncd /developpement/scripts cd developpement cd developpement/scripts 9 2 Option manquante\nMauvaise commande head -15 data.csv head -n 15 data.csv head data.csv -n 15\nhead -15 data.csv\nhead 15 data.csv 10 2 Mauvaise commande tail -n 10 data.csv tail 10 data.csv tail data.csv 11 2 Mauvaise commande history !-2 history !49\nhistory 49\n!2 !-2\n!49 !48 12 2 Absence de boucle\nSyntaxe de la boucle Mauvaise extension\nMauvais chemin\nMauvaise commande for i in *.log; do echo $i; done 13 2 sudo absent et mauvaise commande/chemin sudo absent + rm + chemin sudo présent + chemin, mais mauvaise commande (ex : rmdir) sudo rm /etc/secret.conf 14 4 Mauvaise commande ls *.log *.txt .csv\nls -name {.log, *.txt, *.csv} ls *.{log,txt,csv}\nls *{.log,.txt,.csv} 15 3 Mauvaise commande (ex : mv) syntaxe erronée syntaxe cp inversée\nToutes les années\ncopy backup_{2000 .. 2025}.tar /mnt/archives/\nExtension manquante cp backup_{2000..2025}.tar /mnt/archives cp backup_20{00..25}.tar /mnt/archives cp backup_{2000..2025}.{b,t}ar /mnt/archives 16 2 Mauvaise commande seulement la commande Tous les noms Extension manquante Nombres impairs mv config-{2,4,6,8,10}.txt configs/ 17 2 Pas de commande\nMauvaise commande (ex : ls) Mauvais chemin\nCommande find sans l’option -name find /home/user/scripts -name “*.sh” 18 2 Commande autre que systemctl, init Absence d’isolate Utilisation de runlevel (init)\nMauvaise cible systemctl isolate multi-user.target\nsystemctl isolate multi-user 19 5 Aucune des 2 réponses sont bonnes 1 seule des 2 réponses est bonne 1. systemctl multi-user.target: requiert un redémarrage. 2. systemctl isolate multi-user.target : ne requiert pas de redémarrage 20 5 Aucune des 2 réponses sont bonnes 1 seule des 2 réponses est bonne 1. touch tests/test{1..5}.log 2. ls tests TOTAL 50 Rappels des notions de base importantes non réussies Syntaxe de base d’une commande dans l’ordre\ncommande -option arguments\rcommande : action à exécuter. option : modifie le comportement de la commande. Généralement commence par le symbole - (moins). arguments : cible sur laquelle la commande s’applique. Peut être un chemin vers un fichier/répertoire, un texte, un nombre, etc. Chemin relatif vs absolu\nUn chemin absolu commence toujours par /. Les caractère / correspond à la racine de l’arborescence de Linux voir cours semaine 2. Un chemin relatif NE COMMENCE PAS par /. Dépendamment de où on se trouve, un chemin relatif commencera soit par: le nom (chemin) du répertoire/fichier à atteindre. Un ou plusieurs ../ pour remonter dans l’arborescence. La commande cd\ncd ➝ Change Directory, se déplacer dans l’arborescence de fichiers/repertoires de Linux. Difference entre find et ls\nls → Affiche le contenu d’un répertoire donné. find → Recherche des fichiers/dossiers selon des critères (nom, taille, date, etc.), même dans les sous-dossiers. Exemple concret :\nLister tous les fichiers .txt dans le répertoire courant :\nls *.txt\r➝ Ne fonctionne que pour le répertoire actuel.\nTrouver tous les fichiers .txt dans tous les sous-dossiers :\nfind . -name \"*.txt\"\r➝ Recherche dans le dossier actuel et tous ses sous-dossiers.\nLes commandes touch et mkdir\ntouch ➝ création de fichiers mkdir ➝ création de répertoires (directory) L’option -p permet de créer les sous répertoires Boucle for\nLa syntaxe:\nfor variable in liste do commande done\rvariable : la variable qui prendra successivement les valeurs de liste. liste : une séquence de valeurs (peut être une liste explicite, une plage de nombres, une liste de fichiers, etc.). commande : l’instruction exécutée à chaque itération. Exemples:\nfor fruit in pommes bananes oranges\t# Pas de virgule entre les arguments do echo \"J'aime les $fruit\"\t# $fruit = affiche le nom du fruit traité done\r🡪 Affiche\nJ'aime les pommes\rJ'aime les bananes\rJ'aime les oranges\rfor fichier in *.txt do echo \"Traitement de $fichier\" done\r🡪 Affiche les noms des fichiers .txt dans le dossier courant.\nNB: Si la liste représente un chemin vers un fichier/répertoire, cela ne veut pas dire qu’on est dedans, mais que la variable aura comme valeur les fichiers/répertoires un à un.\nEx: $(find /home/user/Documents -name \"*.bak\") cherche tous les répertoires dont le nom contient Documents et non les fichiers contenant .bak.\nL’expansion d’accolades { }\nRôle de isolate dans la commande systemctl\nDans systemctl, la commande isolate sert à basculer immédiatement vers une cible (target) sans avoir à redémarrer le système. isolate ne redémarre pas la machine, mais change l’environnement d’exécution.",
    "description": "Critères de correction appliqués Question Points -100% -75% -50% -25% Réponses 1 3 cd absent cd ../../home/user\ncd root cd /home/user cd /home ~ cd /~ cd ~ 2 2 mkdir absente autre commande mkdir /home/user/projets/python/scripts mkdir projets/python/scripts mkdir -p /home/user/projets/python/scripts mkdir -p projets/python/scripts 3 2 sudo seul Flèche Mauvaise commande (ex: history -!100) history !sudo !sudo sud tab 4 2 Mauvais caractère générique find -name pas assez de ? 8 ? ls log?????.txt ls-l log?????.txt 5 2 Mauvaise commande\nBoucle touch rapport_20{00,01,02, …, 25}.txt mkdir rapport_{2000..2025} touch /rapport_20{00..25}\ntouch rapport_20{00..25} Toutes les années\nExtension manquante touch rapport_{2000..2025}.txt touch rapport_20{00..25}.txt 6 2 Mauvaise syntaxe de la boucle Mauvaise commande (ex : rmdir) Mauvais chemin\npas reutiliser la variable for i in /home/user/Documents/*.bak; do rm “$i”; done 7 2 Commande et chemin erronés (ex: cd ../../var/log) Mauvais chemin relatif (ex: ls ../../var/log) Mauvaise commande et bon chemin (ex: cd /var/log) ls /var/log ls -l /var/log 8 2 Commande et chemin erronés Chemin relatif erroné\nMauvaise commande (ex: mv) cd /home/user/Documents/projets/developpement/scripts\ncd /developpement/scripts cd developpement cd developpement/scripts 9 2 Option manquante\nMauvaise commande head -15 data.csv head -n 15 data.csv head data.csv -n 15\nhead -15 data.csv\nhead 15 data.csv 10 2 Mauvaise commande tail -n 10 data.csv tail 10 data.csv tail data.csv 11 2 Mauvaise commande history !-2 history !49\nhistory 49\n!2 !-2\n!49 !48 12 2 Absence de boucle\nSyntaxe de la boucle Mauvaise extension\nMauvais chemin\nMauvaise commande for i in *.log; do echo $i; done 13 2 sudo absent et mauvaise commande/chemin sudo absent + rm + chemin sudo présent + chemin, mais mauvaise commande (ex : rmdir) sudo rm /etc/secret.conf 14 4 Mauvaise commande ls *.log *.txt .csv\nls -name {.log, *.txt, *.csv} ls *.{log,txt,csv}\nls *{.log,.txt,.csv} 15 3 Mauvaise commande (ex : mv) syntaxe erronée syntaxe cp inversée\nToutes les années\ncopy backup_{2000 .. 2025}.tar /mnt/archives/\nExtension manquante cp backup_{2000..2025}.tar /mnt/archives cp backup_20{00..25}.tar /mnt/archives cp backup_{2000..2025}.{b,t}ar /mnt/archives 16 2 Mauvaise commande seulement la commande Tous les noms Extension manquante Nombres impairs mv config-{2,4,6,8,10}.txt configs/ 17 2 Pas de commande\nMauvaise commande (ex : ls) Mauvais chemin\nCommande find sans l’option -name find /home/user/scripts -name “*.sh” 18 2 Commande autre que systemctl, init Absence d’isolate Utilisation de runlevel (init)\nMauvaise cible systemctl isolate multi-user.target\nsystemctl isolate multi-user 19 5 Aucune des 2 réponses sont bonnes 1 seule des 2 réponses est bonne 1. systemctl multi-user.target: requiert un redémarrage. 2. systemctl isolate multi-user.target : ne requiert pas de redémarrage 20 5 Aucune des 2 réponses sont bonnes 1 seule des 2 réponses est bonne 1. touch tests/test{1..5}.log 2. ls tests TOTAL 50 Rappels des notions de base importantes non réussies Syntaxe de base d’une commande dans l’ordre",
    "tags": [],
    "title": "Test 1",
    "uri": "/solutions/test1/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Solutions: ateliers et tests",
    "content": "Solution des exercices Exercice 1 : Explorer l’arborescence Linux Afficher le chemin de votre répertoire courant :\n$ pwd\rAller dans /usr/share/doc et vérifier le chemin :\n$ cd /usr/share/doc $ pwd\rRemonter dans le répertoire parent :\n$ cd .. $ pwd\rRetourner dans le répertoire personnel :\n$ cd ~ $ pwd\rLister les fichiers présents dans le répertoire courant :\n$ ls\rLister les fichiers du répertoire /usr :\n$ ls /usr\rExercice 2 : Commandes Linux simples Afficher la date et l’heure actuelles :\n$ date $ date +\"%r\"\rAfficher les 10 premières lignes de /etc/services :\n$ head /etc/services\rAfficher les 10 dernières lignes de /etc/services :\n$ tail /etc/services\rRépéter la commande précédente en trois frappes :\n$ tail /etc/services # (Utilisez la flèche \"haut\" pour la rappeler)\rAfficher les 20 dernières lignes :\n$ tail -n 20 /etc/services\rRéutiliser l’historique pour afficher l’heure :\n$ history $ !\u003cnuméro de la commande date +\"%r\"\u003e\rExercice 3 : Commandes de base Créer le répertoire Atelier2 :\n$ mkdir Atelier2\rCopier le fichier fichier.txt dans Atelier2 :\n$ cp fichier.txt Atelier2/\rCréer le répertoire Rep2 :\n$ mkdir Rep2\rDéplacer Atelier2 dans Rep2 :\n$ mv Atelier2 Rep2/\rSe déplacer dans Atelier2 :\n$ cd Rep2/Atelier2\rModifier fichier.txt avec vim :\n$ vim fichier.txt\r(Écrire votre nom complet, enregistrer et quitter avec :wq).\nAfficher le contenu de fichier.txt :\n$ cat fichier.txt\rCréer fichier2.txt :\n$ touch fichier2.txt\rAfficher le contenu des deux fichiers avec cat :\n$ cat fichier.txt fichier2.txt\rRevenir dans le répertoire personnel :\n$ cd ~\rSupprimer le répertoire Rep2 :\n$ rm -r Rep2\rAfficher le répertoire courant :\n$ pwd\rCréer Rep3 dans /root :\n$ mkdir /root/Rep3\r(Peut échouer sans sudo).\nLister le contenu de /etc avec -l :\n$ ls -l /etc\rIdentifier les caractères au début des lignes : (Réponse : d pour répertoire, - pour fichier, l pour lien symbolique).\nDifférence de /proc : (Réponse : Contient des fichiers virtuels donc éphémères, représentant des informations sur le système).\nDifférence entre /bin et /sbin : (Réponse : /bin contient des binaires pour tous les utilisateurs, /sbin est réservé à l’administration).\nRépertoire du noyau : (Réponse : /boot).\nRépertoire pour une clé USB : (Réponse : /media ou /mnt).\nRépertoire pour Apache : (Réponse : /etc/apache2 ou /etc/httpd, selon la distribution).",
    "description": "Solution des exercices Exercice 1 : Explorer l’arborescence Linux Afficher le chemin de votre répertoire courant :\n$ pwd\rAller dans /usr/share/doc et vérifier le chemin :\n$ cd /usr/share/doc $ pwd\rRemonter dans le répertoire parent :\n$ cd .. $ pwd\rRetourner dans le répertoire personnel :\n$ cd ~ $ pwd\rLister les fichiers présents dans le répertoire courant :\n$ ls\rLister les fichiers du répertoire /usr :",
    "tags": [],
    "title": "Atelier 2",
    "uri": "/solutions/semaine2/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Solutions: ateliers et tests",
    "content": "Solution des exercices Exercice 1 : Niveaux d’exécution Modifier le niveau d’exécution par défaut de votre machine virtuelle (VM) pour passer en mode multi-utilisateurs sans interface graphique. $ systemctl set-default multi-user\rRedémarrer la VM pour appliquer les changements à l’aide de la commande shutdown -r now. $ shutdown -r now\rou\n$ systemctl reboot\rAprès le redémarrage, se connecter à votre VM . Vérifier que l’interface graphique ne démarre pas. Si au redémarrage vous êtes en mode graphique…\rCela signifie qu’à la question #1, vous n’avez pas changé le mode par défaut (permanent), mais vous avez changé temporairement le mode en utilisant isolate. Le système étant configuré pour démarrer en mode graphique (graphical.target) par défaut, c’est lui qui reprend au redémarrage.\nUtiliser une commande systemctl pour connaître le niveau d’exécution actuel.\n$ systemctl get-default\rPourquoi get-default ?\rSi le default.target est différent du target réellement actif, cela signifie que le système fonctionne temporairement sous un autre niveau (par exemple, après une modification manuelle avec systemctl isolate ou en raison d’un problème au démarrage).\nou\n$ who -r\rou\n$ runlevel\rRétablir le mode graphique par défaut. N’oubliez pas de redémarrer la VM pour que les changements soient pris en compte. $ systemctl set-default graphical\rExercice 2 : Caractères génériques et commande find Aller dans le répertoire /etc. Notez qu’il est demandé de ne pas se déplacer pour le reste de cet exercice. $ cd /etc\rUtiliser la commande find pour rechercher les fichiers dont le nom commence par la lettre r dans le répertoire courant. $ find . -name \"r*\"\rUtiliser la commande find pour rechercher les fichiers contenant la chaîne rc dans le répertoire courant. $ find . -name \"*rc*\"\rUtiliser la commande find pour rechercher les fichiers dont le nom comporte exactement trois caractères sur l’ensemble du système de fichiers (à partir de la racine). $ find / -name \"???\"\rExercice 3 : Expansion d’accolades et boucle for Important\rAssurez-vous d’être revenu dans votre répertoire personnel avant de commencer cet exercice.\n$ cd ~\rUtiliser l’expansion d’accolades pour créer l’arborescence de dossiers suivante en une seule commande. $ mkdir -p coursLinux/semaine{1..5}/l{econ,ab}\rou\n$ mkdir -p coursLinux/semaine{1..5}/{lecon,lab}\rou\n$ mkdir -p coursLinux/semaine{1..5}/lab coursLinux/semaine{1..5}/lecon $ tree coursLinux\rToujours en utilisant l’expansion d’accolades, créer un fichier vide nommé priseNote dans chaque répertoire lab en une seule commande. $ touch coursLinux/semaine{1..5}/lab/priseNote\rUtiliser une boucle for pour renommer tous les fichiers priseNote en priseNote.txt. $ for i in coursLinux/semaine{1..5}/lab/priseNote; do mv \"$i\" \"$i.txt\"; done\rUtiliser une boucle for pour déplacer les fichiers priseNote.txt des répertoires lab vers les répertoires lecon correspondants. $ for i in coursLinux/semaine{1..5}; do mv $i/lab/priseNote.txt $i/lecon; done ou\n$ for i in {1..5}; do mv ./coursLinux/semaine$i/lab/priseNote.txt ./coursLinux/semaine$i/lecon;done",
    "description": "Solution des exercices Exercice 1 : Niveaux d’exécution Modifier le niveau d’exécution par défaut de votre machine virtuelle (VM) pour passer en mode multi-utilisateurs sans interface graphique. $ systemctl set-default multi-user\rRedémarrer la VM pour appliquer les changements à l’aide de la commande shutdown -r now. $ shutdown -r now\rou\n$ systemctl reboot\rAprès le redémarrage, se connecter à votre VM . Vérifier que l’interface graphique ne démarre pas. Si au redémarrage vous êtes en mode graphique…\rCela signifie qu’à la question #1, vous n’avez pas changé le mode par défaut (permanent), mais vous avez changé temporairement le mode en utilisant isolate. Le système étant configuré pour démarrer en mode graphique (graphical.target) par défaut, c’est lui qui reprend au redémarrage.",
    "tags": [],
    "title": "Atelier 3",
    "uri": "/solutions/semaine3/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Solutions: ateliers et tests",
    "content": "Solution des exercices Exercice 1 Ouvrir une session avec l’utilisateur standard et reproduire, dans le répertoire courant, l’arborescence suivante et ce en utilisant un maximum de trois commandes : ├── H2025\r│ ├── Linux\r│ │ ├── Cours\r│ │ └── Ateliers\r│ └── Virtualisation\r│ └── machines\r└── Icones Solution 1 : Une seule commande mkdir -p $ mkdir -p H2025/{Linux/{Cours,Ateliers},Virtualisation/machines} Icones\rAvantages : Très concise, une seule commande.\nInconvénients : Moins lisible si l’arborescence est complexe.\nSolution 2 : Trois commandes mkdir séparées $ mkdir -p H2025/Linux H2025/Virtualisation Icones $ mkdir -p H2025/Linux/Cours H2025/Linux/Ateliers $ mkdir -p H2025/Virtualisation/machines\rAvantages : Plus lisible, chaque commande crée une partie logique de l’arborescence.\nInconvénients : Utilise trois commandes, soit le maximum autorisé.\nChanger de répertoire en allant dans le dossier Cours. $ cd H2025/Linux/Cours\rEn saisissant une seule commande, créer, à l’intérieur du répertoire courant, les dossiers semaine1, semaine2, …, semaine15. Vous ne devez pas entrer tous les noms de semaines dans la commande (hint: expansion d’accolades). $ mkdir semaine{1..15}\rÀ l’aide d’une boucle for, à l’intérieur de chaque dossier semaine, créer un fichier .txt qui contient la phrase suivante : Ce cours concerne la semaineN Où N correspond au numéro de la semaine.\n$ for i in {1..15}; do echo \"Ce cours concerne la semaine$i\" \u003e semaine$i/semaine$i.txt; done\rExplication :\nfor i in {1..15} : Crée une boucle qui itère de 1 à 15. echo “Ce cours concerne la semaine$i” : Génère la phrase avec le numéro de la semaine. \u003e semaine$i/semaine$i.txt : Crée un fichier semaine$i.txt dans le dossier semaine$i et y écrit la phrase. └── Cours\r├── semaine1\r│ └── semaine1.txt\r├── semaine10\r│ └── semaine10.txt\r├── semaine11\r│ └── semaine11.txt\rToujours à partir du répertoire courant, utiliser un chemin relatif pour copier dans le dossier Ateliers le fichier passwd qui est dans /etc. $ cp ../../../../../etc/passwd ../Ateliers/\r├── Ateliers\r│ └── passwd\r└── Cours\r├── semaine1\r│ └── semaine1.txt\r├── semaine10\r│ └── semaine10.txt\rToujours à partir du répertoire courant et en utilisant un chemin relatif, renommer le fichier copié en ajoutant “Copie” à son nom (passwdCopie). $ mv ../Ateliers/passwd ../Ateliers/passwdCopie\r├── Ateliers\r│ └── passwdCopie\r└── Cours\r├── semaine1\r│ └── semaine1.txt\r├── semaine10\r│ └── semaine10.txt\rChanger toutes les occurrences du caractère délimiteur : (deux points) du fichier passwdCopie par ; (point-virgule). $ sed -i 's/:/;/g' ../Ateliers/passwdCopie\rExplication :\nsed : Outil pour modifier un fichier en ligne. -i : Modifie le fichier en place (sans créer de fichier temporaire). s/:/;/g : Remplace tous les : par des ; (g pour global, c’est-à-dire dans tout le fichier). ../Ateliers/passwdCopie : Le fichier à modifier, situé dans le dossier Ateliers. Trier le contenu du fichier passwdCopie en ordre croissant du numéro de groupe, soit le quatrième champ. On veut que le fichier soit trié et non uniquement le résultat retourné par la commande. $ sort -t ';' -k4n ../Ateliers/passwdCopie -o ../Ateliers/passwdCopie\rExplication :\nsort : Outil pour trier le contenu d’un fichier. -t ';' : Définit le délimiteur comme étant le point-virgule (;). -k4n : Trie les lignes en fonction du quatrième champ qui est numérique. -o ../Ateliers/passwdCopie : Sauvegarde directement le résultat trié dans le même fichier passwdCopie. Exercice 2 Revenir dans votre dossier personnel.\n$ cd ~\rÉcrire la commande qui permet de compter le nombre d’utilisateurs qui ont pour shell le /bin/bash. Vous trouverez cette information dans le fichier /etc/passwd. $ echo \"$(grep -c '/bin/bash' /etc/passwd) utilisateurs ont pour shell /bin/bash\"\rExplication :\ngrep -c '/bin/bash' /etc/passwd : Cherche toutes les lignes contenant /bin/bash dans le fichier /etc/passwd et renvoie le nombre de correspondances (l’option -c compte les lignes). echo \"$( ... )\" : Affiche le résultat avec le texte personnalisé. Le nombre d’utilisateurs est inséré dans le message. Maintenant on veut écrire la ligne de commande qui permet d’afficher le nombre d’utilisateurs qui ont pour shell par défaut un des shells disponibles sur votre machine. Pour cela, il faut parcourir le fichier /etc/shells ligne par ligne (hint: boucle). Vous y trouverez les shells disponibles. while read shell; do cpt=$(grep -c \"^.*:$shell\" /etc/passwd) echo \"$cpt utilisateurs ont pour shell $shell\" done \u003c /etc/shells\rExplication :\nwhile read shell; do : Lit chaque ligne du fichier /etc/shells et stocke la valeur dans shell. grep -c \"^.*:$shell\" /etc/passwd : Compte le nombre de lignes dans /etc/passwd où le champ shell correspond. done \u003c /etc/shells : Indique que la boucle doit lire les entrées de /etc/shells. Autre solution :\ncat /etc/shells | while read i; do echo \"$(cat /etc/passwd | grep $i | wc -l) utilisateurs ont pour shell $i\"; done\rcat /etc/shells\n→ Affiche le contenu du fichier /etc/shells (liste des shells disponibles sur le système). | while read i; do ... done\n→ Lit chaque ligne du fichier /etc/shells et stocke la valeur dans la variable i. cat /etc/passwd | grep $i | wc -l cat /etc/passwd : Affiche le contenu du fichier /etc/passwd (liste des utilisateurs avec leur shell). grep $i : Filtre les lignes contenant le shell i. wc -l : Compte le nombre de lignes correspondantes (donc le nombre d’utilisateurs utilisant ce shell). echo \"$( ... ) utilisateurs ont pour shell $i\" L’utilisation de cat avant grep est inutile et moins efficace que la solution précédente.\nExercice 3 En une seule ligne de commande, on veut savoir combien de fichiers et dossiers contient le répertoire courant. $ echo \"Le répertoire `basename $PWD` contient $(find . ! -path . | wc -l) fichiers et dossiers\"\rExplication :\nfind . ! -path . → Recherche tout dans le répertoire courant, sauf . (le dossier courant lui-même). wc -l → Compte le nombre d’éléments trouvés. basename $PWD → Affiche uniquement le nom du répertoire courant. echo → Formate le message de sortie. En une seule ligne de commande, on veut savoir combien de fichiers standards contient le répertoire courant. Le résultat doit être affiché comme suit : $ echo \"Le répertoire $(pwd) contient $(ls -l | grep ^- | wc -l) fichiers standard\";\rEn une seule ligne de commande, on veut savoir combien d’éléments ne sont ni des dossiers ni des fichiers standards dans le répertoire courant. $ echo \"Le répertoire $(pwd) contient $(ls -l | grep -v ^d | grep -v ^- | wc -l) fichiers qui ne sont ni des fichiers standards ni des répertoires\"\rÉcrire une commande qui récupère le nom du dernier utilisateur qui a été créé sur votre machine (c’est celui qu’on retrouve à la dernière ligne du fichier /etc/passwd). Le résultat doit être stocké dans une variable nommée nomUtilisateur. $ nomUtilisateur=$(tail -n 1 /etc/passwd | cut -d: -f1)\rExplication :\ntail -n 1 /etc/passwd → Récupère la dernière ligne du fichier /etc/passwd, qui contient les informations du dernier utilisateur créé. cut -d: -f1 → Coupe la ligne en utilisant : comme délimiteur et extrait le premier champ, qui correspond au nom de l’utilisateur. En utilisant la variable nomdurépertoire qui contient le nom du dernier utilisateur défini dans /etc/passwd, écrivez une commande permettant de : Rechercher tous les fichiers à partir de /home (find) Lister leurs détails avec ls -l Filtrer uniquement les fichiers appartenant à cet utilisateur. Filtrer uniquement les fichiers standards. La commande doit être une seule ligne en utilisant un pipe (|) et une boucle while read. $ find /home -type f -user \"$nomUtilisateur\" 2\u003e/dev/null | while read fichier; do ls -ld \"$fichier\"; done\rExplication :\nfind / -type f -user \"$nomUtilisateur\" 2\u003e/dev/null\nfind /home → Recherche dans tout le répertoire /home et ses sous dossiers. -type f → Filtre pour ne garder que les fichiers standards (exclut les dossiers et autres types de fichiers). -user \"$nomUtilisateur\" → Sélectionne uniquement les fichiers appartenant à l’utilisateur défini dans la variable nomUtilisateur. 2\u003e/dev/null → Supprime les messages d’erreur liés aux permissions pour éviter qu’elles s’affichent. | while read fichier; do ls -ld \"$fichier\"; done\nLit chaque fichier trouvé, stockant chaque chemin de fichier dans la variable fichier. Utilise ls -ld pour afficher les détails du fichier (-l pour le format détaillé, -d pour éviter de suivre les liens symboliques). Autre solution non optimale\nfind /home -name \"$user\" 2\u003e/dev/null |while read i; do ls -ld $i ; done |grep ^- Exercice 4 En tant qu’utilisateur standard, on veut trouver tous les fichiers .txt sur votre disque dur (ne pas utiliser sudo). Écrire la commande qui permet de retrouver cette information sans afficher les erreurs. $ find / -type f -name \"*.txt\" 2\u003e/dev/null\rExplication :\nfind / → Recherche à partir de la racine du système. -type f → Filtre pour ne garder que les fichiers standards. -name \"*.txt\" → Cherche uniquement les fichiers avec l’extension .txt. 2\u003e/dev/null → Redirige les erreurs (par exemple, permissions refusées) vers /dev/null, les rendant invisibles. Récupérer la sortie standard de la commande précédente et à partir de son résultat, lire chaque ligne et à l’aide de la commande ls, afficher la taille de ces fichiers suivi du chemin vers les fichiers.(en une seule commande sans utiliser de variable). $ find / -type f -name \"*.txt\" 2\u003e/dev/null | while read fichier; do ls -l \"$fichier\" | tr -s ' ' | cut -d' ' -f5,9-; done\rExplication :\nfind / -type f -name \"*.txt\" 2\u003e/dev/null\nRecherche tous les fichiers .txt accessibles. Ignore les erreurs de permission. | while read fichier; do ls -l \"$fichier\" | tr -s ' ' | cut -d' ' -f5,9-; done\nLit chaque fichier trouvé. ls -l \"$fichier\" affiche les détails du fichier. tr -s ' ' compresse les espaces multiples en un seul espace pour éviter les décalages dans cut. cut -d' ' -f5,9- extrait : -f5 → La taille du fichier (5ᵉ champ). -f9- → Extrait le chemin du fichier (le nom commence au 9ᵉ champ). Récupérer la sortie standard de la commande précédente et trier le résultat par ordre croissant de taille. (en une seule commande sans utiliser de variable). $ find / -type f -name \"*.txt\" 2\u003e/dev/null | while read fichier; do ls -l \"$fichier\" | tr -s ' ' | cut -d' ' -f5,9-; done | sort -n\rExplication :\n| sort -n Trie les résultats par ordre croissant de taille (sort -n pour tri numérique). Autres solutions\n$ find / -name \"*.txt\" 2\u003e/dev/null| while read i; do du -sh $i; done | sort -h\rExplication\nwhile read i → Lit chaque ligne de la sortie de find, stockant chaque chemin de fichier dans i. du -sh $i → du (Disk Usage) mesure la taille du fichier. s → Affiche uniquement la taille totale du fichier, sans détails supplémentaires. h → Formate la taille en unités lisibles (K, M, G). sort -h → Trie les fichiers par taille, en interprétant correctement les suffixes (K, M, G). Sans -h, le tri serait incorrect pour des valeurs comme 512K et 1.2M (car sort classerait alphabétiquement). $ find / -name \"*.txt\" 2\u003e/dev/null | while read fichier; do ls -lh $fichier; done |sort -t' ' -k5h\rExplication\nls -lh $fichier → Affiche les détails du fichier (ls -l), mais avec -h pour afficher la taille dans un format lisible (Ko, Mo, Go).",
    "description": "Solution des exercices Exercice 1 Ouvrir une session avec l’utilisateur standard et reproduire, dans le répertoire courant, l’arborescence suivante et ce en utilisant un maximum de trois commandes : ├── H2025\r│ ├── Linux\r│ │ ├── Cours\r│ │ └── Ateliers\r│ └── Virtualisation\r│ └── machines\r└── Icones Solution 1 : Une seule commande mkdir -p $ mkdir -p H2025/{Linux/{Cours,Ateliers},Virtualisation/machines} Icones\rAvantages : Très concise, une seule commande.\nInconvénients : Moins lisible si l’arborescence est complexe.",
    "tags": [],
    "title": "Atelier 4",
    "uri": "/solutions/semaine4/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Solutions: ateliers et tests",
    "content": "Solution des exercices Exercice 1 : nombre_de_fichiers_seq.sh` Solution 1 #!/bin/bash # Définition des types de fichiers à analyser types=\"java conf txt png tiff\" echo \"Décompte des fichiers $types\" echo \"\" # Boucle sur chaque type de fichier for i in $types do nb=$(find / -name \"*.$i\" 2\u003e/dev/null | wc -l) test $nb -eq 0 \u0026\u0026 echo \"Il n'y a aucun fichier .$i\" || echo \"Il y a $nb fichiers .$i\" done\rSolution 2 #!/bin/bash # Définition des types de fichiers à analyser types=\"java conf txt png tiff\" echo \"Décompte des fichiers $types\" echo \"\" # Boucle sur chaque type de fichier for type in $types; do # Compter le nombre de fichiers avec l'extension donnée nombre=$(find . -type f -name \"*.$type\" | wc -l) # Affichage du résultat en utilisant des expressions arithmétiques echo \"Il y a $nombre fichiers .$type\" | sed 's/ 0 fichiers/ aucun fichier/' done\rExercice 2 : nombre_de_fichiers_conc.sh Solution 1 # Définition des types de fichiers à analyser types=\"java conf txt png tiff\" echo \"Décompte des fichiers $types\" echo \"\" # Boucle sur chaque type de fichier (lancement en arrière-plan avec `\u0026`) for i in $types do (nb=$(find / -name \"*.$i\" 2\u003e/dev/null | wc -l) test $nb -eq 0 \u0026\u0026 echo \"Il n'y a aucun fichier .$i\" || echo \"Il y a $nb fichiers .$i\")\u0026 done # Attendre la fin de tous les processus en arrière-plan wait\rSolution 2 #!/bin/bash # Définition des types de fichiers à analyser types=\"java conf txt png tiff\" echo \"Décompte des fichiers $types\" echo \"\" # Boucle sur chaque type de fichier (lancement en arrière-plan) for type in $types; do ( nombre=$(find . -type f -name \"*.$type\" | wc -l) # Affichage avec substitution via `sed` echo \"Il y a $nombre fichiers .$type\" | sed 's/ 0 fichiers/ aucun fichier/' ) \u0026 done # Attendre la fin de tous les processus en arrière-plan wait\rAttention\rNotez que lors des l’exécution des scripts en parallèle, l’ordre des résultats peut changer d’une exécution à l’autre, ceci montre que les différentes commandes sont bien exécutées de façon asynchrone, totalement indépendantes les unes des autres.",
    "description": "Solution des exercices Exercice 1 : nombre_de_fichiers_seq.sh` Solution 1 #!/bin/bash # Définition des types de fichiers à analyser types=\"java conf txt png tiff\" echo \"Décompte des fichiers $types\" echo \"\" # Boucle sur chaque type de fichier for i in $types do nb=$(find / -name \"*.$i\" 2\u003e/dev/null | wc -l) test $nb -eq 0 \u0026\u0026 echo \"Il n'y a aucun fichier .$i\" || echo \"Il y a $nb fichiers .$i\" done\rSolution 2 #!/bin/bash # Définition des types de fichiers à analyser types=\"java conf txt png tiff\" echo \"Décompte des fichiers $types\" echo \"\" # Boucle sur chaque type de fichier for type in $types; do # Compter le nombre de fichiers avec l'extension donnée nombre=$(find . -type f -name \"*.$type\" | wc -l) # Affichage du résultat en utilisant des expressions arithmétiques echo \"Il y a $nombre fichiers .$type\" | sed 's/ 0 fichiers/ aucun fichier/' done\rExercice 2 : nombre_de_fichiers_conc.sh Solution 1 # Définition des types de fichiers à analyser types=\"java conf txt png tiff\" echo \"Décompte des fichiers $types\" echo \"\" # Boucle sur chaque type de fichier (lancement en arrière-plan avec `\u0026`) for i in $types do (nb=$(find / -name \"*.$i\" 2\u003e/dev/null | wc -l) test $nb -eq 0 \u0026\u0026 echo \"Il n'y a aucun fichier .$i\" || echo \"Il y a $nb fichiers .$i\")\u0026 done # Attendre la fin de tous les processus en arrière-plan wait\rSolution 2 #!/bin/bash # Définition des types de fichiers à analyser types=\"java conf txt png tiff\" echo \"Décompte des fichiers $types\" echo \"\" # Boucle sur chaque type de fichier (lancement en arrière-plan) for type in $types; do ( nombre=$(find . -type f -name \"*.$type\" | wc -l) # Affichage avec substitution via `sed` echo \"Il y a $nombre fichiers .$type\" | sed 's/ 0 fichiers/ aucun fichier/' ) \u0026 done # Attendre la fin de tous les processus en arrière-plan wait\rAttention\rNotez que lors des l’exécution des scripts en parallèle, l’ordre des résultats peut changer d’une exécution à l’autre, ceci montre que les différentes commandes sont bien exécutées de façon asynchrone, totalement indépendantes les unes des autres.",
    "tags": [],
    "title": "Atelier 5",
    "uri": "/solutions/semaine5/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Les expressions régulières \u003e Les expressions régulières",
    "content": "Ces tableaux couvrent les symboles essentiels pour utiliser les expressions régulières !\n1. Opérateurs spéciaux (métacaractères) Symbole Signification Exemple Correspondances . N’importe quel caractère sauf un saut de ligne a.b acb, a1b, a_b ^ Début de ligne ^Hello Hello world (valide), Salut Hello (non valide) $ Fin de ligne end$ C'est la fin [...] Un seul caractère parmi ceux spécifiés [aeiou] a, e, o [^...] Un seul caractère sauf ceux spécifiés [^aeiou] b, c, x (tout sauf voyelles) (xyz) Capture un groupe (abc) abc (capture complète) | OU logique chien|chat chien, chat \\s Un espace blanc (y compris tabulation, retour à la ligne) \\s+ → \" \" [ \\t\\n\\r\\f\\v] \\S Tous sauf un espace blanc (y compris tabulation, retour à la ligne) \\S+ → \"abc\" [^ \\t\\n\\r\\f\\v] (Tout sauf les espaces) 2. Quantificateurs Symbole Signification Exemple Correspondances * 0 ou plusieurs fois ab*c ac, abc, abbc + 1 ou plusieurs fois ab+c abc, abbc mais pas ac ? 0 ou 1 fois (optionnel) colou?r color, colour {n} Exactement n répétitions [0-9]{4} 2025, 1234 {n,} Au moins n fois [0-9]{2,} 12, 456, 7890 {n,m} Entre n et m fois [0-9]{2,4} 12, 123, 4567 3. Séquence d’échappement Symbole Signification Exemples \\ Échappe un métacaractère \\. → correspond à . (point) \\+ → correspond au symbole +, \\$ → correspond au symbole $ etc.",
    "description": "Ces tableaux couvrent les symboles essentiels pour utiliser les expressions régulières !\n1. Opérateurs spéciaux (métacaractères) Symbole Signification Exemple Correspondances . N’importe quel caractère sauf un saut de ligne a.b acb, a1b, a_b ^ Début de ligne ^Hello Hello world (valide), Salut Hello (non valide) $ Fin de ligne end$ C'est la fin [...] Un seul caractère parmi ceux spécifiés [aeiou] a, e, o [^...] Un seul caractère sauf ceux spécifiés [^aeiou] b, c, x (tout sauf voyelles) (xyz) Capture un groupe (abc) abc (capture complète) | OU logique chien|chat chien, chat \\s Un espace blanc (y compris tabulation, retour à la ligne) \\s+ → \" \" [ \\t\\n\\r\\f\\v] \\S Tous sauf un espace blanc (y compris tabulation, retour à la ligne) \\S+ → \"abc\" [^ \\t\\n\\r\\f\\v] (Tout sauf les espaces) 2. Quantificateurs Symbole Signification Exemple Correspondances * 0 ou plusieurs fois ab*c ac, abc, abbc + 1 ou plusieurs fois ab+c abc, abbc mais pas ac ? 0 ou 1 fois (optionnel) colou?r color, colour {n} Exactement n répétitions [0-9]{4} 2025, 1234 {n,} Au moins n fois [0-9]{2,} 12, 456, 7890 {n,m} Entre n et m fois [0-9]{2,4} 12, 123, 4567 3. Séquence d’échappement Symbole Signification Exemples \\ Échappe un métacaractère \\. → correspond à . (point) \\+ → correspond au symbole +, \\$ → correspond au symbole $ etc.",
    "tags": [],
    "title": "Tableaux récapitulatifs des symboles des regexp",
    "uri": "/semaine6/cours/recapitulatif/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "",
    "description": "",
    "tags": [],
    "title": "AidesVMs",
    "uri": "/aidesvm/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/categories/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/tags/index.html"
  }
]
