var relearn_searchindex = [
  {
    "breadcrumb": "",
    "content": "Pondération : 2-2-2\nDescription du cours :\nLinux est le système d’exploitation qui constitue la colonne vertébrale des entreprises les plus puissantes et les plus innovantes au monde. Dès lors, l’étudiante ou l’étudiant sera initié aux principes de base des systèmes d’exploitation libre (Linux) et à l’installation et l’exploitation d’une distribution libre de Linux (p. ex. Fedora, Ubuntu, AlmaLinux, OpenSource).\nPour cela, l’étudiant ou l’étudiante devra exploiter l’interface graphique et la puissance de la ligne de commande pour gérer une station de travail, explorer les systèmes de fichiers et le partitionnement des disques, gérer les processus, l’automatisation des tâches et la programmation de scripts shell.\nObjectifs du cours : Effectuer l’installation et la gestion d’ordinateurs.",
    "description": "Pondération : 2-2-2\nDescription du cours :\nLinux est le système d’exploitation qui constitue la colonne vertébrale des entreprises les plus puissantes et les plus innovantes au monde. Dès lors, l’étudiante ou l’étudiant sera initié aux principes de base des systèmes d’exploitation libre (Linux) et à l’installation et l’exploitation d’une distribution libre de Linux (p. ex. Fedora, Ubuntu, AlmaLinux, OpenSource).",
    "tags": [],
    "title": "420-ZG4-MO Système d’exploitation Linux",
    "uri": "/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "Plan de la leçon Présentation du cours (plan de cours).\nPondération. Objectifs. Contexte d’apprentissage et méthodes pédagogiques. Evaluations formatives. Évaluations sommatives. Politiques institutionnelles (absences, retards, plagiat, etc.). Règlements en classe et hors classe. Théorie :\nGénéralités sur le système d’exploitation Linux. Atelier :\nInstallation de Linux sur une machine virtuelle.",
    "description": "Plan de la leçon Présentation du cours (plan de cours).\nPondération. Objectifs. Contexte d’apprentissage et méthodes pédagogiques. Evaluations formatives. Évaluations sommatives. Politiques institutionnelles (absences, retards, plagiat, etc.). Règlements en classe et hors classe. Théorie :\nGénéralités sur le système d’exploitation Linux. Atelier :\nInstallation de Linux sur une machine virtuelle.",
    "tags": [],
    "title": "Introduction à Linux",
    "uri": "/semaine1/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Introduction à Linux",
    "content": "Qu’est-ce qu’un système d’exploitation? Un système d’exploitation (SE) est un logiciel essentiel qui agit comme un intermédiaire entre l’utilisateur et le matériel de l’ordinateur. Il gère les ressources matérielles et logicielles de l’ordinateur et fournit des services communs pour les programmes informatiques. Voici quelques-unes de ses principales fonctions:\nGestion des ressources matérielles: Le système d’exploitation contrôle et coordonne l’utilisation du processeur, de la mémoire, des périphériques de stockage, et des périphériques d’entrée/sortie comme le clavier, la souris et l’écran.\nGestion des fichiers: Il organise les données en fichiers et dossiers, permettant aux utilisateurs de stocker, récupérer et manipuler des informations de manière efficace.\nGestion des processus: Le système d’exploitation gère l’exécution des programmes, en allouant du temps processeur et en assurant que les tâches s’exécutent sans conflit.\nInterface utilisateur: Il fournit une interface utilisateur, qui peut être en ligne de commande (CLI) ou graphique (GUI), permettant aux utilisateurs d’interagir facilement avec l’ordinateur.\nSécurité et gestion des utilisateurs: Le système d’exploitation protège les données et les ressources de l’ordinateur contre les accès non autorisés et permet la gestion des comptes utilisateurs.\nExemples de systèmes d’exploitation Windows: Développé par Microsoft, c’est l’un des systèmes d’exploitation les plus utilisés dans le monde. macOS: Développé par Apple, il est utilisé sur les ordinateurs Mac. Linux: Un système d’exploitation open-source utilisé principalement par les développeurs et les serveurs. Android: Utilisé principalement sur les smartphones et les tablettes. iOS: Le système d’exploitation d’Apple pour ses appareils mobiles comme l’iPhone et l’iPad. Pourquoi est-ce important? Le système d’exploitation est crucial car il permet à l’utilisateur d’exploiter pleinement les capacités de l’ordinateur sans avoir à gérer directement les complexités matérielles. Il offre une plateforme stable et sécurisée pour exécuter des applications et effectuer des tâches quotidiennes.\nQu’est-ce que Linux ? Définition\rLinux est un système d’exploitation puissant et flexible qui offre de nombreux avantages, notamment en termes de sécurité, de stabilité, et de personnalisation.\nQue ce soit pour un usage personnel, professionnel, ou pour des serveurs, Linux est une option solide et fiable.\nUn peu d’histoire 1991 : Créé par Linus Torvalds et est basé sur le système Unix. 1992 : Le noyau Linux a été re-licencié sous la licence publique générale GNU GPL (GNU’s Not Unix General Public Licence), ce qui a renforcé son statut de logiciel libre. 1994 : La version 1.0 du noyau Linux a été publiée, marquant une étape importante dans son développement. Depuis sa création, Linux est devenu l’un des systèmes d’exploitation les plus populaires, notamment pour les serveurs, les superordinateurs, et les appareils embarqués.\nCaractéristiques principales Open Source : Le code source de Linux est disponible gratuitement, permettant aux utilisateurs de le modifier et de le distribuer. Sécurité : Linux est réputé pour sa robustesse et sa sécurité. Les mises à jour régulières et la communauté active contribuent à maintenir un haut niveau de sécurité. Stabilité : Linux est connu pour sa stabilité et sa capacité à fonctionner pendant de longues périodes sans nécessiter de redémarrage. Personnalisation : Les utilisateurs peuvent personnaliser leur environnement Linux selon leurs besoins, grâce à une multitude de distributions et d’outils disponibles. Distributions Linux Définition\rUne distribution Linux est une version de Linux qui inclut le noyau Linux ainsi que divers logiciels et outils.\nVoici quelques-unes des distributions les plus populaires :\nUbuntu : Connue pour sa convivialité et son support communautaire.\nSite d’Ubuntu Fedora : Souvent utilisée par les développeurs et les administrateurs système.\nSite de Fedora Red Hat : L’une des premières distributions commerciales de Linux. Elle est particulièrement populaire dans les environnements d’entreprise.\nSite de Red Hat Debian : Réputée pour sa stabilité et sa large collection de logiciels.\nsite de Debian Arch Linux : Appréciée par les utilisateurs avancés pour sa flexibilité et sa simplicité.\nSite d’Arch Linux Utilisations de Linux Serveurs : Linux est largement utilisé pour les serveurs web, les serveurs de bases de données, et les serveurs de fichiers en raison de sa fiabilité et de sa sécurité. Superordinateurs : La majorité des superordinateurs dans le monde fonctionnent sous Linux. Appareils embarqués : De nombreux appareils, tels que les routeurs, les téléviseurs intelligents, et les smartphones (via Android), utilisent Linux. Postes de travail : Bien que moins courant que Windows ou macOS, Linux est utilisé par de nombreux développeurs et professionnels de l’informatique pour ses capacités de personnalisation et ses outils puissants. Répartition des SE chez les développeurs Répartition des systèmes d’exploitation pour le développement de logiciels dans le monde de 2018 à 2023\nAvantages Inconvénients Très souvent le même environnement que la machine de production (surtout pour la portion serveur d’une application) Accès très limité aux outils Microsoft : pas de Visual Studio, seulement VS Code et un support minimal pour C# Très facile d’installer des nouveaux outils de développement : $ dnf install nodejs $ dnf install nodejs Une bonne console (ligne de commande) est souvent un bon dépanneur pour un développeur (p.ex. les messages d’erreur sont souvent plus explicites à la ligne de commande que dans l’IDE) Plus facile d’automatiser des tâches de compilation et de tests Systèmes plus légers qui laissent la place aux outils de développement (p.ex. mon Linux prend moins de 1Go de mémoire, alors le reste est pour les outils, VM, etc.). Dans le cours Android p.ex., l’environnement de développement prend 15Go de mémoire (pour l’IDE + deux émulateurs de téléphone). Part de marché des SE pour les serveurs Part de marché des systèmes d’exploitation pour les serveurs",
    "description": "Qu’est-ce qu’un système d’exploitation? Un système d’exploitation (SE) est un logiciel essentiel qui agit comme un intermédiaire entre l’utilisateur et le matériel de l’ordinateur. Il gère les ressources matérielles et logicielles de l’ordinateur et fournit des services communs pour les programmes informatiques. Voici quelques-unes de ses principales fonctions:\nGestion des ressources matérielles: Le système d’exploitation contrôle et coordonne l’utilisation du processeur, de la mémoire, des périphériques de stockage, et des périphériques d’entrée/sortie comme le clavier, la souris et l’écran.",
    "tags": [],
    "title": "Qu'est-ce que Linux ?",
    "uri": "/semaine1/cours/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Introduction à Linux",
    "content": "Objectifs L’atelier a pour but de vous guider à travers le processus d’installation de Linux sur une machine virtuelle (VM). Cela permet d’expérimenter avec Linux sans affecter le système d’exploitation principal de l’ordinateur.\nPrérequis pour l’atelier Avoir Windows 11 installé sur votre disque SSD (sur une seule partition). Télécharger un logiciel de virtualisation tel que VMWare Workstation Pro 17. Télécharger la dernière version d’Almalinux (janvier 2025 c’est la version 9.5). Rappels (Cours ZE5 Virtualisation) VMWare permet d’installer différents systèmes d’exploitation sur une même machine. Le nombre de machines virtuelles (VM) que l’on peut installer dépend de la puissance en terme de CPU et de mémoire de la machine hôte. La machine hôte est celle qui héberge les machines virtuelles aussi appelées les invités. La machine hôte peut être Windows ou Linux et les invités peuvent être une grande variété de systèmes d’exploitation. Format de la remise Attention\rVous devrez prendre des captures d’écran de vos installations. Pour plus de détails, voir les documents ci-dessous:.\nAtelier Étape 1: Réinstallation de Windows Utiliser la procédure obtenue dans le cours 420-ZC5-MO de la session d’automne.\nAttention\rVous devez installer Windows 11 et sur une seule partition.\nÉtape 2: Téléchargement et installation de VMWare sur la machine hôte (votre SSD Windows) Guide - Téléchargement WMWare\nGuide - Installation de VMWare\nÉtape 3: Création d’une VM et installation d’Almalinux Télécharger l’image d’Almalinux Site Almalinux\nNote\rChoisir AlmaLinux OS 9.5 DVD ISO\nVous obtiendrez le fichier AlmaLinux-9.5-x86_64-dvd.iso\nCréer une VM pour y installer Almalinux Guide - Création d’une VM Almalinux",
    "description": "Objectifs L’atelier a pour but de vous guider à travers le processus d’installation de Linux sur une machine virtuelle (VM). Cela permet d’expérimenter avec Linux sans affecter le système d’exploitation principal de l’ordinateur.\nPrérequis pour l’atelier Avoir Windows 11 installé sur votre disque SSD (sur une seule partition). Télécharger un logiciel de virtualisation tel que VMWare Workstation Pro 17. Télécharger la dernière version d’Almalinux (janvier 2025 c’est la version 9.5). Rappels (Cours ZE5 Virtualisation) VMWare permet d’installer différents systèmes d’exploitation sur une même machine. Le nombre de machines virtuelles (VM) que l’on peut installer dépend de la puissance en terme de CPU et de mémoire de la machine hôte. La machine hôte est celle qui héberge les machines virtuelles aussi appelées les invités. La machine hôte peut être Windows ou Linux et les invités peuvent être une grande variété de systèmes d’exploitation. Format de la remise Attention\rVous devrez prendre des captures d’écran de vos installations. Pour plus de détails, voir les documents ci-dessous:.",
    "tags": [],
    "title": "ATELIER #1: Installation de Linux sur une VM",
    "uri": "/semaine1/atelier/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "Plan de la leçon Théorie :\nLe système de fichiers de Linux. Le Shell Bash. La ligne de commandes Les commandes de base Atelier :\nUtilisation des commandes de base",
    "description": "Plan de la leçon Théorie :\nLe système de fichiers de Linux. Le Shell Bash. La ligne de commandes Les commandes de base Atelier :\nUtilisation des commandes de base",
    "tags": [],
    "title": "Système de fichiers, Shell, commandes de base",
    "uri": "/semaine2/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Système de fichiers, Shell, commandes de base",
    "content": "La structure du système de fichiers Linux est hiérarchique et organisée sous la forme d’un arbre inversé, où la racine (root) est représentée par /. Tous les fichiers et répertoires sont situés sous cette racine.\nLa structure du système de fichiers Linux est conçue pour être logique et organisée, facilitant ainsi la gestion et la navigation.\nComprendre cette structure est essentiel pour naviguer et gérer efficacement un système Linux.\nTout est fichier Sous Linux, TOUT les éléments visibles dans l’arborescence du système de fichiers sont des fichiers.\nUn fichier est un fichier Un répertoire est un fichier Une clé USB est un fichier Une partition est un fichier Un disque dur est un fichier etc. Répertoires principaux Important\rChaque répertoire a un rôle spécifique et contient des types de fichiers bien définis.\n/ (Racine) Le point de départ de l’arborescence du système de fichiers. Tous les autres répertoires et fichiers sont situés sous ce répertoire. /bin Contient les binaires essentiels nécessaires au démarrage du système et à l’exécution des commandes de base, comme ls, cp, mv, etc. /boot Contient les fichiers nécessaires au démarrage du système, y compris le noyau Linux et les fichiers de configuration du chargeur de démarrage (bootloader). /dev Contient les fichiers de périphériques. Chaque périphérique matériel (comme les disques durs, les clés USB, etc.) est représenté par un fichier dans ce répertoire. /etc Contient les fichiers de configuration du système. Par exemple, les fichiers de configuration des services, des utilisateurs, des réseaux, etc. /home Contient les répertoires personnels des utilisateurs. Chaque utilisateur a son propre répertoire sous /home, par exemple /home/ndesmangles. /lib Contient les bibliothèques partagées nécessaires pour les binaires situés dans /bin et /sbin. /media Point de montage pour les périphériques amovibles comme les CD-ROM, les clés USB, etc. /mnt Utilisé pour monter temporairement des systèmes de fichiers. Par exemple, pour monter un disque dur externe. /opt Contient les logiciels optionnels et les paquets additionnels qui ne sont pas inclus dans la distribution standard. /proc Système de fichiers virtuel qui contient des informations sur les processus en cours et le système. Par exemple, /proc/cpuinfo contient des informations sur le processeur. /root Répertoire personnel de l’utilisateur root (administrateur du système). /run Contient des informations sur l’état du système depuis le dernier démarrage. Utilisé pour stocker des fichiers temporaires nécessaires au fonctionnement du système. /sbin Contient les binaires essentiels pour l’administration du système, comme fdisk, ifconfig, etc. /srv Contient les données spécifiques aux services fournis par le système. Par exemple, les fichiers de données pour un serveur web peuvent être stockés ici. /tmp Contient les fichiers temporaires créés par les utilisateurs et les applications. Ce répertoire est souvent vidé au redémarrage du système. /usr Contient les applications et les fichiers utilisés par les utilisateurs. Sous-répertoires importants : /usr/bin : Contient les binaires des applications utilisateur. /usr/lib : Contient les bibliothèques partagées pour les applications utilisateur. /usr/local : Contient les logiciels installés localement par l’administrateur du système. /var Contient les fichiers variables, tels que les journaux système, les fichiers de spool, et les fichiers temporaires des applications. Par exemple, /var/log contient les fichiers journaux. Les chemins absolu et relatif Chemin absolu Un chemin absolu est un chemin complet qui commence à la racine du système de fichiers. Il indique l’emplacement exact d’un fichier ou d’un répertoire, peu importe où vous vous trouvez dans le système de fichiers. Par exemple :\n/home/utilisateur/Documents/fichier.txt\rDans cet exemple, le chemin commence par /, qui est la racine du système de fichiers, et suit l’arborescence jusqu’au fichier fichier.txt.\nChemin relatif Un chemin relatif, quant à lui, est un chemin qui est relatif à votre répertoire de travail actuel. Il ne commence pas par /. Par exemple, si vous êtes dans le répertoire /home/utilisateur, et que vous voulez accéder à fichier.txt dans le sous-répertoire Documents, vous pouvez utiliser :\nDocuments/fichier.txt\rOu, si vous voulez remonter d’un niveau dans l’arborescence, vous pouvez utiliser .. pour représenter le répertoire parent. Par exemple, si vous êtes dans /home/utilisateur/Documents et que vous voulez accéder à un fichier dans /home/utilisateur, vous pouvez utiliser :\n../fichier.txt\rEn résumé\nChemin absolu : Commence à la racine / et donne l’emplacement complet. Chemin relatif : Dépend de votre répertoire de travail actuel et ne commence pas par /. Qu’est-ce que le SHELL? Le terme Shell désigne un programme qui interprète les commandes que vous tapez et les exécute. Il existe plusieurs types de shells, comme le Bourne Shell (sh), le C Shell (csh), le Korn Shell (ksh), et bien d’autres.\nLe shell Bash Bash (Bourne Again Shell) est le shell par défaut sur de nombreuses distributions Linux. Il agit comme une interface entre l’utilisateur et le système d’exploitation, permettant d’exécuter des commandes, des scripts, et d’automatiser des tâches.\nFonctionnalités clés de Bash Historique des commandes : Bash conserve un historique des commandes entrées, ce qui permet de les réutiliser facilement. Redirection : Les flux d’entrée et de sortie peuvent être redirigés pour enregistrer des résultats ou chaîner des commandes. Variables : Bash prend en charge les variables, qui peuvent stocker des données pour une utilisation ultérieure. Alias : Vous pouvez créer des alias pour simplifier des commandes longues ou fréquemment utilisées. La ligne de commande La ligne de commande est l’interface où vous tapez vos commandes. Elle est souvent représentée par un symbole $ ou #:\n$ signifie que vous êtes un utilisateur standard # signifie que vous êtes le super-utilisateur root (administrateur du système). ~ signifie le répertoire personnel, les symboles $ et # seront précédés du symbole tilde: ~$ ou ~#. Une commande dans le shell suit généralement cette structure :\ncommande [options] [arguments]\rcommande : Le programme ou l’outil que vous souhaitez exécuter. options : Des paramètres supplémentaires qui modifient le comportement de la commande. arguments : Les cibles sur lesquelles la commande doit agir (fichiers, répertoires, etc.). Lorsque vous êtes prêt à exécuter une commande, appuyez sur la touche Entrée. Tapez chaque commande sur une ligne séparée. Le résultat de la commande est affiché avant l’invite du shell suivante.\nExemple de commande sans option :\n[ndesmangles@localhost ~]$ whoami ndesmangles [ndesmangles@localhost ~]$\rExemple de commande avec une option :\n[ndesmangles@localhost ~]$ date -R Fri, 17 Jan 2025 20:19:50 -0500 [ndesmangles@localhost ~]$\rPour exécuter une commande avec des privilèges de super-utilisateur (root), on la précède de sudo:\n[ndesmangles@localhost ~]$ sudo ls /root\rCommandes de base en Bash Bash propose une variété de commandes puissantes pour interagir avec le système. Ces commandes de base sont essentielles pour naviguer, gérer des fichiers, et interagir avec votre système sous Bash.\nNavigation dans le système de fichiers Commande Description pwd Affiche le chemin absolu du répertoire courant. cd Change le répertoire courant. ls Affiche le contenu d’un répertoire. pwd (Print Working Directory) :\n[ndesmangles@localhost ~]$ pwd /home/ndesmangles\t# Le répertoire personnel dans home [ndesmangles@localhost ~]$ cd (Change Directory) :\n[ndesmangles@localhost ~]$ cd /etc [ndesmangles@localhost etc]$\t# Notez le changement du répertoire courant (etc)\rRemonter d’un niveau. [ndesmangles@localhost etc]$ cd .. [ndesmangles@localhost /]$ # Notez le positionnement à la racine /\rRevenir dans le répertoire etc [ndesmangles@localhost /]$ cd etc [ndesmangles@localhost etc]$ Remonter de deux niveaux. [ndesmangles@localhost etc]$ cd ../.. [ndesmangles@localhost /]$ # Notez le retour à la racine /\rRevenir à notre répertoire personnel [ndesmangles@localhost etc]$ cd ~ [ndesmangles@localhost ~]$ # Notez le retour au répertoire personnel ~\rls (List) :\nOptions utiles :\n-l : Affiche des détails comme les permissions1, la taille, etc. -a : Montre les fichiers cachés. [ndesmangles@localhost /]$ ls afs bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var [ndesmangles@localhost /]$ ls -l total 24 dr-xr-xr-x. 2 root root 6 2 oct 17:00 afs lrwxrwxrwx. 1 root root 7 2 oct 17:00 bin -\u003e usr/bin dr-xr-xr-x. 5 root root 4096 11 jan 23:06 boot\rQuelques explications :\nPremière colonne: -rwxr-xr-x par exemple représente le type de fichier et les droits d’accès (abordés en détail dans un prochain cours) qui lui sont associés. Deuxième colonne : ce qu’elle représente dépend du type de fichier: Répertoire : indique le nombre de sous-répertoires (+2 pour . et ..). Fichier : nombre de lien physiques (vu plus loin dans ce cours). Troisième et quatrième colonnes représentent l’utilisateur propriétaire du fichier et le groupe propriétaire du fichier. Cinquième colonne indique la taille du fichier (notez qu’un répertoire a une taille qui correspond à la taille du fichier répertoire sur le disque). Sixième colonne indique la date de dernière modification. Septième colonne est le nom du fichier. Manipulation de fichiers et répertoires Commande Description touch Crée un fichier vide ou met à jour la date de modification d’un fichier existant. mkdir Crée un nouveau répertoire. rm Supprime des fichiers. Pour supprimer des répertoires, utilisez -r (récursif). rmdir Supprime un répertoire vide. cp Copie des fichiers ou des répertoires. mv Déplace ou renomme des fichiers et des répertoires. touch :\n[ndesmangles@localhost ~]$ touch nouveau_fichier.txt\rmkdir (Make Directory) :\n[ndesmangles@localhost ~]$ mkdir nouveau_repertoire\rrm (Remove) :\n[ndesmangles@localhost ~]$ rm fichier.txt [ndesmangles@localhost ~]$ rm -r dossier_a_supprimer\rrmdir (Remove Directory) :\n[ndesmangles@localhost ~]$ rmdir dossier_vide [ndesmangles@localhost ~]$ rmdir dossier_pas_vide # Affiche une erreur\rcp (Copy) :\n[ndesmangles@localhost ~]$ cp fichier_source.txt fichier_destination.txt [ndesmangles@localhost ~]$ cp -r dossier_source dossier_destination\rmv (Move) :\n[ndesmangles@localhost ~]$ mv ancien_nom.txt nouveau_nom.txt [ndesmangles@localhost ~]$ mv fichier.txt /nouveau/chemin/\rAffichage et lecture de fichiers Commande Description cat Affiche le contenu complet d’un fichier. less Permet de lire un fichier page par page. head Affiche les premières lignes d’un fichier. 10 lignes par défaut. tail Affiche les dernières lignes d’un fichier. 10 lignes par défaut. cat :\n[ndesmangles@localhost ~]$ cat fichier.txt [ndesmangles@localhost ~]$ cat fichier1 fichier2 Hello World!! Introduction aux commandes Linux. [ndesmangles@localhost ~]$ cat /etc/shells\t# Affiche les Shells installés sur la machine.\rless :\nContrôles : Espace : Page suivante q : Quitter [ndesmangles@localhost ~]$ less fichier.txt\rhead :\n[ndesmangles@localhost ~]$ head fichier.txt # Affiche les 10 premières lignes [ndesmangles@localhost ~]$ head -n 5 fichier.txt # Affiche les 5 premières lignes\rtail :\n[ndesmangles@localhost ~]$ tail fichier.txt # Affiche les 10 dernières lignes [ndesmangles@localhost ~]$ tail -n 5 fichier.txt # Affiche les 5 dernières lignes\rInformations système et historique Commande Description date Affiche la date et l’heure actuelles. history Liste les commandes précédemment exécutées. date :\nOptions utiles : + : Pour spécifier un format personnalisé. Formats: %Y : Année complète (ex. 2025). %m : Mois (01-12). %d : Jour (01-31). %H : Heure (00-23). %M : Minutes (00-59). %S : Secondes (00-59). [ndesmangles@localhost ~]$ date Thu Jan 9 20:42:36 EST 2025 [ndesmangles@localhost ~]$ date \"+%Y-%m-%d %H:%M:%S\" 2025-01-09 20:42:43\rhistory :\nOptions utiles : n : Pour spécifier le nombre de commandes précédentes à afficher. ! : Pour exécuter une commande spécifique de l’historique, par son numéro. c : Pour effacer l’historique de la session. [ndesmangles@localhost ~]$ history\t# Affiche l'historique complet de la session. 1 date -R 2 pwd 3 cd /etc 4 cd .. 5 cd etc 6 cd ../.. 7 ls 8 ls -a 9 ls -l 10 date 11 date \"+%Y-%m-%d %H:%M:%S\" 12 cd ~ 13 history [ndesmangles@localhost ~]$ history 5\t# Affiche les 5 dernières commandes effectuées. 10 date 11 date \"+%Y-%m-%d %H:%M:%S\" 12 cd ~ 13 history 14 history 5 [ndesmangles@localhost ~]$ !11\t# Exécute la commande #11 dans l'historique date \"+%Y-%m-%d %H:%M:%S\" 2025-01-09 20:47:03 [ndesmangles@localhost ~]$ !da\t# Exécute la commande la plus récente, dont le nom commence par 'da'. date \"+%Y-%m-%d %H:%M:%S\"\t2025-01-18 20:48:22\t[ndesmangles@localhost ~]$ history -c\t# Efface l'historique. [ndesmangles@localhost ~]$ history 1 history\rBon à savoir\rLa commande clear permet d’effacer l’écran du terminal.\nCommandes utiles Commande Description echo Affiche un message ou une variable dans le terminal. man Affiche le manuel d’aide pour une commande. echo :\n[ndesmangles@localhost ~]$ echo \"Bonjour, monde!\" Bonjour, monde! [ndesmangles@localhost ~]$ echo $SHELL /bin/bash\rNote\r$SHELL doit être écrit en respectant la casse.\rman (Manual) :\n[ndesmangles@localhost ~]$ man ls\t# Affiche le manuel de la commande `ls`.\rStructure d’une page de manuel Une page de manuel typique contient plusieurs sections, telles que :\nNAME : Le nom de la commande et une brève description. SYNOPSIS : La syntaxe de la commande. DESCRIPTION : Une description détaillée de la commande et de ses options. OPTIONS : Les options disponibles pour la commande. EXAMPLES : Des exemples d’utilisation. SEE ALSO : Des références à d’autres commandes ou documents pertinents. Options utiles man -k keyword : Recherche des pages de manuel contenant le mot-clé spécifié. man -f command : Affiche une brève description de la commande (équivalent à whatis command). Autocompletion d’une commande Bash La touche Tab du clavier, permet de compléter rapidement les commandes et les noms de fichiers après avoir entré un nombre de caractères suffisant pour réduire les possibilités à une seule. Si les caractères saisis ne sont pas uniques, appuyez deux fois sur la touche de tabulation pour afficher toutes les commandes correspondantes. [ndesmangles@localhost ~]$ cat /etc/serTab\t# `cat /etc/ser` suivi de la touche `Tab` complète le nom du fichier. [ndesmangles@localhost ~]$ cat /etc/services [ndesmangles@localhost ~]$ passTabTab\t# `pass` suivi de 2 fois la touche `Tab` propose les commande dont le nom commence par `pass`. passt passt.avx2 passwd [ndesmangles@localhost ~]$ pass\rNous étudierons comment gérer les droits des différents utilisateurs plus tard dans ce cours. ↩︎",
    "description": "La structure du système de fichiers Linux est hiérarchique et organisée sous la forme d’un arbre inversé, où la racine (root) est représentée par /. Tous les fichiers et répertoires sont situés sous cette racine.\nLa structure du système de fichiers Linux est conçue pour être logique et organisée, facilitant ainsi la gestion et la navigation.\nComprendre cette structure est essentiel pour naviguer et gérer efficacement un système Linux.",
    "tags": [],
    "title": "Système de fichiers, Shell et commandes de base",
    "uri": "/semaine2/cours/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Système de fichiers, Shell, commandes de base",
    "content": "Objectifs de l’atelier Se familiariser avec la ligne de commandes. Naviguer dans l’arborescence Linux à l’aide de commandes. Gerer des fichiers et répertoires à l’aide de commandes. Format de la remise sur Moodle Attention\rPour chaque exercice, vous devrez prendre une capture d’écran. Sur les captures, on doit pouvoir voir : Votre nom d’utilisateur (Ne travaillez donc pas avec l’utilisateur root, ni la commande sudo). La ligne de commande et la commande. Le résultat de la commande. Si le résultat fait plus de 10 lignes, capturer juste les 10 premières lignes. Nommer les fichiers image, tel qu’indiqué pour chaque question. Remettre toutes vos images dans 1 seul fichier compressé (ex:.zip). Tout autre format ne sera pas corrigé. Pour l’exercice #3, quelques questions devront ètre répondues dans un fichier texte à remettre sur Moodle en plus du .zip. Atelier Préparation Sur votre machine Almalinux, avec votre utilisateur standard, allez sur votre cours sur Moodle, dans la semaine 2. On vous demande de télécharger le fichier fichier.txt. Vous en aurez besoin pour l’exercice #3.\nCliquez sur fichier1. Sur la fenêtre qui s’ouvre, faites un clic droit et choisissez Enregistrez-sous. Le fichier va être enregistré par défaut dans le dossier Téléchargements. Fermer la fenêtre.\nCliquez sur le bouton Activités sur le bureau.\nCliquer sur l’icône Fichiers. Attention\rAvant de commencer chaque exercice, assurez vous que vous travaillez dans votre répertoire personnel et ne vous déplacez pas que lorsque demandé. À moins d’indication contraire, utiliser TOUJOURS des chemins relatifs. Allez maintenant sur votre terminal. Placez-vous dans votre répertoire personnel.\nExercice 1 : Explorer l’arborescence Linux Afficher le chemin de votre répertoire courant. Prendre une capture d’écran et nommez-la 1-1.png. Allez dans le répertoire /usr/share/doc, puis vérifiez le chemin de votre répertoire courant. Prendre une capture d’écran et nommez-la 1-2.png. Remontez dans le répertoire parent. Prendre une capture d’écran et nommez-la 1-3.png. Allez dans votre répertoire personnel. Prendre une capture d’écran et nommez-la 1-4.png. Listez les fichiers présents du répertoire courant. Prendre une capture d’écran et nommez-la 1-5.png. Toujours en étant dans votre dossier personnel, listez les fichiers du répertoire /usr. Prendre une capture d’écran et nommez-la 1-6.png. Exercice 2: Commandes Linux simples Commande date\nAfficher la date et l’heure actuelles du système. Afficher l’heure actuelle sur une horloge de douze heures (par exemple, 11:42:11 AM). Prendre une capture d’écran et nommez-la 2-1.png. Commande head\nAffichez les 10 premières lignes du fichier /etc/services Prendre une capture d’écran et nommez-la 2-2.png. Commande tail\nAffichez les 10 dernières lignes du fichier /etc/services. Prendre une capture d’écran et nommez-la 2-3.png. Commande tail et la flèche vers le haut\nRépéter la commande précédente avec exactement trois frappes de touches. Prendre une capture d’écran et nommez-la 2-4.png. Commande tail et les flèches vers le haut et vers la gauche\nRépéter la commande précédente, mais afficher les 20 dernières lignes du fichier. Prendre une capture d’écran et nommez-la 2-5.png. Commande history\nUtiliser l’historique du shell pour exécuter à nouveau la commande effectuée pour la question #3 (heure sur 12h) Prendre une capture d’écran et nommez-la 2-6.png. Exercice 3: Commandes de base Important\rUtilisez pas l’interface graphique d’Almalinux QUE LORSQUE demandé (#6). Autrement, utilisez uniquement des commandes pour répondre aux questions. Après chaque question (**sauf #6, #12a, #15 à #20), n’oubliez pas de prendre une capture d’écran et de la nommer 3-X.png où X est le numéro de la question. Créer un répertoire Atelier2 dans le répertoire courant. Copier le fichier téléchargé fichier.txt dans le répertoire Atelier2. Créer un autre répertoire nommé Rep2. Déplacer Atelier2 dans Rep2. Déplacez-vous dans Atelier2. Via l’interface d’Almalinux, ouvrir le fichier fichier.txt et écrivez votre nom complet dans le fichier. Enregistrer la modification et fermer le fichier. Afficher le contenu du fichier à l’aide de la commande cat. Créer un autre fichier nommé fichier2.txt dans Atelier2. Avec une seule commande cat afficher le contenu de fichier.txt et fichier2.txt. Revenir dans votre répertoire personnel. Supprimer le répertoire Rep2. a) Dans quel répertoire vous trouvez-vous? b) Utiliser une commande pour voir le répertoire courant. Créer un dossier avec le nom Rep3 dans le dossier /root(en utilisant un chemin absolu). Avez-vous réussi ? Si non, pourquoi ? Afficher le contenu du répertoire /etc en utilisant l’option -l. Par quels caractères, les lignes affichées débutent ? Quelles est leur signification ? Qu’est-ce qui distingue le répertoire /proc des autres répertoires de l’arborescence linux ? Qu’est ce qui distingue le répertoire /bin et /sbin ? Quel est le répertoire qui est utilisé pour charger le noyau du système d’exploitation au démarrage ? Dans Linux, tout est fichier. Si on connecte une clé usb à une machine linux, dans quel répertoire de l’arborescence, on va trouver la référence à cette clé ? Si on installe un serveur web apache sur une machine linux, dans quel répertoire de l’arborescence le dossier contenant les fichiers de configuration du serveur se trouvera-t-il ?",
    "description": "Objectifs de l’atelier Se familiariser avec la ligne de commandes. Naviguer dans l’arborescence Linux à l’aide de commandes. Gerer des fichiers et répertoires à l’aide de commandes. Format de la remise sur Moodle Attention\rPour chaque exercice, vous devrez prendre une capture d’écran. Sur les captures, on doit pouvoir voir : Votre nom d’utilisateur (Ne travaillez donc pas avec l’utilisateur root, ni la commande sudo). La ligne de commande et la commande. Le résultat de la commande. Si le résultat fait plus de 10 lignes, capturer juste les 10 premières lignes. Nommer les fichiers image, tel qu’indiqué pour chaque question. Remettre toutes vos images dans 1 seul fichier compressé (ex:.zip). Tout autre format ne sera pas corrigé. Pour l’exercice #3, quelques questions devront ètre répondues dans un fichier texte à remettre sur Moodle en plus du .zip. Atelier Préparation Sur votre machine Almalinux, avec votre utilisateur standard, allez sur votre cours sur Moodle, dans la semaine 2. On vous demande de télécharger le fichier fichier.txt. Vous en aurez besoin pour l’exercice #3.",
    "tags": [],
    "title": "ATELIER #2: Commandes Linux de base",
    "uri": "/semaine2/atelier/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e WSL installation et manipulation (Ubuntu, VS Code)",
    "content": "Objectifs de l’atelier Cet atelier a pour but de vous familiariser avec la ligne de commandes en utilisant Ubuntu comme distribution Linux.\nFormat de la remise Attention\rPour chacune des étapes des parties 2 et 3 vous devrez prendre une capture d’écran de vos commandes et résultats. ATTENTION: On doit pouvoir voir votre nom d’utilisateur. Ne travaillez donc pas avec l’utilisateur root.\nAtelier Partie 1: Installations WSL (Windows Subsystem for Linux) Rechercher les fonctionnalités Windows Dans la liste, cocher Sous-Système Windows pour Linux Redémarrer Une fois redémarré, vous pouvez installer la distribution Ubuntu depuis le Microsoft Store.\nPartie 2: Installation d’Ubuntu WSL prend en charge une variété de distributions Linux, y compris la dernière version LTS d’Ubuntu.\nIl existe plusieurs façons d’installer des distributions sur WSL, nous nous concentrons ici sur la méthode via l’application dans Microsoft Store et les commandes WSL exécutées dans le terminal. Le résultat est le même quelle que soit la méthode.\nApplication dans Microsoft Store\nOuvrir Microsoft Store et trouver la dernière version d’Ubuntu. Cliquez sur Free/Gratuit, puis sur Get/Obtenir. Patienter durant l’installation. Ubuntu sera alors installé sur votre machine.\nAvant de commencer, s’assurer qu’Ubuntu est à jour:\n$ sudo apt update\rPrenez une capture d’écran de la fenêtre de la commande avec le résultat et nommez-la 1.png. NOTE: La commande sudo permet d’exécuter une commande en tant qu’administrateur du système.\nUne fois installé, vous pouvez soit lancer l’application directement depuis le Microsoft Store, soit rechercher Ubuntu dans votre barre de recherche Windows.\nPrenez une capture d’écran de la fenêtre de terminal Ubuntu et nommez-la 2.png. References:\nSite Ubuntu WSL Vidéo YouTube",
    "description": "Objectifs de l’atelier Cet atelier a pour but de vous familiariser avec la ligne de commandes en utilisant Ubuntu comme distribution Linux.\nFormat de la remise Attention\rPour chacune des étapes des parties 2 et 3 vous devrez prendre une capture d’écran de vos commandes et résultats. ATTENTION: On doit pouvoir voir votre nom d’utilisateur. Ne travaillez donc pas avec l’utilisateur root.\nAtelier Partie 1: Installations WSL (Windows Subsystem for Linux) Rechercher les fonctionnalités Windows",
    "tags": [],
    "title": "ATELIER #2: WSL, Ubuntu et des commandes Linux simples",
    "uri": "/semaine14/atelier/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Processus de démarrage, variables et FOR",
    "content": "Séquence de démarrage de Linux Le processus de démarrage de Linux est une série d’étapes qui se déroulent depuis l’allumage de l’ordinateur jusqu’à l’affichage de l’invite de commande ou de l’interface graphique. Comprendre ce processus est essentiel pour diagnostiquer et résoudre les problèmes de démarrage.\nLorsqu’un système Linux démarre, plusieurs étapes se succèdent de manière ordonnée pour préparer la machine et le système d’exploitation à fonctionner. Voici les étapes principales :\nBIOS/UEFI : Initialise le matériel et recherche un périphérique amorçable. Bootloader (GRUB) : Charge le noyau Linux et transfère le contrôle au système d’exploitation. Noyau Linux : Configure le matériel, monte le système de fichiers racine, et démarre le processus d’initialisation. Init/Systemd : Gère le lancement des services et des processus utilisateur. Étape 1 : BIOS/UEFI Rôle du BIOS/UEFI Le BIOS (Basic Input/Output System) ou l’UEFI (Unified Extensible Firmware Interface) est le premier programme exécuté lorsqu’une machine est allumée. Il effectue des tests matériels (POST) et localise le bootloader sur un disque amorçable, et charge le MBR en mémoire Le BIOS transfère alors le contrôle au code du Master Boot Record (MBR). Le MBR se trouve dans le premier secteur du disque dur (secteur 0), c’est-à-dire les premiers 512 octets de l’espace de stockage. Le MBR contient un programme minimal d’amorçage (bootloader primaire) qui localise et charge le bootloader secondaire (ex. GRUB ou LILO) depuis une partition active. Modes de démarrage Legacy (BIOS) : Mode traditionnel compatible avec les anciens systèmes. UEFI : Plus moderne, prend en charge des fonctionnalités avancées comme le Secure Boot. BIOS ou UEFI ?\rAvec l’essor de l’UEFI, le MBR est remplacé par le schéma GPT (GUID Partition Table), qui offre plus de flexibilité (gestion de disques de grande taille et partitions multiples). Les systèmes UEFI n’utilisent pas de MBR classique mais démarrent directement via un fichier exécutable dans une partition EFI (ESP). Le MBR est une étape initiale critique dans les systèmes BIOS/MBR, mais il est remplacé dans les environnements modernes utilisant UEFI. Étape 2 : Bootloader (GRUB) Rôle de GRUB Le bootloader (GRUB : GRand Unified Bootloader) est responsable de charger le noyau Linux en mémoire. Il peut proposer plusieurs options de démarrage, comme des versions différentes du noyau ou un mode de récupération. Étape 3 : Le noyau Linux (Kernel) Fonctionnalités du noyau au démarrage Détection matérielle : Identifie et initialise les composants matériels. Chargement des modules : Ajoute des pilotes pour des périphériques spécifiques. Montage du système de fichiers racine : Prépare l’environnement pour le reste du système. Lancement du processus d’initialisation : Appelle le gestionnaire d’initialisation (PID 1). Définition\rPID : Processus ID est l’identifiant d’un processus. Étape 4 : Init et Systemd Gestionnaires d’initialisation SysVinit : Ancien gestionnaire basé sur des scripts shell. Systemd : Gestionnaire moderne basé sur des unités (units) qui remplacent les scripts traditionnels. Information\rDans ce cours, on se limitera au commandes de systemd. Rôle de l’init (PID 1) L’init est le premier processus utilisateur démarré par le noyau. Il gère le lancement des services essentiels et assure la transition vers un état prêt pour les utilisateurs. Les services sont des processus en arrière-plan qui effectuent des tâches spécifiques (ex. serveur SSH, journalisation). Quand tous les services sont lancés, le programme init affiche l’écran de connexion, qui vous demande votre nom d’utilisateur et votre mot de passe. 5. Les cibles / niveaux d’exécution (Runlevels) Les cibles (niveaux d’exécution) définissent l’état du système et les services qui doivent être exécutés. Dans le passé, les modes de fonctionnement étaient connus sous le nom de niveaux d’exécution, chacun permettant l’accès à un ensemble spécifique de services. Le concept de niveaux d’exécution a été remplacé par celui de cibles (target). L’ensemble des services associés aux anciens niveaux d’exécution ont été conservés dans le système de cibles de systemd, afin de maintenir la compatibilité avec les scripts et les configurations existantes. Information\rLes distributions modernes comme Fedora, Ubuntu et Almalinux utilisent donc Systemd. Voici les cibles les plus courantes et leur correspondance:\nNiveau d’exécution Description Target Systemd 0 Arrêt du système. poweroff.target 1 Mode monoutilisateur (maintenance). rescue.target ou emergency.target 3 Multi-utilisateur (texte) multi-user.target 5 Multi-utilisateur (graphique) graphical.target 6 Redémarrage reboot.target Différence entre emergency.target et rescue.target emergency.target : Le mode le plus minimal, aucun système de fichiers supplémentaire n’est monté, pas de réseau, pas de services. C’est vraiment pour les urgences critiques. rescue.target : Similaire au mode monoutilisateur (niveau d’exécution 1). Il monte certains systèmes de fichiers et démarre un ensemble limité de services, mais pas de services réseau. Commandes liées aux cibles Systemd ou init. Note\rLes commandes systemctl qui modifient l’état du système ou des services touchent des fichiers et des processus sous contrôle strict, souvent localisés dans des répertoires comme /etc/systemd/system ou /lib/systemd/system. Ces zones sont protégées pour éviter des modifications accidentelles ou malveillantes. Dans la plupart des cas, vous devez avoir des privilèges sudo ou être connecté en tant qu’utilisateur root pour utiliser la commande systemctl, car elle est conçue pour gérer des services, des cibles (targets), et d’autres composants système qui nécessitent des autorisations élevées. Pour lister les processus s’exécutant sur une machine Avec ps :\nAffiche tous les processus s’exécutant sur la machine. [ndesmangles@localhost ~]$ ps -ef UID PID PPID C STIME TTY TIME CMD root 1 0 2 16:18 ? 00:00:01 /usr/lib/systemd/systemd --s\rPour connaître le niveau d’exécution actuel Avec Systemd :\n[ndesmangles@localhost ~]$ systemctl get-default graphical.target\rAvec runlevel (SysVinit) :\n[ndesmangles@localhost ~]$ runlevel N 5\rCette commande affiche deux valeurs : le précédent et l’actuel niveau d’exécution. Ici, N indique qu’il n’y avait pas de niveau précédent (au démarrage), et 5 est le niveau actuel. Pour se placer temporairement dans un niveau d’exécution Avec systemctl isolate reboot :\nCette commande met immédiatement le système en état de redémarrage. Elle isole le target associé à l’action de redémarrage (souvent reboot.target). Effet : Redémarrage immédiat, tous les services et processus actifs sont arrêtés proprement. Avec systemctl isolate poweroff :\nCette commande met immédiatement le système hors tension (extinction complète). Elle isole le target associé à l’arrêt (poweroff.target). Effet : Extinction immédiate, tous les services et processus actifs sont arrêtés proprement. Pour voir quel est le niveau d’exécution par défaut Avec Systemd :\n[ndesmangles@localhost ~]$ systemctl get-default\t# Renvoie le *target* par défaut.\rAvec runlevel (SysVinit) :\nVous pouvez également utiliser runlevel comme décrit précédemment. Pour modifier le niveau par défaut Avec Systemd :\nChangez le target par défaut avec : [ndesmangles@localhost ~]$ sudo systemctl set-default multi-user.target\t# Niveau d’exécution 3 (mode texte multi-utilisateur).\rAvec SysVinit :\nModifiez le fichier /etc/inittab (pour les systèmes utilisant encore SysVinit) : [ndesmangles@localhost ~]$ id:5:initdefault:\t# Définit le niveau 5 (mode graphique) comme niveau d’exécution par défaut.\rPour se rendre directement au niveau d’exécution par défaut Utilisez la commande suivante pour forcer le système à se placer dans le niveau d’exécution ou target par défaut : [ndesmangles@localhost ~]$ sudo systemctl isolate default.target\rQuestion: Suite aux commandes suivantes, que se passe-t-il ?\n[ndesmangles@localhost ~]$ init 0 : Réponse\rEnvoie le système au niveau d’exécution 0, qui correspond à l’extinction. Effet : Éteint immédiatement la machine, tout comme la commande systemctl poweroff. [ndesmangles@localhost ~]$ init 6 : Réponse\rEnvoie le système au niveau d’exécution 6, qui correspond au redémarrage. Effet : Redémarre immédiatement la machine, tout comme la commande systemctl reboot. Les variables utilisateur en Bash Nomenclature, assignation et affichage des variables Lors de la création d’une variable, toujours utiliser des noms descriptifs. Exemple: nombre_utilisateurs au lieu de nombre. Attention\rLes caractères spéciaux ou espaces dans les noms peuvent causer des erreurs. Les noms sont sensible à la casse. Exemple: VAR1 ≠ var1\nPas besoin de déclaration explicite, pour affecter une valeur on utilise = sans espace autour de =. Exemple:\n[ndesmangles@localhost ~]$ ma_variable=\"Bonjour, Linux!\"\rPour afficher la valeur d’une variable, on utilise le symbole $ devant le nom. Exemple: [ndesmangles@localhost ~]$ echo $ma_variable\rPour supprimer une variable, on utilise unset suivi du nom de la variable (sans $). Exemple: [ndesmangles@localhost ~]$ unset ma_variable\rStocker le résultat d’une commande dans une variable En Bash, vous pouvez capturer la sortie d’une commande dans une variable en utilisant la syntaxe $(...).\nExemple 1 : Stocker la date courante\n[ndesmangles@localhost ~]$ date_courante=$(date +%Y-%m-%d)\t# La date sera stockée dans date_courante aaaa-mm-jj [ndesmangles@localhost ~]$ echo $date_courante\t# Affiche la valeur de date_courante 2025-01-09\rExemple 2 : Compter et stocker le nombre de fichiers dans le répertoire courant\n[ndesmangles@localhost ~]$ nombre_fichiers=$(ls | wc -l) [ndesmangles@localhost ~]$ echo $nombre_fichiers 8\rls : Liste les fichiers et répertoires dans le répertoire courant. wc -l : Compte le nombre de lignes de la sortie de ls, correspondant au nombre d’entrées.[^1] Expansion des variables en Bash L’expansion des variables consiste à remplacer le nom d’une variable par sa valeur lors de l’exécution d’une commande, permettant ainsi d’utiliser dynamiquement des données dans des scripts ou des commandes.\nExemple 1: Remplacement de la variable par sa valeur\n[ndesmangles@localhost ~]$ fichiers=\"toto titi tutu\" [ndesmangles@localhost ~]$ ls -l $fichiers\rCommande exécutée :\n[ndesmangles@localhost ~]$ ls -l toto titi tutu\rExemple 2: Une variable peut inclure des options :\n[ndesmangles@localhost ~]$ fichiers=\"-l toto titi tutu\" [ndesmangles@localhost ~]$ ls $fichiers\rCommande équivalente :\n[ndesmangles@localhost ~]$ ls -l toto titi tutu\rStocker le résultat d’une commande dans une variable Stocker le résultat d’une commande dans une variable consiste à capturer la sortie d’une commande en utilisant la syntaxe $(commande) afin de la réutiliser ultérieurement dans un script ou une commande.\n[ndesmangles@localhost ~]$ fichiers=$(ls) [ndesmangles@localhost ~]$ ls \"$fichiers\" # Toujours utiliser des guillemets pour gérer les espaces.\rExpansion de noms de fichiers (* et ?) Dans Bash on peut utiliser des caractères génériques pour étendre des motifs en liste de fichiers existants.\nCaractère Description Exemple Résultat * Remplace une chaîne de longueur variable ls *.txt Fichiers comme toto.txt, titi.txt ? Remplace un seul caractère ls t?t?.txt Fichiers comme toto.txt, titi.txt Expansion d’accolades L’expansion d’accolades en Bash permet de générer rapidement des séries de chaînes ou de motifs en factorisant des éléments variables, comme dans {a,b,c} pour produire a, b, c, ou {1..5} pour générer 1, 2, 3, 4, 5.\nBut Commande Résultat Générer des variations touch patat{a,e,i,o,u,y} patata, patate, … Générer une séquence touch test{1..12}.txt test1.txt, test2.txt, … Attention\rPas d’espace dans les accolades Protéger contre l’expansion Protéger contre l’expansion en Bash consiste à empêcher l’interprétation des caractères spéciaux, des variables ou des commandes en utilisant des guillemets simples, doubles ou le caractère d’échappement \\.\nMéthode Commande Effet Échappement \\ echo Je veux afficher \\* et \\$x Affiche * et $x sans expansion. Guillemets simples ' echo 'Voici * et $x' Aucun remplacement, affiche littéralement. Guillemets doubles \" echo \"Valeur : $x\" Permet l’expansion des variables. Commandes spéciales et expansions Certaines commandes comme find[^1] nécessitent une attention particulière concernant l’expansion.\nExemple : Recherche avec find Pour rechercher tous les fichiers .txt :\nfind / -name \"*.txt\"\rIci, les guillemets protègent *.txt pour empêcher Bash d’expandre le motif avant de passer à find. Cela garantit que find traite correctement le motif.\nBonnes pratiques avec les variables Toujours utiliser des guillemets pour éviter les problèmes avec les espaces ou caractères spéciaux :\nls \"$fichiers\"\rProtégez les motifs pour les commandes comme find:\nfind / -name \"*.txt\"\rUtilisez les accolades pour générer des séquences et factoriser vos commandes :\ntouch fichier{1..10}.txt\rItération sur les résultats de commandes La boucle for est un élément fondamental qui permet de répéter une action pour chaque élément d’une liste ou d’un ensemble de valeurs. Elle est particulièrement utile pour automatiser des tâches répétitives.\nStructure générale for variable in liste do commande1 commande2 ... done\rvariable : Une variable temporaire qui prend successivement chaque valeur de la liste. liste : Un ensemble de valeurs, qui peut être défini explicitement ou généré dynamiquement. Les commandes entre do et done sont exécutées pour chaque valeur de la liste. Exemple 1 : Parcourir une liste statique for animal in chat chien oiseau do echo \"Je suis un $animal\" done\rSortie :\nJe suis un chat\rJe suis un chien\rJe suis un oiseau\rExemple 2 : Parcourir des fichiers d’un répertoire for fichier in *.txt do echo \"Traitement de $fichier\" done\rIci, *.txt est un motif de fichier. Bash remplace *.txt par la liste des fichiers correspondants dans le répertoire courant. Sortie : (si le répertoire contient file1.txt et file2.txt)\nTraitement de file1.txt\rTraitement de file2.txt\rExemple 3 : Générer une liste avec une séquence Vous pouvez utiliser une séquence avec {debut..fin} pour générer des nombres ou des caractères :\nfor i in {1..5} do echo \"Nombre : $i\" done\rSortie :\nNombre : 1\rNombre : 2\rNombre : 3\rNombre : 4\rNombre : 5\rExemple 4 : Ajouter des pas dans une séquence Pour parcourir une séquence avec un pas spécifique, utilisez {debut..fin..pas} :\nfor i in {1..10..2} do echo \"Nombre impair : $i\" done\rSortie :\nNombre impair : 1\rNombre impair : 3\rNombre impair : 5\rNombre impair : 7\rNombre impair : 9\rExemple 5 : Lire des entrées à partir d’une commande Vous pouvez parcourir les fichiers dans un répertoire pour lister les utilisateurs disposant d’un répertoire personnel sur le système :\nfor user in $(ls /home) do echo \"Utilisateur avec un répertoire : $user\" done\rExplication :\nls /home liste les répertoires dans /home, où chaque répertoire correspond généralement à un utilisateur ayant un compte sur le système. La boucle for parcourt chaque nom de répertoire et l’associe à la variable user. La commande echo affiche ensuite le nom de chaque utilisateur. Utiliser des guillemets pour protéger les valeurs Si les éléments de la liste contiennent des espaces, utilisez des guillemets pour éviter des erreurs :\nfor fichier in \"Fichier 1.txt\" \"Fichier 2.txt\" do echo \"Traitement de $fichier\" done\rBonnes pratiques avec la boucle for Liste explicite : Utilisez une liste statique ou une séquence simple :\nfor i in {1..10}\rMotifs et fichiers : Parcourez les fichiers d’un répertoire avec des motifs :\nfor fichier in *.txt\rCommandes dynamiques : Créez une liste à partir du résultat d’une commande :\nfor utilisateur in $(who | awk '{print $1}')\rGuillemets : Protégez les éléments avec des espaces :\nfor fichier in \"file 1\" \"file 2\"\r[^1] Nous verrons cette commande plus en détails au prochain cours.",
    "description": "Séquence de démarrage de Linux Le processus de démarrage de Linux est une série d’étapes qui se déroulent depuis l’allumage de l’ordinateur jusqu’à l’affichage de l’invite de commande ou de l’interface graphique. Comprendre ce processus est essentiel pour diagnostiquer et résoudre les problèmes de démarrage.\nLorsqu’un système Linux démarre, plusieurs étapes se succèdent de manière ordonnée pour préparer la machine et le système d’exploitation à fonctionner. Voici les étapes principales :",
    "tags": [],
    "title": "Processus de démarrage, cibles, variables et boucle For",
    "uri": "/semaine3/cours/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Processus de démarrage, variables et FOR",
    "content": "Objectifs de l’atelier Se familiariser avec les cibles (niveaux d’exécution). Comprendre les bases des variables utilisateur en Bash. Apprendre à manipuler et utiliser des variables pour stocker des résultats de commandes. Atelier Exercice 1 : Manipuler les cibles (niveaux d’exécution) Utiliser la commande systemctl pour passer en mode multi-utilisateur sans interface graphique Vérifier que vous êtes maintenant en mode multi-utilisateur sans interface graphique. Définir le mode multi-utilisateur avec interface graphique comme cible par défaut. Redémarrer votre système pour vérifier que le mode graphique est bien la cible par défaut. Exercice 2 : Création et affichage de variables Déclarez une variable nom avec votre prénom. Affichez la valeur de la variable. Essayez d’accéder à la variable sans $. Notez la différence. Exercice 3 : Capturer une date formatée Stockez la date actuelle dans une variable date_actuelle avec le format AAAA/MM/JJ hh:mm:ss. Affichez la date formatée. Exercice 4 : Supprimer une variable Déclarez une variable temporaire. Supprimez la variable avec unset. Essayez d’afficher la variable supprimée. Exercice 5: Expansion de variables et d’accolades Créer une variable (variable_etc) contenant la liste des fichiers du répertoire /etc et l’afficher. Son contenu est-il facile à lire ? Que se passe-t-il si vous exécutez ls suivi du nom de votre variable ? Pourquoi ? Sachant que beaucoup de fichiers de configuration se terminent par .conf, les trouver et stocker leur nom dans une variable. Que se passe-t-il si vous exécutez ls suivi du nom de votre variable? Seriez-vous capable d’afficher la taille de chacun des fichiers de configuration ? La commande du -sh \u003cfichier\u003e permet d’afficher la taille de fichier. Créer un répertoire dans lequel vous créerez les fichiers suivants à l’aide de la commande touch en utilisant la syntaxe permettant de factoriser une commande: test1.txt, test2.txt, test3.txt, test1.doc, test2.doc, test3.doc, test1.tot, test2.tot, test3.tot Grâce aux caractères génériques, n’afficher que les fichiers .txt qui commencent par test (plusieurs possibilités existent, essayez de les trouver). a. Tous les fichiers .txt et .tot`. b. Tous les fichiers test1 Exercice 6: Expansion d’accolade et boucle for En faisant cet exercice, vérifiez pour cette question le résultat de vos commandes en utilisant la commande tree. La figure ci-dessous montre un exemple d’utilisation de cette commande. Assurez-vous d’être revenu dans votre répertoire personnel À l’aide d’une seule commande et en utilisant l’expansion d’accolade, créez l’arborescence des dossiers suivante : À l’aide d’une seule commande et en utilisant l’expansion d’accolade, créer le fichier vide priseNote dans chaque répertoire lab. À l’aide d’une boucle for, renommer les fichier priseNote en priseNote.txt. À l’aide d’une boucle for, déplacer les fichiers priseNote.txt du répertoire lab vers le répertoire leçon correspondant.",
    "description": "Objectifs de l’atelier Se familiariser avec les cibles (niveaux d’exécution). Comprendre les bases des variables utilisateur en Bash. Apprendre à manipuler et utiliser des variables pour stocker des résultats de commandes. Atelier Exercice 1 : Manipuler les cibles (niveaux d’exécution) Utiliser la commande systemctl pour passer en mode multi-utilisateur sans interface graphique Vérifier que vous êtes maintenant en mode multi-utilisateur sans interface graphique. Définir le mode multi-utilisateur avec interface graphique comme cible par défaut. Redémarrer votre système pour vérifier que le mode graphique est bien la cible par défaut. Exercice 2 : Création et affichage de variables Déclarez une variable nom avec votre prénom. Affichez la valeur de la variable. Essayez d’accéder à la variable sans $. Notez la différence. Exercice 3 : Capturer une date formatée Stockez la date actuelle dans une variable date_actuelle avec le format AAAA/MM/JJ hh:mm:ss. Affichez la date formatée. Exercice 4 : Supprimer une variable Déclarez une variable temporaire. Supprimez la variable avec unset. Essayez d’afficher la variable supprimée. Exercice 5: Expansion de variables et d’accolades Créer une variable (variable_etc) contenant la liste des fichiers du répertoire /etc et l’afficher. Son contenu est-il facile à lire ? Que se passe-t-il si vous exécutez ls suivi du nom de votre variable ? Pourquoi ? Sachant que beaucoup de fichiers de configuration se terminent par .conf, les trouver et stocker leur nom dans une variable. Que se passe-t-il si vous exécutez ls suivi du nom de votre variable? Seriez-vous capable d’afficher la taille de chacun des fichiers de configuration ? La commande du -sh \u003cfichier\u003e permet d’afficher la taille de fichier. Créer un répertoire dans lequel vous créerez les fichiers suivants à l’aide de la commande touch en utilisant la syntaxe permettant de factoriser une commande: test1.txt, test2.txt, test3.txt, test1.doc, test2.doc, test3.doc, test1.tot, test2.tot, test3.tot Grâce aux caractères génériques, n’afficher que les fichiers .txt qui commencent par test (plusieurs possibilités existent, essayez de les trouver). a. Tous les fichiers .txt et .tot`. b. Tous les fichiers test1 Exercice 6: Expansion d’accolade et boucle for En faisant cet exercice, vérifiez pour cette question le résultat de vos commandes en utilisant la commande tree. La figure ci-dessous montre un exemple d’utilisation de cette commande. Assurez-vous d’être revenu dans votre répertoire personnel À l’aide d’une seule commande et en utilisant l’expansion d’accolade, créez l’arborescence des dossiers suivante :",
    "tags": [],
    "title": "ATELIER #3: Cibles et variables utilisateurs et for",
    "uri": "/semaine3/atelier/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "Plan de la leçon Théorie :\ngrep, set, more, cut, sort, find. Les entrées et sorties des commandes. La redirection des entrées et sorties. Les Pipelines. Les commandes de filtrage courantes. La boucle while. Atelier :\nRedirection des entrées et sorties. Utilisation de pipelines. Utilisation des commandes de filtrage. Itération avec While.",
    "description": "Plan de la leçon Théorie :\ngrep, set, more, cut, sort, find. Les entrées et sorties des commandes. La redirection des entrées et sorties. Les Pipelines. Les commandes de filtrage courantes. La boucle while. Atelier :\nRedirection des entrées et sorties. Utilisation de pipelines. Utilisation des commandes de filtrage. Itération avec While.",
    "tags": [],
    "title": "E/S, redirection et filtrage de commandes et While",
    "uri": "/semaine4/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e E/S, redirection et filtrage de commandes et While",
    "content": "7. Utilisation spécifique avec find Pour éviter une expansion prématurée par Bash, protégez les motifs :\nfind / -name \"*.txt\"\rBonnes pratiques avec les variables Utilisez des guillemets pour gérer les espaces : ls \"$fichiers\"\rProtégez les motifs pour find : find / -name \"*.txt\"\rUtilisez des accolades pour automatiser : touch fichier{1..10}.txt\r====== Les entrées et sorties des commandes, la redirection des commandes, les filtres et les pipelines de commandes permettent de manipuler et de traiter des données de manière puissante et flexible, en utilisant des commandes simples mais très efficaces.\nLes entrées et sorties des commandes Dans le système d’exploitation Linux, les commandes interagissent avec trois flux de données principaux :\nEntrée standard (stdin) : Il s’agit du flux de données d’entrée par défaut pour les commandes. Par défaut, stdin est lié au clavier, ce qui signifie que les commandes lisent les données saisies par l’utilisateur. Cependant, stdin peut être redirigé pour lire des données à partir de fichiers ou d’autres commandes.\nSortie standard (stdout, numérotée 1) : Il s’agit du flux de données de sortie par défaut pour les commandes. Par défaut, stdout est lié à l’écran, ce qui signifie que les commandes affichent leurs résultats à l’écran. Cependant, stdout peut être redirigé pour écrire des données dans des fichiers ou les transmettre à d’autres commandes.\nErreurs standard (stderr, numérotée 2) : Il s’agit du flux de données de sortie pour les messages d’erreur. Par défaut, stderr est également lié à l’écran, ce qui signifie que les messages d’erreur sont affichés à l’écran. Comme stdout, stderr peut être redirigé pour écrire des messages d’erreur dans des fichiers ou les transmettre à d’autres commandes.\nLa redirection des entrées et sorties L’utilisation de stdin, stdout et stderr est essentielle pour manipuler les flux de données dans Linux.\nRedirection de stdin (Entrée standard) Par défaut, stdin (\u003c) lit les données saisies par l’utilisateur via le clavier.\nInfo\rNous ne verrons pas la redirection à l’aide de \u003c.\nCependant, vous pouvez rediriger stdin pour lire des données à partir d’un fichier ou d’une autre commande, en récupérant la sortie standard d’une autre commande grâce au pipeline (vu plus bas).\nRedirection de stdout (Sortie standard) Par défaut, stdout (\u003e et ») affiche les résultats des commandes à l’écran. Vous pouvez rediriger stdout pour écrire les résultats dans un fichier ou les transmettre à une autre commande.\ncommande \u003e fichier.txt\rCette commande enregistre la sortie de commande dans sortie.txt, écrasant le contenu existant du fichier.\nExemples :\nLa commande find / -name services retourne à l’écran (stdout) les noms des fichiers ou des répertoires nommés “services” à partir de la racine du système de fichiers (/).\nSi on souhaite , on peut rediriger la sortie standard (stdout) vers un fichier (ex: resultat.txt):\nfind / -name services \u003e resultat.txt\rOu\nfind / -name services 1\u003e resultat.txt\rCes commandes envoient le résultat dans un fichier au lieu de l’envoyer à l’écran.\nImportant\rAvec \u003e ou 1\u003e, le contenu du fichier sera écrasé.\nPour ne pas écraser le contenu existant, il faut utiliser \u003e\u003e comme dans l’exemple ci-dessous:\nfind / -name services \u003e\u003e resultat.txt\rCette commande ajoute le résultat à la fin du fichier resultat.txt sans écraser le contenu existant.\nInfo\rLa mention Permission denied est un message d’erreur indiquant qu’il faut avoir les droits d’accès sur les fichiers ou répertoires.\nRedirection de stderr (Erreurs standard) Par défaut, stderr affiche les messages d’erreur à l’écran. Vous pouvez rediriger stderr pour écrire les messages d’erreur dans un fichier ou les transmettre à une autre commande.\nfind / -name services 2\u003e erreurs.txt\rCette commande envoie les messages d’erreur dans le fichier erreurs.txt.\nIl est possible de rediriger la sortie standard et la sortie d’erreur standard.\n$ find / -name services \u003e resultats.txt 2\u003e/dev/null\rIl est aussi possible de rediriger la sortie d’erreur standard vers la sortie standard (\u00261) et d’envoyer le tout dans un fichier:\n$ find / -name services \u003e resultats.txt 2\u003e\u00261\r2\u003e\u00261 : Cette syntaxe redirige stderr vers la même destination que stdout. Il est possible de se débarrasser des erreurs en redirigeant la sortie d’erreur standard.\n$ find / -name services 2\u003e/dev/null\r/dev/null agit comme un trou noir dans lequel tout ce qu’on envoie disparait.\n\u0026\u003e : Ce symbole redirige à la fois stdout et stderr vers un fichier spécifié. L’utilisation des symboles \u0026\u003e et 2\u003e\u00261 permet de rediriger à la fois les sorties standard et les erreurs standard.\nVous pouvez rediriger à la fois stdout et stderr vers un fichier ou une autre commande.\ncommande \u003e sortie.txt 2\u003e erreurs.txt\rCette commande enregistre la sortie de commande dans sortie.txt et les messages d’erreur dans erreurs.txt.\ncommande \u0026\u003e tout.txt\rCette commande enregistre à la fois la sortie et les messages d’erreur de commande dans tout.txt.\nRedirection combinée La redirection combinée permet de rediriger simultanément les sorties standard (stdout) et les erreurs standard (stderr) vers un fichier ou une autre commande. Cela est particulièrement utile pour capturer toutes les sorties d’une commande, y compris les messages d’erreur, dans un seul fichier.\nExemple 1 : Utilisation de \u0026\u003e\ncommande \u0026\u003e tout.txt\rCette commande redirige à la fois la sortie standard et les erreurs standard de commande vers le fichier tout.txt.\nExemple 2 : Utilisation de 2\u003e\u00261\ncommande \u003e sortie.txt 2\u003e\u00261\rCette commande redirige la sortie standard de commande vers le fichier sortie.txt et redirige les erreurs standard vers la même destination que la sortie standard.\nExemple 3 : Redirection combinée avec append\ncommande \u003e\u003e sortie.txt 2\u003e\u00261\rCette commande ajoute la sortie standard et les erreurs standard de commande à la fin du fichier sortie.txt sans écraser le contenu existant.\nUtilisation des Pipelines Les pipelines permettent de rediriger la sortie d’une commande (stdout) comme entrée (stdin) d’une autre commande en utilisant le symbole | (se prononce pipe).\ncommande1 | commande2\rCette commande utilise la sortie de commande1 comme entrée pour commande2.\nExemple :\nls -l | grep \".txt\" | sort\rCette commande liste les fichiers du répertoire courant, filtre ceux qui ont l’extension .txt, puis trie les résultats.\nRedirection combinée avec un pipeline commande1 | commande2 \u003e sortie.txt 2\u003e\u00261\rCette commande utilise un pipeline pour rediriger la sortie de commande1 vers commande2, puis redirige la sortie standard et les erreurs standard de commande2 vers le fichier sortie.txt.\nLes filtres de commandes Les filtres sont des commandes qui prennent des données en entrée, les transforment et produisent des données en sortie. Ils sont utilisés pour manipuler et traiter des données de manière précise et efficace. Les filtres sont souvent utilisés dans des pipelines pour créer des chaînes de traitement de données complexes.\nLes filtres jouent un rôle crucial dans le traitement des données sous Linux. Ils permettent de :\nFiltrer : Sélectionner uniquement les données pertinentes en fonction de critères spécifiques. Transformer : Modifier les données pour les adapter à un format ou à une structure souhaitée. Analyser : Extraire des informations utiles à partir des données brutes. Combiner : Fusionner les données provenant de différentes sources pour obtenir un résultat cohérent. Les commandes de filtrage courantes AJOUTER FIND Commande Description Option Description de l’option Exemple grep Recherche de motifs dans les fichiers. -i Ignore la casse (majuscule/minuscule) grep -i \"motif\" fichier.txt -r Recherche récursive dans les répertoires grep -r \"motif\" /chemin/du/repertoire -v Inverse la recherche, affichant les lignes qui ne correspondent pas au motif grep -v \"motif\" fichier.txt -n Affiche les numéros de ligne des correspondances grep -n \"motif\" fichier.txt sed Édition de flux de texte. -e Permet de spécifier plusieurs commandes sed -e 's/ancien/nouveau/' -e 's/vieux/neuf/' fichier.txt -i Modifie les fichiers en place sed -i 's/ancien/nouveau/g' fichier.txt cut Extraction de sections de lignes. -d Spécifie le délimiteur cut -d ',' -f 1,3 fichier.csv -f Spécifie les champs à extraire cut -f 1,3 fichier.txt sort Tri des lignes. -r Trie dans l’ordre inverse sort -r fichier.txt -n Trie numériquement sort -n fichier.txt -k Trie selon une clé spécifique sort -k 2 fichier.txt uniq Suppression des doublons. -c Affiche le nombre de fois que chaque ligne apparaît uniq -c fichier.txt -d Affiche uniquement les lignes en double uniq -d fichier.txt wc Comptage des lignes, mots et caractères. -l Compte les lignes wc -l fichier.txt -w Compte les mots wc -w fichier.txt -c Compte les caractères wc -c fichier.txt tr Traduction ou suppression de caractères. -d Supprime les caractères spécifiés `echo “texte” -s Remplace les séquences de caractères répétés par un seul caractère `echo “aaabbbccc” Commande grep grep (Global Regular Expression Print) est utilisée pour rechercher des motifs dans des fichiers. grep \"motif\" fichier.txt\rCette commande recherche le mot “motif” dans fichier.txt.\nCommande sed sed (Stream Editor) est un éditeur de texte en ligne de commande qui permet de modifier des fichiers de manière non interactive. sed 's/ancien/nouveau/g' fichier.txt\rCette commande remplace toutes les occurrences de “ancien” par “nouveau” dans fichier.txt.\nCommande cut cut est utilisée pour extraire des sections de chaque ligne d’un fichier. cut -d ',' -f 1,3 fichier.csv\rCette commande extrait les champs 1 et 3 des lignes du fichier fichier.csv, en utilisant la virgule comme délimiteur.\nCommande sort sort est utilisée pour trier les lignes d’un fichier texte ou d’une entrée standard. sort fichier.txt\rCette commande trie les lignes de fichier.txt.\nCommande uniq uniq est utilisée pour supprimer les lignes en double dans un fichier trié. sort fichier.txt | uniq\rCette commande trie les lignes de fichier.txt et supprime les doublons.\nCommande wc Rappel de la semaine 2 : wc (Word Count) est utilisée pour compter les lignes, les mots et les caractères dans un fichier.\nwc -l fichier.txt\rCette commande affiche le nombre de lignes dans fichier.txt.\nCommande tr tr (Translate) est utilisée pour traduire ou supprimer des caractères. echo \"texte\" | tr 'a-z' 'A-Z'\rCette commande convertit les lettres minuscules en majuscules dans le texte “texte”.\nCombinaison de plusieurs filtres à l’aide de | Exemple 1 : Compter les lignes contenant un motif spécifique\ngrep \"motif\" fichier.txt | wc -l\rCette commande recherche “motif” dans fichier.txt et compte le nombre de lignes correspondantes.\nExemple 2 : Afficher les 10 plus grands fichiers\nls -l | sort -k 5 -n | tail -n 10\rCette commande liste les fichiers du répertoire courant, trie les résultats par taille (colonne 5) et affiche les 10 plus grands fichiers.\nExemple 3 : Trouver les fichiers modifiés récemment\nfind . -type f -mtime -7 | xargs ls -l\rCette commande trouve les fichiers modifiés au cours des 7 derniers jours et affiche leurs détails.\nExemple 4 : Extraire et trier des champs spécifiques d’un fichier CSV\ncut -d ',' -f 2 fichier.csv | sort | uniq\rCette commande extrait le deuxième champ de chaque ligne de fichier.csv, trie les résultats et affiche les lignes uniques.\nExemple 5 : Remplacer un mot dans plusieurs fichiers\ngrep -rl \"ancien\" . | xargs sed -i 's/ancien/nouveau/g'\rCette commande recherche tous les fichiers contenant “ancien” dans le répertoire courant et remplace “ancien” par “nouveau” dans ces fichiers.",
    "description": "7. Utilisation spécifique avec find Pour éviter une expansion prématurée par Bash, protégez les motifs :\nfind / -name \"*.txt\"\rBonnes pratiques avec les variables Utilisez des guillemets pour gérer les espaces : ls \"$fichiers\"\rProtégez les motifs pour find : find / -name \"*.txt\"\rUtilisez des accolades pour automatiser : touch fichier{1..10}.txt\r====== Les entrées et sorties des commandes, la redirection des commandes, les filtres et les pipelines de commandes permettent de manipuler et de traiter des données de manière puissante et flexible, en utilisant des commandes simples mais très efficaces.",
    "tags": [],
    "title": "Entrées/Sorties, redirection, filtres et Pipeline des commandes",
    "uri": "/semaine4/cours/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e E/S, redirection et filtrage de commandes et While",
    "content": "Objectif de l’atelier Se familiariser avec les entrées/sorties et la redirection des commandes. Combinaison de commandes. Filtrage de données. Atelier Exercice 1 : E/S Exercice 2: Redirection Exercice 3: Filtrage (grep, sed, cut, find, etc.) Exercice 4: While Exercice 5: Expansion d’accolade et commande find, grep Exercice2 : Caractères génériques et commande find Allez dans le répertoire /etc. Ne vous déplacez pas pour le reste de cet exercice.\nEn utilisant la commande find, cherchez les fichiers dont le nom commence par la lettre r à partir du répertoire courant.\nCherchez tous les fichiers dont le nom contient la chaîne de caractères rc à partir du répertoire courant.\nAffichez tous les fichiers dont le nom comporte trois caractères sur tout le système.",
    "description": "Objectif de l’atelier Se familiariser avec les entrées/sorties et la redirection des commandes. Combinaison de commandes. Filtrage de données. Atelier Exercice 1 : E/S Exercice 2: Redirection Exercice 3: Filtrage (grep, sed, cut, find, etc.) Exercice 4: While Exercice 5: Expansion d’accolade et commande find, grep Exercice2 : Caractères génériques et commande find Allez dans le répertoire /etc. Ne vous déplacez pas pour le reste de cet exercice.\nEn utilisant la commande find, cherchez les fichiers dont le nom commence par la lettre r à partir du répertoire courant.",
    "tags": [],
    "title": "ATELIER #4: Redirection, E/S, pipeline et filtres",
    "uri": "/semaine4/atelier/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Les processus Linux",
    "content": "Objectifs de l’atelier Comprendre les processus sous Linux. Apprendre à lister, gérer et contrôler les processus. Manipuler les processus en premier plan et en arrière-plan. Atelier Dans cet atelier, vous apprendrez à manipuler les processus sous Linux en utilisant des commandes de base. Nous allons explorer les différents types de processus, ainsi que les commandes essentielles pour les superviser et les contrôler. Cet atelier est conçu pour être pratique et interactif.\nExercice 1 : Identifier les processus Commande : ps Ouvrez un terminal. Tapez la commande suivante pour lister les processus associés à votre session actuelle : ps\rEssayez d’utiliser ps aux pour afficher tous les processus en cours d’exécution : ps aux\rObservez les colonnes importantes comme PID, USER, et COMMAND. Exercice 2 : Observer les processus en temps réel Commande : top Lancez la commande : top\rNotez les informations fournies : utilisation du CPU, de la mémoire, etc. Appuyez sur q pour quitter. Alternative : htop Si disponible, essayez htop pour une interface plus conviviale : htop\rExercice 3 : Gérer les processus en arrière-plan Commandes : jobs, bg, et fg Lancez une commande en arrière-plan en ajoutant un \u0026 à la fin : sleep 30 \u0026\rListez les processus en arrière-plan : jobs\rSuspendez un processus (en premier plan) avec Ctrl+Z et relancez-le en arrière-plan : bg %1\rRamenez un processus en premier plan : fg %1\rExercice 4 : Terminer un processus Commandes : kill et ps Identifiez un processus à l’aide de ps : ps aux | grep sleep\rNotez le PID du processus. Terminez le processus avec la commande kill : kill \u003cPID\u003e\rPour forcer l’arrêt d’un processus : kill -9 \u003cPID\u003e",
    "description": "Objectifs de l’atelier Comprendre les processus sous Linux. Apprendre à lister, gérer et contrôler les processus. Manipuler les processus en premier plan et en arrière-plan. Atelier Dans cet atelier, vous apprendrez à manipuler les processus sous Linux en utilisant des commandes de base. Nous allons explorer les différents types de processus, ainsi que les commandes essentielles pour les superviser et les contrôler. Cet atelier est conçu pour être pratique et interactif.",
    "tags": [],
    "title": "ATELIER #5: Gestion des processus Linux",
    "uri": "/semaine5/atelier/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "Plan de la leçon Théorie : Atelier :.\nExercices patiques sur Création",
    "description": "Plan de la leçon Théorie : Atelier :.\nExercices patiques sur Création",
    "tags": [],
    "title": "VIM et les fichiers de configuration",
    "uri": "/semaine8/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e VIM et les fichiers de configuration",
    "content": "Vim est un éditeur de texte puissant et flexible, souvent utilisé par les programmeurs et les administrateurs système. Il est basé sur un autre éditeur de texte appelé Vi, mais offre de nombreuses fonctionnalités supplémentaires.\nVim peut sembler intimidant au début, mais avec de la pratique, il devient un outil extrêmement puissant pour l’édition de texte.\nInstallation de Vim Pour installer Vim, vous pouvez utiliser le gestionnaire de paquets de votre système d’exploitation. Par exemple :\nSur Ubuntu/Debian :\nsudo apt-get install vim\rSur Fedora :\nsudo dnf install vim\rSur macOS avec Homebrew :\nbrew install vim\rModes de Vim Vim fonctionne en différents modes, chacun ayant un comportement spécifique. Les trois modes principaux sont :\nMode Normal : Le mode par défaut pour naviguer et manipuler du texte. Mode Insertion : Utilisé pour insérer du texte. Mode Commande : Utilisé pour exécuter des commandes. Passer d’un mode à l’autre Pour passer en mode Insertion depuis le mode Normal, appuyez sur i. Pour revenir en mode Normal depuis le mode Insertion, appuyez sur Esc. Pour entrer en mode Commande depuis le mode Normal, appuyez sur :. Commandes de base Voici quelques commandes de base pour vous aider à démarrer avec Vim :\nNavigation h, j, k, l : Déplacer le curseur à gauche, en bas, en haut et à droite. w : Aller au début du mot suivant. b : Aller au début du mot précédent. 0 : Aller au début de la ligne. $ : Aller à la fin de la ligne. Édition i : Passer en mode Insertion avant le curseur. a : Passer en mode Insertion après le curseur. x : Supprimer le caractère sous le curseur. dd : Supprimer la ligne courante. yy : Copier la ligne courante. p : Coller après le curseur. Sauvegarde et sortie :w : Sauvegarder le fichier. :q : Quitter Vim. :wq : Sauvegarder et quitter Vim. :q! : Quitter sans sauvegarder. Exemple pratique Imaginons que vous souhaitiez créer un fichier texte simple avec Vim. Voici les étapes à suivre :\nOuvrez Vim en tapant vim dans votre terminal. Passez en mode Insertion en appuyant sur i. Tapez votre texte, par exemple : Bonjour, ceci est un fichier texte créé avec Vim.\rRevenez en mode Normal en appuyant sur Esc. Sauvegardez le fichier en tapant :w nom_du_fichier.txt et appuyez sur Enter. Quittez Vim en tapant :q et appuyez sur Enter. Les fichiers de configuration dans Linux Les fichiers de configuration sont essentiels pour le fonctionnement des systèmes Linux. Ils permettent de définir les paramètres et les comportements des applications et des services. Comprendre comment les utiliser et les modifier est crucial pour tout utilisateur de Linux.\nEmplacement des fichiers de configuration Les fichiers de configuration se trouvent généralement dans le répertoire /etc. Cependant, certains fichiers de configuration spécifiques à l’utilisateur peuvent se trouver dans le répertoire personnel de l’utilisateur, souvent précédés d’un point (.), ce qui les rend cachés.\nExemples de fichiers de configuration /etc/passwd : Contient les informations sur les utilisateurs du système. /etc/fstab : Contient les informations sur les systèmes de fichiers montés au démarrage. ~/.bashrc : Contient les configurations spécifiques à l’utilisateur pour le shell Bash. Syntaxe des fichiers de configuration La syntaxe des fichiers de configuration peut varier, mais ils sont souvent basés sur des paires clé-valeur ou des sections. Voici quelques exemples :\nFichier de configuration simple # Ceci est un commentaire clé1=valeur1 clé2=valeur2\rFichier de configuration avec sections [section1] clé1=valeur1 [section2] clé2=valeur2\rModifier les fichiers de configuration Pour modifier un fichier de configuration, vous pouvez utiliser un éditeur de texte comme nano, vim ou gedit. Voici comment modifier un fichier de configuration avec nano :\nOuvrez le terminal. Tapez sudo nano /etc/nom_du_fichier pour ouvrir le fichier avec les privilèges administratifs. Faites les modifications nécessaires. Appuyez sur Ctrl+O pour sauvegarder le fichier, puis Ctrl+X pour quitter. Modifier les fichiers de configuration avec Vim Pour modifier un fichier de configuration avec Vim, suivez ces étapes :\nOuvrez le terminal. Tapez sudo vim /etc/nom_du_fichier pour ouvrir le fichier avec les privilèges administratifs. Passez en mode Insertion en appuyant sur i. Faites les modifications nécessaires. Revenez en mode Normal en appuyant sur Esc. Sauvegardez et quittez en tapant :wq et appuyez sur Enter. Exemple pratique : Modifier le fichier /etc/hosts Le fichier /etc/hosts est utilisé pour associer des adresses IP à des noms de domaine. Voici comment le modifier :\nAvec Nano Ouvrez le terminal. Tapez sudo nano /etc/hosts. Ajoutez une nouvelle ligne avec l’adresse IP et le nom de domaine, par exemple : 127.0.0.1 monsite.local\rSauvegardez et quittez en appuyant sur Ctrl+O, puis Ctrl+X. Avec Vim Ouvrez le terminal. Tapez sudo vim /etc/hosts. Passez en mode Insertion en appuyant sur i. Ajoutez une nouvelle ligne avec l’adresse IP et le nom de domaine, par exemple : 127.0.0.1 monsite.local\rRevenez en mode Normal en appuyant sur Esc. Sauvegardez et quittez en tapant :wq et appuyez sur Enter.",
    "description": "Vim est un éditeur de texte puissant et flexible, souvent utilisé par les programmeurs et les administrateurs système. Il est basé sur un autre éditeur de texte appelé Vi, mais offre de nombreuses fonctionnalités supplémentaires.\nVim peut sembler intimidant au début, mais avec de la pratique, il devient un outil extrêmement puissant pour l’édition de texte.\nInstallation de Vim Pour installer Vim, vous pouvez utiliser le gestionnaire de paquets de votre système d’exploitation. Par exemple :",
    "tags": [],
    "title": "L'éditeur Vim et les fichiers de configuration",
    "uri": "/semaine8/cours/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "Plan de la leçon Théorie : Atelier :.",
    "description": "Plan de la leçon Théorie : Atelier :.",
    "tags": [],
    "title": "???",
    "uri": "/semaine9/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "Plan de la leçon **Théorie/Test :\nValidation de l’atelier #10 Atelier :\nInstallation de WSL et Ubuntu et VS Code",
    "description": "Plan de la leçon **Théorie/Test :\nValidation de l’atelier #10 Atelier :\nInstallation de WSL et Ubuntu et VS Code",
    "tags": [],
    "title": "WSL installation et manipulation (Ubuntu, VS Code)",
    "uri": "/semaine14/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e WSL installation et manipulation (Ubuntu, VS Code)",
    "content": "+++ title = “Installation et manipulation de WSL avec Ubuntu et VS Code” weight = 141 +++\nLe Windows Subsystem for Linux (WSL) est une fonctionnalité de Windows qui permet d’exécuter un environnement Linux directement sur un système Windows sans avoir besoin d’une machine virtuelle.\nNous allons voir comment installer et utiliser WSL avec Ubuntu et Visual Studio Code (VS Code).\nPrérequis Un PC sous Windows 10 (version 2004 ou ultérieure) ou Windows 11. Accès à une connexion Internet. 1. Activation de WSL Activer les fonctionnalités Windows :\nOuvrez “Panneau de configuration” \u003e “Programmes” \u003e “Activer ou désactiver des fonctionnalités Windows”. Cochez les cases suivantes : Sous-système Windows pour Linux Plateforme de machine virtuelle Cliquez sur “OK” et redémarrez votre PC. Installer WSL 2 :\nOuvrez PowerShell en mode administrateur. Exécutez la commande suivante pour définir WSL 2 comme version par défaut : wsl --set-default-version 2\r2. Installation d’Ubuntu sur WSL Installer Ubuntu :\nOuvrez le Microsoft Store. Recherchez “Ubuntu” et choisissez une version (par ex., “Ubuntu 22.04 LTS”). Cliquez sur “Installer”. Configurer Ubuntu :\nLancez l’application Ubuntu depuis le menu Démarrer. Créez un utilisateur et un mot de passe lors du premier démarrage. 3. Installation de Visual Studio Code Installer VS Code :\nTéléchargez et installez Visual Studio Code depuis le site officiel : code.visualstudio.com. Installer l’extension WSL :\nOuvrez VS Code. Accédez à l’onglet des extensions (icône de carré à gauche ou Ctrl+Shift+X). Recherchez et installez l’extension Remote - WSL. 4. Configuration de l’environnement Accéder à WSL depuis VS Code :\nLancez Ubuntu (WSL) et naviguez jusqu’à votre répertoire de projet ou créez-en un : mkdir mon_projet\rcd mon_projet\rTapez code . pour ouvrir VS Code directement dans ce répertoire. Configurer le terminal :\nDans VS Code, allez dans Fichier \u003e Préférences \u003e Paramètres. Recherchez “terminal.integrated.defaultProfile.windows” et sélectionnez “WSL” comme terminal par défaut. 5. Manipulation de l’environnement Ubuntu dans WSL Installer des outils de développement :\nUtilisez apt pour installer des packages : sudo apt update\rsudo apt install build-essential git curl\rCloner un projet Git :\nUtilisez la commande suivante pour cloner un projet : git clone https://github.com/utilisateur/projet.git\rExécuter un projet :\nPar exemple, pour un projet Node.js : sudo apt install nodejs npm\rnpm install\rnpm start\r6. Conseils et Astuces Partage de fichiers entre Windows et WSL : Les fichiers créés sous WSL sont accessibles dans l’explorateur Windows sous : \\\\wsl$\\Ubuntu\\. Performances : Pour des performances optimales, stockez vos fichiers de projet dans le système de fichiers Linux (dans WSL) plutôt que dans le système de fichiers Windows. Mises à jour : Pensez à mettre à jour régulièrement WSL et Ubuntu : sudo apt update \u0026\u0026 sudo apt upgrade\rConclusion Avec WSL, Ubuntu et VS Code, vous disposez d’un environnement puissant pour le développement sous Linux, tout en conservant la commodité de Windows.",
    "description": "+++ title = “Installation et manipulation de WSL avec Ubuntu et VS Code” weight = 141 +++\nLe Windows Subsystem for Linux (WSL) est une fonctionnalité de Windows qui permet d’exécuter un environnement Linux directement sur un système Windows sans avoir besoin d’une machine virtuelle.\nNous allons voir comment installer et utiliser WSL avec Ubuntu et Visual Studio Code (VS Code).\nPrérequis Un PC sous Windows 10 (version 2004 ou ultérieure) ou Windows 11. Accès à une connexion Internet. 1. Activation de WSL Activer les fonctionnalités Windows :",
    "tags": [],
    "title": "WSL installation et manipulation (Ubuntu, VS Code)",
    "uri": "/semaine14/cours/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/categories/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/tags/index.html"
  }
]
