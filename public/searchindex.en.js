var relearn_searchindex = [
  {
    "breadcrumb": "",
    "content": "Pondération : 2-2-2\nDescription du cours :\nLinux est le système d’exploitation qui constitue la colonne vertébrale des entreprises les plus puissantes et les plus innovantes au monde. Dès lors, l’étudiante ou l’étudiant sera initié aux principes de base des systèmes d’exploitation libre (Linux) et à l’installation et l’exploitation d’une distribution libre de Linux (p. ex. Fedora, Ubuntu, AlmaLinux, OpenSource).\nPour cela, l’étudiant ou l’étudiante devra exploiter l’interface graphique et la puissance de la ligne de commande pour gérer une station de travail, explorer les systèmes de fichiers et le partitionnement des disques, gérer les processus, l’automatisation des tâches et la programmation de scripts shell.\nObjectifs du cours : Effectuer l’installation et la gestion d’ordinateurs.",
    "description": "Pondération : 2-2-2\nDescription du cours :\nLinux est le système d’exploitation qui constitue la colonne vertébrale des entreprises les plus puissantes et les plus innovantes au monde. Dès lors, l’étudiante ou l’étudiant sera initié aux principes de base des systèmes d’exploitation libre (Linux) et à l’installation et l’exploitation d’une distribution libre de Linux (p. ex. Fedora, Ubuntu, AlmaLinux, OpenSource).",
    "tags": [],
    "title": "420-ZG4-MO Système d’exploitation Linux",
    "uri": "/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "Plan de la leçon Présentation du cours (plan de cours).\nPondération. Objectifs. Contexte d’apprentissage et méthodes pédagogiques. Evaluations formatives. Évaluations sommatives. Politiques institutionnelles (absences, retards, plagiat, etc.). Règlements en classe et hors classe. Théorie :\nGénéralités sur le système d’exploitation Linux. Atelier :\nInstallation de Linux sur une machine virtuelle.",
    "description": "Plan de la leçon Présentation du cours (plan de cours).\nPondération. Objectifs. Contexte d’apprentissage et méthodes pédagogiques. Evaluations formatives. Évaluations sommatives. Politiques institutionnelles (absences, retards, plagiat, etc.). Règlements en classe et hors classe. Théorie :\nGénéralités sur le système d’exploitation Linux. Atelier :\nInstallation de Linux sur une machine virtuelle.",
    "tags": [],
    "title": "Introduction à Linux",
    "uri": "/semaine1/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Introduction à Linux",
    "content": "Qu’est-ce qu’un système d’exploitation? Un système d’exploitation (SE) est un logiciel essentiel qui agit comme un intermédiaire entre l’utilisateur et le matériel de l’ordinateur. Il gère les ressources matérielles et logicielles de l’ordinateur et fournit des services communs pour les programmes informatiques. Voici quelques-unes de ses principales fonctions:\nGestion des ressources matérielles: Le système d’exploitation contrôle et coordonne l’utilisation du processeur, de la mémoire, des périphériques de stockage, et des périphériques d’entrée/sortie comme le clavier, la souris et l’écran.\nGestion des fichiers: Il organise les données en fichiers et dossiers, permettant aux utilisateurs de stocker, récupérer et manipuler des informations de manière efficace.\nGestion des processus: Le système d’exploitation gère l’exécution des programmes, en allouant du temps processeur et en assurant que les tâches s’exécutent sans conflit.\nInterface utilisateur: Il fournit une interface utilisateur, qui peut être en ligne de commande (CLI) ou graphique (GUI), permettant aux utilisateurs d’interagir facilement avec l’ordinateur.\nSécurité et gestion des utilisateurs: Le système d’exploitation protège les données et les ressources de l’ordinateur contre les accès non autorisés et permet la gestion des comptes utilisateurs.\nExemples de systèmes d’exploitation Windows: Développé par Microsoft, c’est l’un des systèmes d’exploitation les plus utilisés dans le monde. macOS: Développé par Apple, il est utilisé sur les ordinateurs Mac. Linux: Un système d’exploitation open-source utilisé principalement par les développeurs et les serveurs. Android: Utilisé principalement sur les smartphones et les tablettes. iOS: Le système d’exploitation d’Apple pour ses appareils mobiles comme l’iPhone et l’iPad. Pourquoi est-ce important? Le système d’exploitation est crucial car il permet à l’utilisateur d’exploiter pleinement les capacités de l’ordinateur sans avoir à gérer directement les complexités matérielles. Il offre une plateforme stable et sécurisée pour exécuter des applications et effectuer des tâches quotidiennes.\nQu’est-ce que Linux ? Définition\rLinux est un système d’exploitation puissant et flexible qui offre de nombreux avantages, notamment en termes de sécurité, de stabilité, et de personnalisation.\nQue ce soit pour un usage personnel, professionnel, ou pour des serveurs, Linux est une option solide et fiable.\nUn peu d’histoire 1991 : Créé par Linus Torvalds et est basé sur le système Unix. 1992 : Le noyau Linux a été re-licencié sous la licence publique générale GNU GPL (GNU’s Not Unix General Public Licence), ce qui a renforcé son statut de logiciel libre. 1994 : La version 1.0 du noyau Linux a été publiée, marquant une étape importante dans son développement. Depuis sa création, Linux est devenu l’un des systèmes d’exploitation les plus populaires, notamment pour les serveurs, les superordinateurs, et les appareils embarqués.\nCaractéristiques principales Open Source : Le code source de Linux est disponible gratuitement, permettant aux utilisateurs de le modifier et de le distribuer. Sécurité : Linux est réputé pour sa robustesse et sa sécurité. Les mises à jour régulières et la communauté active contribuent à maintenir un haut niveau de sécurité. Stabilité : Linux est connu pour sa stabilité et sa capacité à fonctionner pendant de longues périodes sans nécessiter de redémarrage. Personnalisation : Les utilisateurs peuvent personnaliser leur environnement Linux selon leurs besoins, grâce à une multitude de distributions et d’outils disponibles. Distributions Linux Définition\rUne distribution Linux est une version de Linux qui inclut le noyau Linux ainsi que divers logiciels et outils.\nVoici quelques-unes des distributions les plus populaires :\nUbuntu : Connue pour sa convivialité et son support communautaire.\nSite d’Ubuntu Fedora : Souvent utilisée par les développeurs et les administrateurs système.\nSite de Fedora Red Hat : L’une des premières distributions commerciales de Linux. Elle est particulièrement populaire dans les environnements d’entreprise.\nSite de Red Hat Debian : Réputée pour sa stabilité et sa large collection de logiciels.\nsite de Debian Arch Linux : Appréciée par les utilisateurs avancés pour sa flexibilité et sa simplicité.\nSite d’Arch Linux Utilisations de Linux Serveurs : Linux est largement utilisé pour les serveurs web, les serveurs de bases de données, et les serveurs de fichiers en raison de sa fiabilité et de sa sécurité. Superordinateurs : La majorité des superordinateurs dans le monde fonctionnent sous Linux. Appareils embarqués : De nombreux appareils, tels que les routeurs, les téléviseurs intelligents, et les smartphones (via Android), utilisent Linux. Postes de travail : Bien que moins courant que Windows ou macOS, Linux est utilisé par de nombreux développeurs et professionnels de l’informatique pour ses capacités de personnalisation et ses outils puissants. Répartition des SE chez les développeurs Répartition des systèmes d’exploitation pour le développement de logiciels dans le monde de 2018 à 2023\nAvantages Inconvénients Très souvent le même environnement que la machine de production (surtout pour la portion serveur d’une application) Accès très limité aux outils Microsoft : pas de Visual Studio, seulement VS Code et un support minimal pour C# Très facile d’installer des nouveaux outils de développement :\n$ dnf install nodejs\n$ dnf install nodejs Une bonne console (ligne de commande) est souvent un bon dépanneur pour un développeur (p.ex. les messages d’erreur sont souvent plus explicites à la ligne de commande que dans l’IDE) Plus facile d’automatiser des tâches de compilation et de tests Systèmes plus légers qui laissent la place aux outils de développement (p.ex. mon Linux prend moins de 1Go de mémoire, alors le reste est pour les outils, VM, etc.). Dans le cours Android p.ex., l’environnement de développement prend 15Go de mémoire (pour l’IDE + deux émulateurs de téléphone). Part de marché des SE pour les serveurs Part de marché des systèmes d’exploitation pour les serveurs",
    "description": "Qu’est-ce qu’un système d’exploitation? Un système d’exploitation (SE) est un logiciel essentiel qui agit comme un intermédiaire entre l’utilisateur et le matériel de l’ordinateur. Il gère les ressources matérielles et logicielles de l’ordinateur et fournit des services communs pour les programmes informatiques. Voici quelques-unes de ses principales fonctions:\nGestion des ressources matérielles: Le système d’exploitation contrôle et coordonne l’utilisation du processeur, de la mémoire, des périphériques de stockage, et des périphériques d’entrée/sortie comme le clavier, la souris et l’écran.",
    "tags": [],
    "title": "Qu'est-ce que Linux ?",
    "uri": "/semaine1/cours/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Introduction à Linux",
    "content": "Objectifs Installation du logiciel de virtualisation VMware workstation Pro. Création d’une machine virtuelle (VM). Installation de Linux sur la VM. Prérequis pour l’atelier Avoir Windows 11 installé sur votre disque SSD (sur une seule partition). Télécharger un logiciel de virtualisation tel que VMWare Workstation Pro 17. Télécharger la dernière version d’Almalinux (janvier 2025 c’est la version 9.5). Rappels (Cours ZE5 Virtualisation) VMWare permet d’installer différents systèmes d’exploitation sur une même machine. Le nombre de machines virtuelles (VM) que l’on peut installer dépend de la puissance en terme de CPU et de mémoire de la machine hôte. La machine hôte est celle qui héberge les machines virtuelles aussi appelées les invités. La machine hôte peut être Windows ou Linux et les invités peuvent être une grande variété de systèmes d’exploitation. Format de la remise Attention\rVous devrez prendre des captures d’écran de vos installations. Pour plus de détails, voir les documents ci-dessous:.\nAtelier Étape 1: Réinstallation de Windows Utiliser la procédure obtenue dans le cours 420-ZC5-MO de la session d’automne.\nAttention\rVous devez installer Windows 11 et sur une seule partition.\nÉtape 2: Téléchargement et installation de VMWare sur la machine hôte (votre SSD Windows) Guide - Téléchargement WMWare\nGuide - Installation de VMWare\nÉtape 3: Création d’une VM et installation d’Almalinux Télécharger l’image d’Almalinux Site Almalinux\nNote\rChoisir AlmaLinux OS 9.5 DVD ISO\nVous obtiendrez le fichier AlmaLinux-9.5-x86_64-dvd.iso\nCréer une VM pour y installer Almalinux Attention\rNe pas sauvegarder le fichier .iso sur OneDrive, ni dans le répertoire Téléchargements (Downloads), Sauvegardez le sur votre disque dur (en général c’est le lecteur C:).\nGuide - Création d’une VM Almalinux\nEn cas de problème Cas #1: Il arrive parfois que le serveur X ne démarre pas dans le temps imparti, ce qui force l’installation à basculer en mode texte. Vous le résolvez en augmentant le délai avec inst.xtimeout=180 en début d’installation.\nPour résoudre le problème:\nmenu installation - choisir troubleshooting touche tab ajouter inst.xtimeout=valeur en seconde en bas ( comme l’image ci bas) Cas #2: Si le processus d’installation exécute le Check et que c’est très long, il suffit d’appuyer plusieurs fois sur la touche Esc pour sauter la vérification et poursuivre l’installation.\nCas #3: Sur certains postes/SSD, la configuration ci-dessous règle les problèmes encourus pendant l’installation d’Almalinux.\nConfiguration de la VM:\n40 Gb au lieu de 20 Gb 4096 en mémoire 1 processeur et 4 Coeurs",
    "description": "Objectifs Installation du logiciel de virtualisation VMware workstation Pro. Création d’une machine virtuelle (VM). Installation de Linux sur la VM. Prérequis pour l’atelier Avoir Windows 11 installé sur votre disque SSD (sur une seule partition). Télécharger un logiciel de virtualisation tel que VMWare Workstation Pro 17. Télécharger la dernière version d’Almalinux (janvier 2025 c’est la version 9.5). Rappels (Cours ZE5 Virtualisation) VMWare permet d’installer différents systèmes d’exploitation sur une même machine. Le nombre de machines virtuelles (VM) que l’on peut installer dépend de la puissance en terme de CPU et de mémoire de la machine hôte. La machine hôte est celle qui héberge les machines virtuelles aussi appelées les invités. La machine hôte peut être Windows ou Linux et les invités peuvent être une grande variété de systèmes d’exploitation. Format de la remise Attention\rVous devrez prendre des captures d’écran de vos installations. Pour plus de détails, voir les documents ci-dessous:.",
    "tags": [],
    "title": "ATELIER #1: Installation de Linux sur une VM",
    "uri": "/semaine1/atelier/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "Plan de la leçon Théorie :\nLe système de fichiers de Linux. Le Shell Bash. La ligne de commandes. Les commandes de base. Introduction à VIM. Atelier :\nUtilisation des commandes de base et Vim.",
    "description": "Plan de la leçon Théorie :\nLe système de fichiers de Linux. Le Shell Bash. La ligne de commandes. Les commandes de base. Introduction à VIM. Atelier :\nUtilisation des commandes de base et Vim.",
    "tags": [],
    "title": "Système de fichiers, Shell, commandes de base, Vim",
    "uri": "/semaine2/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Système de fichiers, Shell, commandes de base, Vim",
    "content": "La structure du système de fichiers Linux est hiérarchique et organisée sous la forme d’un arbre inversé, où la racine (root) est représentée par /. Tous les fichiers et répertoires sont situés sous cette racine.\nLa structure du système de fichiers Linux est conçue pour être logique et organisée, facilitant ainsi la gestion et la navigation.\nComprendre cette structure est essentiel pour naviguer et gérer efficacement un système Linux.\nTout est fichier Sous Linux, TOUT les éléments visibles dans l’arborescence du système de fichiers sont des fichiers.\nUn fichier est un fichier Un répertoire est un fichier Une clé USB est un fichier Une partition est un fichier Un disque dur est un fichier etc. Répertoires principaux Important\rChaque répertoire a un rôle spécifique et contient des types de fichiers bien définis.\n/ (Racine) Le point de départ de l’arborescence du système de fichiers. Tous les autres répertoires et fichiers sont situés sous ce répertoire. /bin Contient les binaires essentiels nécessaires au démarrage du système et à l’exécution des commandes de base, comme ls, cp, mv, etc. /boot Contient les fichiers nécessaires au démarrage du système, y compris le noyau Linux et les fichiers de configuration du chargeur de démarrage (bootloader). /dev Contient les fichiers de périphériques. Chaque périphérique matériel (comme les disques durs, les clés USB, etc.) est représenté par un fichier dans ce répertoire. /etc Contient les fichiers de configuration du système. Par exemple, les fichiers de configuration des services, des utilisateurs, des réseaux, etc. /home Contient les répertoires personnels des utilisateurs. Chaque utilisateur a son propre répertoire sous /home, par exemple /home/ndesmangles. /lib Contient les bibliothèques partagées nécessaires pour les binaires situés dans /bin et /sbin. /media Point de montage pour les périphériques amovibles comme les CD-ROM, les clés USB, etc. /mnt Utilisé pour monter temporairement des systèmes de fichiers. Par exemple, pour monter un disque dur externe. /opt Contient les logiciels optionnels et les paquets additionnels qui ne sont pas inclus dans la distribution standard. /proc Système de fichiers virtuel qui contient des informations sur les processus en cours et le système. Par exemple, /proc/cpuinfo contient des informations sur le processeur. /root Répertoire personnel de l’utilisateur root (administrateur du système). /run Contient des informations sur l’état du système depuis le dernier démarrage. Utilisé pour stocker des fichiers temporaires nécessaires au fonctionnement du système. /sbin Contient les binaires essentiels pour l’administration du système, comme fdisk, ifconfig, etc. /srv Contient les données spécifiques aux services fournis par le système. Par exemple, les fichiers de données pour un serveur web peuvent être stockés ici. /tmp Contient les fichiers temporaires créés par les utilisateurs et les applications. Ce répertoire est souvent vidé au redémarrage du système. /usr Contient les applications et les fichiers utilisés par les utilisateurs. Sous-répertoires importants : /usr/bin : Contient les binaires des applications utilisateur. /usr/lib : Contient les bibliothèques partagées pour les applications utilisateur. /usr/local : Contient les logiciels installés localement par l’administrateur du système. /var Contient les fichiers variables, tels que les journaux système, les fichiers de spool, et les fichiers temporaires des applications. Par exemple, /var/log contient les fichiers journaux. Les chemins absolu et relatif Chemin absolu Un chemin absolu est un chemin complet qui commence à la racine du système de fichiers. Il indique l’emplacement exact d’un fichier ou d’un répertoire, peu importe où vous vous trouvez dans le système de fichiers. Par exemple :\n/home/utilisateur/Documents/fichier.txt\rDans cet exemple, le chemin commence par /, qui est la racine du système de fichiers, et suit l’arborescence jusqu’au fichier fichier.txt.\nChemin relatif Un chemin relatif, quant à lui, est un chemin qui est relatif à votre répertoire de travail actuel. Il ne commence pas par /. Par exemple, si vous êtes dans le répertoire /home/utilisateur, et que vous voulez accéder à fichier.txt dans le sous-répertoire Documents, vous pouvez utiliser :\nDocuments/fichier.txt\rOu, si vous voulez remonter d’un niveau dans l’arborescence, vous pouvez utiliser .. pour représenter le répertoire parent. Par exemple, si vous êtes dans /home/utilisateur/Documents et que vous voulez accéder à un fichier dans /home/utilisateur, vous pouvez utiliser :\n../fichier.txt\rEn résumé\nChemin absolu : Commence à la racine / et donne l’emplacement complet. Chemin relatif : Dépend de votre répertoire de travail actuel et ne commence pas par /. Qu’est-ce que le SHELL? Le terme Shell désigne un programme qui interprète les commandes que vous tapez et les exécute. Il existe plusieurs types de shells, comme le Bourne Shell (sh), le C Shell (csh), le Korn Shell (ksh), et bien d’autres.\nLe shell Bash Bash (Bourne Again Shell) est le shell par défaut sur de nombreuses distributions Linux. Il agit comme une interface entre l’utilisateur et le système d’exploitation, permettant d’exécuter des commandes, des scripts, et d’automatiser des tâches.\nFonctionnalités clés de Bash Historique des commandes : Bash conserve un historique des commandes entrées, ce qui permet de les réutiliser facilement. Redirection : Les flux d’entrée et de sortie peuvent être redirigés pour enregistrer des résultats ou chaîner des commandes. Variables : Bash prend en charge les variables, qui peuvent stocker des données pour une utilisation ultérieure. Alias : Vous pouvez créer des alias pour simplifier des commandes longues ou fréquemment utilisées. La ligne de commande La ligne de commande est l’interface où vous tapez vos commandes. Elle est souvent représentée par un symbole $ ou #:\n$ signifie que vous êtes un utilisateur standard # signifie que vous êtes le super-utilisateur root (administrateur du système). ~ signifie le répertoire personnel, les symboles $ et # seront précédés du symbole tilde: ~$ ou ~#. Une commande dans le shell suit généralement cette structure :\ncommande [options] [arguments]\rcommande : Le programme ou l’outil que vous souhaitez exécuter. options : Des paramètres supplémentaires qui modifient le comportement de la commande. arguments : Les cibles sur lesquelles la commande doit agir (fichiers, répertoires, etc.). Lorsque vous êtes prêt à exécuter une commande, appuyez sur la touche Entrée. Tapez chaque commande sur une ligne séparée. Le résultat de la commande est affiché avant l’invite du shell suivante.\nExemple de commande sans option :\n[ndesmangles@localhost ~]$ whoami ndesmangles [ndesmangles@localhost ~]$\rExemple de commande avec une option :\n[ndesmangles@localhost ~]$ date -R Fri, 17 Jan 2025 20:19:50 -0500 [ndesmangles@localhost ~]$ date +%R 20:19 Pour exécuter une commande avec des privilèges de super-utilisateur (root), on la précède de sudo:\n[ndesmangles@localhost ~]$ sudo ls /root\rCommandes de base en Bash Bash propose une variété de commandes puissantes pour interagir avec le système. Ces commandes de base sont essentielles pour naviguer, gérer des fichiers, et interagir avec votre système sous Bash.\nNavigation dans le système de fichiers Les commandes :\npwd (Print Working Directory) cd (Change Directory) ls (List) Commande Description Exemple pwd Affiche le chemin absolu du répertoire courant. /home/user $ pwd /home/user cd Change le répertoire courant pour Documents. /home/user $ cd Documents /home/user/Documents cd ~ Change vers le répertoire personnel de l’utilisateur. /home/user/Documents $ cd ~ /home/user cd .. Remonte d’un niveau dans l’arborescence des répertoires. /home/user/Documents $ cd .. /home/user cd ../../ Remonte de deux niveaux dans l’arborescence. /home/user/Documents/Projects $ cd ../../ /home/user ls Affiche le contenu d’un répertoire. /home/user/Documents $ ls fichier.txt dossier ls -l Affiche la liste des fichiers dans un répertoire. L’option -l affiche les détails des fichiers dans un répertoire. /home/user/Documents $ ls -l -rw-r--r-- 1 user user 1234 Jan 1 12:00 fichier.txt Quelques explications du résultat de ls -l Premier caractère: -, d ou l représente le type de fichier (fichier standard, répertoire ou lien symbolique respectivement) Neuf caractères suivants: par exemple rwxr-xr-x représentent les droits d’accès au fichier/répertoire (abordés en détail dans un prochain cours). Bon à savoir\rLa commande clear permet d’effacer l’écran du terminal.\nManipulation de fichiers et répertoires Les commandes :\ntouch mkdir (Make Directory) rm (Remove) : rmdir (Remove Directory) cp (Copy) mv (Move) Commande Description Exemple touch Crée un fichier vide ou met à jour la date de modification d’un fichier existant. /home/user $ touch fichier.txt $ ls fichier.txt mkdir Crée un nouveau répertoire. /home/user $ mkdir mon_dossier $ ls mon_dossier rm Supprime des fichiers. Utilisez -r pour supprimer des répertoires et leur contenu. /home/user $ rm fichier.txt $ rm -r mon_dossier rmdir Supprime un répertoire vide (ne fonctionne pas s’il contient des fichiers). $ rmdir mon_dossier cp Copie des fichiers ou des répertoires (avec -r pour copier des dossiers entiers). $ cp fichier.txt copie.txt $ ls fichier.txt copie.txt $ cp -r mon_dossier copie_dossier $ ls mon_dossier copie_dossier mv Déplace ou renomme des fichiers et des répertoires. $ mv fichier.txt nouveau_nom.txt $ ls nouveau_nom.txt Affichage et lecture de fichiers Les commandes :\ncat less head tail Commande Description Exemple cat Affiche le contenu complet d’un ou de plusieurs fichiers. $ cat fichier.txt $ cat fichier1.txt fichier2.txt less Permet de lire un fichier page par page. Contrôles : Espace : Page suivante q : Quitter $ less fichier.txt head Affiche les premières lignes d’un fichier. 10 lignes par défaut. L’option -n permet de spécifier le nombre de lignes $ head fichier.txt $ head -n 5 fichier.txt tail Affiche les dernières lignes d’un fichier. 10 lignes par défaut. L’option -n permet de spécifier le nombre de lignes $ tail fichier.txt $ tail -n 5 fichier.txt Informations système et historique Commande Description Exemple date Affiche la date et l’heure actuelles. $ date Thu Jan 9 20:42:36 EST 2025 $ date \"+%Y-%m-%d %H:%M:%S\" 2025-01-09 20:42:43 history Liste les commandes précédemment exécutées. Options utiles : n : Pour spécifier le nombre de commandes précédentes à afficher. ! : Pour exécuter une commande spécifique de l’historique, par son numéro. c : Pour effacer l’historique de la session. $ history $ history 5 $ history -c Commande date quelques options utiles :\n+ : Il faut précéder l’option du symbole + pour spécifier un format personnalisé. Formats: %Y : Année complète (ex. 2025). %m : Mois (01-12). %d : Jour (01-31). %H : Heure (00-23). %M : Minutes (00-59). %S : Secondes (00-59). %r : Heure au format 12h (ex. 11:11:04 PM) %R : Heure au format 24h (ex. 23:11 sans les secondes) %p : Heure avec AM ou PM Exemples avec la commande history :\n[ndesmangles@localhost ~]$ history\t# Affiche l'historique complet de la session. 1 date -R 2 pwd 3 cd /etc 4 cd .. 5 cd etc 6 cd ../.. 7 ls 8 ls -a 9 ls -l 10 date 11 date \"+%Y-%m-%d %H:%M:%S\" 12 cd ~ 13 history [ndesmangles@localhost ~]$ history 5\t# Affiche les 5 dernières commandes effectuées. 10 date 11 date \"+%Y-%m-%d %H:%M:%S\" 12 cd ~ 13 history 14 history 5 [ndesmangles@localhost ~]$ !11\t# Exécute la commande #11 dans l'historique date \"+%Y-%m-%d %H:%M:%S\" 2025-01-09 20:47:03 [ndesmangles@localhost ~]$ !da\t# Exécute la commande la plus récente, dont le nom commence par 'da'. date \"+%Y-%m-%d %H:%M:%S\"\t2025-01-18 20:48:22\t[ndesmangles@localhost ~]$ history -c\t# Efface l'historique. [ndesmangles@localhost ~]$ history 1 history\rCommandes utiles echo man (Manual) Commande Description Exemple echo Affiche un message ou une variable dans le terminal. $SHELL doit être écrit en respectant la casse. $ echo \"Bonjour, monde!\" Bonjour, monde! $ echo $SHELL /bin/bash man Affiche le manuel d’aide pour une commande. $ man ls Structure d’une page de manuel Une page de manuel typique contient plusieurs sections, telles que :\nNAME : Le nom de la commande et une brève description. SYNOPSIS : La syntaxe de la commande. DESCRIPTION : Une description détaillée de la commande et de ses options. OPTIONS : Les options disponibles pour la commande. EXAMPLES : Des exemples d’utilisation. SEE ALSO : Des références à d’autres commandes ou documents pertinents. Options utiles man -k keyword : Recherche des pages de manuel contenant le mot-clé spécifié. man -f command : Affiche une brève description de la commande (équivalent à whatis command). Autocompletion d’une commande Bash La touche Tab du clavier, permet de compléter rapidement les commandes et les noms de fichiers après avoir entré un nombre de caractères suffisant pour réduire les possibilités à une seule. Si les caractères saisis ne sont pas uniques, appuyez deux fois sur la touche de tabulation pour afficher toutes les commandes correspondantes. [ndesmangles@localhost ~]$ cat /etc/serTab\t# `cat /etc/ser` suivi de la touche `Tab` complète le nom du fichier. [ndesmangles@localhost ~]$ cat /etc/services [ndesmangles@localhost ~]$ passTabTab\t# `pass` suivi de 2 fois la touche `Tab` propose les commande dont le nom commence par `pass`. passt passt.avx2 passwd [ndesmangles@localhost ~]$ pass\rIntroduction à l’éditeur de texte VIM VIM (Vi IMproved) est un éditeur de texte, souvent utilisé dans les environnements Unix/Linux. Bien qu’il puisse sembler intimidant au premier abord, il devient très efficace une fois maîtrisé.\nPourquoi utiliser vim ? Disponibilité : Installé par défaut sur presque tous les systèmes Unix/Linux. Léger et rapide : Idéal pour éditer des fichiers même sur des systèmes limités en ressources. Puissant : Supporte des fonctionnalités avancées comme la recherche, la substitution, et l’édition de plusieurs fichiers simultanément. Premiers pas avec vim Pour ouvrir un fichier avec vim, utilisez la commande suivante :\n$ vim nom_du_fichier\rSi le fichier n’existe pas, vim le créera.\nLorsque vous ouvrez vim, il commence en mode commande. Vous ne pouvez pas directement écrire du texte. Vous devez d’abord passer au mode insertion en tapant la lettre i. En bas de la fenêtre Vim, le mot INSERTION s’affichera.\nRevenir au mode Normal\rSi avant de taper i ou n’importe quel autre mode, vous n’êtes plus dans le mode Normal, il suffit de tapper la touche ESC pour revenir au mode Normal.\nModes principaux de vim Ces modes sont les bases du fonctionnement de vim. Vous pouvez basculer entre eux selon vos besoins pour éditer et manipuler vos fichiers.\nMode Description Action Commande Normal Mode par défaut lorsque vous ouvrez vim. Appuyez sur Esc pour revenir à ce mode. ESC Insertion Permet d’insérer ou de modifier du texte. Passer en mode insertion où se trouve le curseur. i Commande Permet de sauvegarder un fichier. Sauvegarde :w Permet de quitter Vim, si aucun changement n’a été effectué dans le fichier en cours. Quitter :q Permet de forcer la fermeture de vim sans sauvegarder les modifications. Quitter sans sauvegarder les modifications. :q! Permet de sauvegarder et fermer le fichier. Sauvegarde et quitter. :wq Exercices pratiques Ouvrez un fichier nommé test.txt avec la commande :\n$ vim test.txt\rPassez en mode insertion (i), écrivez quelques lignes, puis sauvegardez et quittez avec :wq.\nRecherchez du texte : Ouvrez un fichier existant, cherchez un mot avec /mot, puis naviguez entre les occurrences avec n.\nTestez l’annulation : Modifiez une ligne, annulez avec u, puis rétablissez avec Ctrl+r.",
    "description": "La structure du système de fichiers Linux est hiérarchique et organisée sous la forme d’un arbre inversé, où la racine (root) est représentée par /. Tous les fichiers et répertoires sont situés sous cette racine.\nLa structure du système de fichiers Linux est conçue pour être logique et organisée, facilitant ainsi la gestion et la navigation.\nComprendre cette structure est essentiel pour naviguer et gérer efficacement un système Linux.",
    "tags": [],
    "title": "Système de fichiers, Shell et commandes de base et VIM",
    "uri": "/semaine2/cours/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Système de fichiers, Shell, commandes de base, Vim",
    "content": "Objectifs de l’atelier Se familiariser avec la ligne de commandes. Naviguer dans l’arborescence Linux à l’aide de commandes. Gerer des fichiers et répertoires à l’aide de commandes. Format de la remise sur Moodle Attention\rPour chaque exercice, vous devrez prendre une capture d’écran. Sur les captures, on doit pouvoir voir : Votre nom d’utilisateur (Ne travaillez donc pas avec l’utilisateur root, ni la commande sudo). La ligne de commande et la commande. Le résultat de la commande. Si le résultat fait plus de 10 lignes, capturer juste les 10 premières lignes. Nommer les fichiers image, tel qu’indiqué pour chaque question. Remettre toutes vos images dans 1 seul fichier compressé (ex:.zip). Tout autre format ne sera pas corrigé. Pour l’exercice #3, quelques questions devront ètre répondues dans un fichier texte à remettre sur Moodle en plus du .zip. Atelier Préparation Sur votre machine Almalinux, avec votre utilisateur standard, allez sur votre cours sur Moodle, dans la semaine 2. On vous demande de télécharger le fichier fichier.txt. Vous en aurez besoin pour l’exercice #3.\nCliquez sur fichier1. Sur la fenêtre qui s’ouvre, faites un clic droit et choisissez Enregistrez-sous. Le fichier va être enregistré par défaut dans le dossier Téléchargements. Fermer la fenêtre.\nCliquez sur le bouton Activités sur le bureau.\nCliquer sur l’icône Fichiers. Attention\rAvant de commencer chaque exercice, assurez vous que vous travaillez dans votre répertoire personnel et ne vous déplacez pas que lorsque demandé. À moins d’indication contraire, utiliser TOUJOURS des chemins relatifs. Allez maintenant sur votre terminal. Placez-vous dans votre répertoire personnel.\nExercice 1 : Explorer l’arborescence Linux Afficher le chemin de votre répertoire courant. Prendre une capture d’écran et nommez-la 1-1.png. Allez dans le répertoire /usr/share/doc, puis vérifiez le chemin de votre répertoire courant. Prendre une capture d’écran et nommez-la 1-2.png. Remontez dans le répertoire parent. Prendre une capture d’écran et nommez-la 1-3.png. Allez dans votre répertoire personnel. Prendre une capture d’écran et nommez-la 1-4.png. Listez les fichiers présents du répertoire courant. Prendre une capture d’écran et nommez-la 1-5.png. Toujours en étant dans votre dossier personnel, listez les fichiers du répertoire /usr. Prendre une capture d’écran et nommez-la 1-6.png. Exercice 2: Commandes Linux simples Commande date\nAfficher la date et l’heure actuelles du système. Afficher l’heure actuelle sur une horloge de douze heures (par exemple, 11:42:11 AM). Prendre une capture d’écran et nommez-la 2-1.png. Commande head\nAffichez les 10 premières lignes du fichier /etc/services Prendre une capture d’écran et nommez-la 2-2.png. Commande tail\nAffichez les 10 dernières lignes du fichier /etc/services. Prendre une capture d’écran et nommez-la 2-3.png. Commande tail\nRépéter la commande précédente avec exactement trois frappes de touches. Prendre une capture d’écran et nommez-la 2-4.png. Commande tail et les flèches vers le haut et vers la gauche\nRépéter la commande précédente, mais afficher les 20 dernières lignes du fichier. Prendre une capture d’écran et nommez-la 2-5.png. Commande history\nUtiliser l’historique du shell pour exécuter à nouveau la commande effectuée pour la question #3 Prendre une capture d’écran et nommez-la 2-6.png. Exercice 3: Commandes de base Important\rUtilisez pas l’interface graphique d’Almalinux QUE LORSQUE demandé (#6). Autrement, utilisez uniquement des commandes pour répondre aux questions. Après chaque question (sauf #6, #12a, #15 à #20), n’oubliez pas de prendre une capture d’écran et de la nommer 3-X.png où X est le numéro de la question. Créer un répertoire Atelier2 dans le répertoire courant. Copier le fichier téléchargé fichier.txt dans le répertoire Atelier2. Créer un autre répertoire nommé Rep2. Déplacer Atelier2 dans Rep2. Déplacez-vous dans Atelier2. Avec vim, ouvrez le fichier fichier.txt et écrivez écrivez votre nom complet dans le fichier. Enregistrer la modification et fermer le fichier. Afficher le contenu du fichier à l’aide de la commande cat. Créer un autre fichier nommé fichier2.txt dans Atelier2. Avec une seule commande cat afficher le contenu de fichier.txt et fichier2.txt. Revenir dans votre répertoire personnel. Supprimer le répertoire Rep2. a) Dans quel répertoire vous trouvez-vous? b) Utiliser une commande pour voir le répertoire courant. Créer un dossier avec le nom Rep3 dans le dossier /root(en utilisant un chemin absolu). Avez-vous réussi ? Si non, pourquoi ? Afficher le contenu du répertoire /etc en utilisant l’option -l. Par quels caractères, les lignes affichées débutent ? Quelles est leur signification ? Qu’est-ce qui distingue le répertoire /proc des autres répertoires de l’arborescence linux ? Qu’est ce qui distingue le répertoire /bin et /sbin ? Quel est le répertoire qui est utilisé pour charger le noyau du système d’exploitation au démarrage ? Dans Linux, tout est fichier. Si on connecte une clé usb à une machine linux, dans quel répertoire de l’arborescence, on va trouver la référence à cette clé ? Si on installe un serveur web apache sur une machine linux, dans quel répertoire de l’arborescence le dossier contenant les fichiers de configuration du serveur se trouvera-t-il ?",
    "description": "Objectifs de l’atelier Se familiariser avec la ligne de commandes. Naviguer dans l’arborescence Linux à l’aide de commandes. Gerer des fichiers et répertoires à l’aide de commandes. Format de la remise sur Moodle Attention\rPour chaque exercice, vous devrez prendre une capture d’écran. Sur les captures, on doit pouvoir voir : Votre nom d’utilisateur (Ne travaillez donc pas avec l’utilisateur root, ni la commande sudo). La ligne de commande et la commande. Le résultat de la commande. Si le résultat fait plus de 10 lignes, capturer juste les 10 premières lignes. Nommer les fichiers image, tel qu’indiqué pour chaque question. Remettre toutes vos images dans 1 seul fichier compressé (ex:.zip). Tout autre format ne sera pas corrigé. Pour l’exercice #3, quelques questions devront ètre répondues dans un fichier texte à remettre sur Moodle en plus du .zip. Atelier Préparation Sur votre machine Almalinux, avec votre utilisateur standard, allez sur votre cours sur Moodle, dans la semaine 2. On vous demande de télécharger le fichier fichier.txt. Vous en aurez besoin pour l’exercice #3.",
    "tags": [],
    "title": "ATELIER #2: Commandes Linux de base",
    "uri": "/semaine2/atelier/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e WSL installation et manipulation (Ubuntu, VS Code)",
    "content": "Objectifs de l’atelier Cet atelier a pour but de vous familiariser avec la ligne de commandes en utilisant Ubuntu comme distribution Linux.\nFormat de la remise Attention\rPour chacune des étapes des parties 2 et 3 vous devrez prendre une capture d’écran de vos commandes et résultats. ATTENTION: On doit pouvoir voir votre nom d’utilisateur. Ne travaillez donc pas avec l’utilisateur root.\nAtelier Partie 1: Installations WSL (Windows Subsystem for Linux) Rechercher les fonctionnalités Windows Dans la liste, cocher Sous-Système Windows pour Linux Redémarrer Une fois redémarré, vous pouvez installer la distribution Ubuntu depuis le Microsoft Store.\nPartie 2: Installation d’Ubuntu WSL prend en charge une variété de distributions Linux, y compris la dernière version LTS d’Ubuntu.\nIl existe plusieurs façons d’installer des distributions sur WSL, nous nous concentrons ici sur la méthode via l’application dans Microsoft Store et les commandes WSL exécutées dans le terminal. Le résultat est le même quelle que soit la méthode.\nApplication dans Microsoft Store\nOuvrir Microsoft Store et trouver la dernière version d’Ubuntu. Cliquez sur Free/Gratuit, puis sur Get/Obtenir. Patienter durant l’installation. Ubuntu sera alors installé sur votre machine.\nAvant de commencer, s’assurer qu’Ubuntu est à jour:\n$ sudo apt update\rPrenez une capture d’écran de la fenêtre de la commande avec le résultat et nommez-la 1.png. NOTE: La commande sudo permet d’exécuter une commande en tant qu’administrateur du système.\nUne fois installé, vous pouvez soit lancer l’application directement depuis le Microsoft Store, soit rechercher Ubuntu dans votre barre de recherche Windows.\nPrenez une capture d’écran de la fenêtre de terminal Ubuntu et nommez-la 2.png. References:\nSite Ubuntu WSL Vidéo YouTube",
    "description": "Objectifs de l’atelier Cet atelier a pour but de vous familiariser avec la ligne de commandes en utilisant Ubuntu comme distribution Linux.\nFormat de la remise Attention\rPour chacune des étapes des parties 2 et 3 vous devrez prendre une capture d’écran de vos commandes et résultats. ATTENTION: On doit pouvoir voir votre nom d’utilisateur. Ne travaillez donc pas avec l’utilisateur root.\nAtelier Partie 1: Installations WSL (Windows Subsystem for Linux) Rechercher les fonctionnalités Windows",
    "tags": [],
    "title": "ATELIER #2: WSL, Ubuntu et des commandes Linux simples",
    "uri": "/semaine14/atelier/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "Plan de la leçon Théorie :\nLa séquence de démarrage de Linux. Les cibles (niveaux d’exécution). Les variables utilisateur. Itération avec la boucle FOR. Atelier :\nGestion des cibles. Création et utilisation de variables. Utilisation de la boucle FOR.",
    "description": "Plan de la leçon Théorie :\nLa séquence de démarrage de Linux. Les cibles (niveaux d’exécution). Les variables utilisateur. Itération avec la boucle FOR. Atelier :\nGestion des cibles. Création et utilisation de variables. Utilisation de la boucle FOR.",
    "tags": [],
    "title": "Processus de démarrage, variables et FOR",
    "uri": "/semaine3/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Processus de démarrage, variables et FOR",
    "content": "Le processus de démarrage Le processus de démarrage d’un système Linux suit plusieurs étapes essentielles, impliquant différents composants du système :\nÉtape Description 1. Activation du BIOS/UEFI Au démarrage, le BIOS (Basic Input Output System) ou l’UEFI (Unified Extensible Firmware Interface) s’active. Il vérifie le matériel et cherche le secteur de démarrage sur le disque (MBR ou GPT). 2. Chargement du chargeur d’amorçage Le MBR (Master Boot Record) définit le chargeur de démarrage, comme GRUB (GRand Unified Bootloader). GRUB affiche un menu permettant de choisir le système à démarrer. 3. Chargement du noyau Linux (Kernel) Après sélection de Linux, GRUB charge le noyau, qui initialise les pilotes, périphériques et la gestion de la mémoire. Il charge aussi un disque temporaire (initrd ou initramfs) contenant les modules nécessaires au démarrage. 4. Lancement du processus d’initialisation (init ou systemd) Le noyau lance le premier processus du système : init ou systemd (selon la distribution Linux). Ce processus démarre les services et scripts de configuration (réseau, interface graphique, gestion des utilisateurs, etc.). 5. Affichage de l’écran de connexion Une fois les services chargés, l’écran de connexion s’affiche, demandant un nom d’utilisateur et un mot de passe. 6. Utilisation du système Après authentification, vous pouvez utiliser Linux, lancer des applications et exécuter des commandes. Vous pouvez aussi arrêter ou redémarrer votre système avec shutdown, reboot ou halt. Les niveaux d’exécution (Runlevels) et cibles (Targets) Autrefois, Linux utilisait des niveaux d’exécution (runlevels), qui définissaient les services actifs selon le mode de fonctionnement. Avec systemd, ces niveaux sont remplacés par des cibles (targets). Cependant, la compatibilité avec les anciens niveaux est conservée.\nChanger temporairement le niveau d’exécution Utilisez la commande suivante pour modifier le niveau d’exécution temporairement :\n$ systemctl isolate \u003cnom_niveau\u003e\rCorrespondance entre les niveaux d’exécution et les cibles systemd Niveau d’exécution Cible systemd Description Commande associée 0 poweroff Arrêt du système $ systemctl isolate poweroff 1 rescue Mode utilisateur unique (maintenance) $ systemctl isolate rescue 3 multi-user Mode multi-utilisateur (ligne de commande) $ systemctl isolate multi-user 5 graphical Mode graphique complet $ systemctl isolate graphical 6 reboot Redémarrage du système $ systemctl isolate reboot Afficher et modifier le niveau d’exécution Pour afficher le niveau d’exécution actuel utiliser la commande who -r :\n$ who -r niveau d'exécution 5 2025-02-01 10:09 $ runlevel N 5\rÀ propos de Runlevel\rLa commande runlevel affiche deux valeurs : le niveau précédent et le niveau d’exécution actuel. Ici, N indique qu’il n’y avait pas de niveau précédent (au démarrage), et 5 est le niveau actuel graphique.\nCommande Description Exemple systemctl get-default Affiche le niveau d’exécution par défaut. $ systemctl get-default graphical.target systemctl set-default \u003cnom_niveau\u003e Modifie le niveau d’exécution par défaut. $ systemctl set-default multi-user systemctl default Revient au niveau d’exécution par défaut. $ systemctl default systemctl isolate default Bascule immédiatement vers le niveau d’exécution par défaut. $ systemctl isolate default Difference entre isolate et set-default\rLa différence entre les commandes est que la commande avec “isolate” est exécutée immédiatement, tandis que la commande avec “set-default” spécifie la cible obtenue après le redémarrage.\nSubstitution de commande La substitution de commande permet d’exécuter une commande et d’utiliser directement son résultat dans une autre commande.\nSyntaxe : $(commande)\rExemple 1 :\nBash exécute d’abord la commande whoami pour obtenir le nom de l’utilisateur, remplace $(whoami) par ce résultat, puis exécute touch pour créer un fichier portant ce nom.\n$ touch $(whoami).txt $ ls bonjour.txt Documents groupe4 Images Musique ndesmangles.txt Téléchargements titi toto tutu Vidéos Bureau fichier.txt groupe6 Modèles nathalie.txt Public test titi.txt toto.txt tutu.txt\rExemple 2 :\nL’exemple ci-dessous affiche les fichiers du dossier personnel :\n$ echo \"Les fichiers de mon dossier personnel sont : $(ls)\" Les fichiers de mon dossier personnel sont : bonjour.txt Bureau Documents Images Modèles Musique ndesmangles.txt Public Téléchargements titi titi.txt toto toto.txt tutu tutu.txt Vidéos\rLes variables En Bash, il est possible de définir des variables. Certaines sont définies par le système au démarrage ou à l’ouverture de la session ; ce sont les variables d’environnement (ex: SHELL). Nous pouvons aussi créer nos propres variables (variables utilisateur).\nDéfinir une variable utilisateur Un utilisateur peut créer ou modifier ses propres variables.\nAttention\rIl ne faut pas mettre d’espace autour du =. Les noms sont sensibles à la casse: VAR1 ≠ var1\n$ variable=valeur\rExemples :\nUne variable peut contenir un booléen, une chaîne de caractères ou une valeur numérique :\n$ variable=true $ variable=\"Ceci est un texte\" $ variable=45\rAccéder au contenu d’une variable Pour afficher la valeur d’une variable, il faut la préfixer avec $ :\n$ echo $variable 45\rExpansion des variables L’expansion des variables permet d’utiliser une variable dans une commande en remplaçant son nom par sa valeur réelle avant l’exécution de la commande.\nExemple: Imaginons que nous souhaitons lister trois fichiers : toto, titi, tutu. Nous pouvons stocker ces noms dans une variable :\n$ fichiers=\"toto titi tutu\"\rEnsuite, nous pouvons utiliser cette variable dans une commande :\n$ ls -l $fichiers -rw-r--r--. 1 ndesmangles ndesmangles 0 1 fév 10:37 titi -rw-r--r--. 1 ndesmangles ndesmangles 0 1 fév 10:37 toto -rw-r--r--. 1 ndesmangles ndesmangles 0 1 fév 10:37 tutu\rQue se passe-t-il ?\nAvant d’exécuter la commande, Bash remplace $fichiers par sa valeur réelle, puis exécute la commande résultante :\n$ ls -l toto titi tutu\rStocker le résultat d’une commande dans une variable Il est possible d’affecter à une variable le résultat d’une commande :\n$ ma_variable=$(ls /home)\rExemple 1 : Stocker la date actuelle\n$ x=\"La date est : $(date)\" $ echo $x La date est : ven 31 jan 2025 15:39:37 EST\rExemple 2 : Stocker le contenu d’un fichier\n$ x=$(cat /etc/passwd) $ echo $x root:x:0:0:root:/root:/bin/bash bin:x:1:1:bin:/bin:/sbin/nologin daemon:x:2:2:daemon:/sbin:/sbin/nologin ...\rÀ savoir\rLe résultat d’une commande stocké dans une variable est retourné sur une seule ligne, ce qui peut poser problème pour les fichiers avec plusieurs lignes.\nExpansion de noms de fichiers à l’aide de caractères génériques Lorsque l’on ne connaît pas précisément le nom d’un fichier ou que l’on veut rechercher plusieurs fichiers ayant un point commun, il est possible d’utiliser des caractères génériques. L’expansion des caractères génériques permet de manipuler facilement plusieurs fichiers sans avoir à taper leurs noms en entier.\nLes principaux caractères génériques Caractère Signification * Remplace n’importe quelle chaîne de caractères de n’importe quelle longueur ? Remplace un seul caractère Le shell effectue une expansion des noms de fichiers en remplaçant les caractères génériques avant d’exécuter la commande.\nExemple 1 : Lister tous les fichiers .txt\n$ ls *.txt\rSi les fichiers toto.txt, titi.txt et tutu.txt existent, la commande devient :\n$ ls toto.txt titi.txt tutu.txt titi.txt toto.txt tutu.txt\rSachez que…\rSi lors de la création des fichiers, l’extension (.txt) était absente, la commande précédente ls retournera une erreur:\nls: impossible d'accéder à 'toto.txt': Aucun fichier ou dossier de ce type ls: impossible d'accéder à 'titi.txt': Aucun fichier ou dossier de ce type ls: impossible d'accéder à 'tutu.txt': Aucun fichier ou dossier de ce type\rExemple 2 : Lister les fichiers avec un format spécifique\n$ ls t?t?.txt\rLe ? remplace un seul caractère, donc cette commande affichera tous les fichiers du répertoire courant correspondant à ce modèle, par exemple : tata.txt, titi.txt, mais pas tututu.txt.\nL’expansion d’accolades L’expansion d’accolades est une fonctionnalité de Bash qui permet de créer plusieurs chaînes de caractères en utilisant une syntaxe abrégée. Elle est particulièrement utile pour la création de fichiers, de répertoires ou pour l’exécution de commandes répétitives.\nL’expansion d’accolades utilise la syntaxe suivante :\n{élément1,élément2,...}\roù élément1, élément2, etc. sont les différentes chaînes de caractères que vous souhaitez combiner. Bash va alors générer toutes les combinaisons possibles de ces éléments.\nAttention\rNe mettez aucun espace à l’intérieur des accolades.\nExemples concrets Exemple 1 : Création de fichiers multiples\nSupposons que vous souhaitez créer les fichiers patata, patate, patati et patatu. Sans l’expansion d’accolades, vous devriez exécuter la commande touch quatre fois ou écrire au complet tous les noms des fichiers :\n$ touch patata $ touch patate $ touch patati $ touch patatu\rou\n$ touch patata patate patati patatu\rAvec l’expansion d’accolades, vous pouvez faire tout cela en une seule ligne :\n$ touch patat{a,e,i,u}\rBash va alors générer les chaînes patata, patate, patati et patatu, puis exécuter la commande touch pour chaque chaîne.\nExemple 2 : Création de séquences numériques\nVous pouvez également utiliser l’expansion d’accolades pour créer des séquences numériques. Par exemple, si vous souhaitez créer les fichiers test1.txt, test2.txt, test3.txt, …, test12.txt, vous pouvez utiliser la commande suivante :\n$ touch test{1..12}.txt\rBash va générer les nombres de 1 à 12, puis créer les fichiers correspondants.\nAutres exemples d’utilisation Exemple 1 : Création de fichiers dans un dossier spécifique\nPour créer la structure suivante :\ndossier1/\r│── test1.txt/\r│── test2.txt/\r│── test3.txt/\rSi dossier1 esxiste déjà $ touch dossier1/test{1..3}.txt\rSi dossier1 n’existe pas utiliser plutôt la commande mkdir -p. $ mkdir -p dossier1/test{1..3}.txt\rL’option -p\rL’option -p de mkdir signifie parents. Elle indique à la commande de créer tous les répertoires parents nécessaires pour atteindre le répertoire cible, s’ils n’existent pas déjà. Attention, l’option -p ne vérifie pas l’existence des fichiers. Utiliser avec précaution pour éviter d’écraser des fichiers existants.\nExemple 2 : Combinaison de chaînes et de séquences\nPour créer la structure suivante:\nboite1/\r│── patata\r│── patate\r│── patati\rboite2/\r│── patata\r│── patate\r│── patati\rSi boite1 et boite2 existent déjà. $ touch boite{1,2}/patat{a,e,i}\rou si boite1 et boite2 n’existent pas.\n$ mkdir -p boite{1,2}/patat{a,e,i}\rProtection contre l’expansion Dans certains cas, vous pouvez souhaiter empêcher l’expansion d’accolades. Pour cela, vous pouvez utiliser le caractère d’échappement \\ ou les guillemets simples (').\nUtilisation du caractère d’échappement Le caractère \\ est un caractère d’échappement dans le shell Bash. Il permet de protéger le caractère qui le suit de son expansion. Par exemple :\n$ echo je veux afficher \\* et afficher \\$x je veux afficher * et afficher $x\rUtilisation des guillemets simples Les guillemets simples (') arrêtent tous les types d’expansion. Par exemple :\n$ echo 'je veux afficher * et afficher $x' je veux afficher * et afficher $x\rUtilisation des guillemets doubles Les guillemets doubles (\") permettent uniquement l’expansion de variables et la substitution de commandes. Par exemple :\n$ x=5 $ echo \"je veux afficher * et afficher la valeur de $x\" je veux afficher * et afficher la valeur de 5\rLa commande find La commande find est un outil essentiel pour naviguer dans le système de fichiers et localiser des fichiers ou répertoires spécifiques. Elle suit la structure générale suivante :\nfind \u003crépertoire_de_départ\u003e \u003coptions\u003e\r\u003crépertoire_de_départ\u003e: Indique le répertoire où la recherche doit commencer. La commande explorera ce répertoire et tous ses sous-répertoires. \u003coptions\u003e: Définissent les critères de recherche, tels que le nom du fichier, le type, la date de modification, etc. Recherche par nom L’option -name est la plus courante pour rechercher des fichiers par leur nom.\nCommande Description $ find / -name services Recherche un fichier nommé services dans tout le système (à partir de la racine). $ find . -name \"*.txt\" Recherche tous les fichiers se terminant par .txt dans le répertoire courant. $ find . -name \"p*\" Recherche tous les fichiers commençant par p dans le répertoire courant et ses sous-répertoires. $ find /var/log -name \"???n\" Recherche tous les fichiers de 4 caractères se terminant par n dans /var/log. Pièges à éviter Lors de l’utilisation de find, il est crucial de comprendre comment Bash gère l’expansion des variables et les guillemets. Voici quelques points importants :\nCommande find et l’expansion\rAvec la commande find, l’expansion de variables et de noms de fichiers ne se font pas. Cela permet à find d’interpréter correctement les motifs avec des caractères génériques comme *.txt. Il est souvent nécessaire d’utiliser des guillemets pour protéger les caractères spéciaux et éviter des erreurs d’interprétation. Le tableau suivant illustre les différences de comportement :\nCommande Résultat ls *.txt Affiche tous les fichiers se terminant par .txt. Si aucun fichier .txt n’est trouvé, la commande s’exécute comme si les guillemets étaient présents. ls \"*.txt\" Affiche le fichier nommé exactement *.txt. find . -name *.txt L’expansion a lieu avant la recherche. Trois cas sont possibles :- Aucun fichier .txt : La commande s’exécute comme si les guillemets étaient présents.- Un fichier .txt : Seul ce fichier est recherché.- Plusieurs fichiers .txt : La commande échoue. find . -name \"*.txt\" Recherche tous les fichiers .txt à partir du répertoire courant. Exercices Manipulation de variables et de ls :\nCréez une variable variable_etc contenant la liste des fichiers de /etc et affichez-la. Observez le résultat et évaluez sa lisibilité. Essayez d’exécuter ls suivi du nom de votre variable. Expliquez le comportement observé. Recherche de fichiers de configuration :\nTrouvez tous les fichiers se terminant par .conf et stockez leurs noms dans une variable. Essayez d’exécuter ls suivi du nom de votre variable. Utilisez la commande du -sh \u003cfichier\u003e pour afficher la taille de chaque fichier de configuration. Création de fichiers avec factorisation :\nCréez un répertoire et utilisez la commande touch avec la syntaxe de factorisation pour créer les fichiers suivants : test1.txt, test2.txt, test3.txt, test1.doc, test2.doc, test3.doc, test1.tot, test2.tot, test3.tot. Utilisation de caractères génériques :\nAffichez uniquement les fichiers .txt commençant par test (trouvez plusieurs solutions). Affichez tous les fichiers .txt et .tot. Affichez tous les fichiers test1. Solution\rManipulation de variables et de ls : variable_etc=$(ls /etc) echo $variable_etc ls $variable_etc # Affiche les fichiers séparés par des espaces\rRecherche de fichiers de configuration : fichiers_conf=$(find /etc -name \"*.conf\") ls $fichiers_conf # Affiche les fichiers séparés par des espaces for fichier in $fichiers_conf; do du -sh $fichier done\rCréation de fichiers avec factorisation : mkdir repertoire_test touch repertoire_test/test{1..3}.{txt,doc,tot}\rUtilisation de caractères génériques : ls repertoire_test/test*.txt # Solution 1 ls repertoire_test/test[1-3].txt # Solution 2 ls repertoire_test/*.{txt,tot} ls repertoire_test/test1*\rItération sur le résultat d’une commande avec la boucle for La syntaxe de base d’une boucle for est la suivante :\nfor i in arg1 arg2 ...; do commande; done\ri : Variable qui prendra successivement la valeur de chaque argument. arg1 arg2 ... : Liste des éléments sur lesquels itérer. commande : Commande à exécuter pour chaque élément de la liste. Exemples d’utilisation Exemple 1 : Affichage du contenu de fichiers .txt\nSupposons que vous ayez les fichiers suivants :\nfichier1.txt\t# contient le mot 'Bonjour'\rfichier2.txt\t# contient le mot 'tout'\rfichier3.txt\t# contient le mot 'le'\rfichier4.txt\t# contient le mot 'monde'\rPour afficher le contenu de chaque fichier, vous pouvez utiliser une boucle for :\n$ for i in fichier1.txt fichier2.txt fichier3.txt fichier4.txt; do cat $i; done Bonjour tout le monde\rExemple 2 : Utilisation d’une variable pour stocker le résultat d’une commande\nVous pouvez stocker le résultat d’une commande dans une variable, puis itérer sur cette variable :\n$ fichiers=$(ls fichier*.txt) $ for i in $fichiers; do cat $i; done Bonjour tout le monde\rExemple 3 : Passage direct de la commande à la boucle for\nIl est également possible de passer directement la commande à la boucle for :\n$ for i in $(ls fichier*.txt) ; do cat $i; done Bonjour tout le monde\rExemple 4 : Utilisation de l’expansion de noms de fichiers\nPour simplifier l’itération sur des fichiers, vous pouvez utiliser l’expansion de noms de fichiers :\n$ for i in fichier*.txt; do cat $i; done Bonjour tout le monde\rFormatage de la boucle for dans un script Dans un script, il est recommandé d’écrire la boucle for sur plusieurs lignes pour une meilleure lisibilité. Les sauts de ligne remplacent le ; dans ce cas :\nfor i in $var do echo $i done\rExercices Liste des fichiers de /bin :\nCréez une variable contenant la liste des fichiers du répertoire /bin. Affichage des fichiers :\nParcourez cette variable à l’aide d’une boucle for et affichez chaque fichier sur une ligne différente. Taille des fichiers :\nSachant que vous pouvez concaténer des chaînes de caractères comme ceci : echo /bin/$i\rEssayez d’afficher la taille des fichiers du répertoire /bin. Utilisez la commande du -sh \u003cfichier\u003e pour afficher la taille d’un fichier. Solution\rListe des fichiers de /bin : fichiers_bin=$(ls /bin)\rAffichage des fichiers : for i in $fichiers_bin; do echo $i done\rTaille des fichiers : for i in $fichiers_bin; do echo /bin/$i du -sh /bin/$i done",
    "description": "Le processus de démarrage Le processus de démarrage d’un système Linux suit plusieurs étapes essentielles, impliquant différents composants du système :\nÉtape Description 1. Activation du BIOS/UEFI Au démarrage, le BIOS (Basic Input Output System) ou l’UEFI (Unified Extensible Firmware Interface) s’active. Il vérifie le matériel et cherche le secteur de démarrage sur le disque (MBR ou GPT). 2. Chargement du chargeur d’amorçage Le MBR (Master Boot Record) définit le chargeur de démarrage, comme GRUB (GRand Unified Bootloader). GRUB affiche un menu permettant de choisir le système à démarrer. 3. Chargement du noyau Linux (Kernel) Après sélection de Linux, GRUB charge le noyau, qui initialise les pilotes, périphériques et la gestion de la mémoire. Il charge aussi un disque temporaire (initrd ou initramfs) contenant les modules nécessaires au démarrage. 4. Lancement du processus d’initialisation (init ou systemd) Le noyau lance le premier processus du système : init ou systemd (selon la distribution Linux). Ce processus démarre les services et scripts de configuration (réseau, interface graphique, gestion des utilisateurs, etc.). 5. Affichage de l’écran de connexion Une fois les services chargés, l’écran de connexion s’affiche, demandant un nom d’utilisateur et un mot de passe. 6. Utilisation du système Après authentification, vous pouvez utiliser Linux, lancer des applications et exécuter des commandes. Vous pouvez aussi arrêter ou redémarrer votre système avec shutdown, reboot ou halt. Les niveaux d’exécution (Runlevels) et cibles (Targets) Autrefois, Linux utilisait des niveaux d’exécution (runlevels), qui définissaient les services actifs selon le mode de fonctionnement. Avec systemd, ces niveaux sont remplacés par des cibles (targets). Cependant, la compatibilité avec les anciens niveaux est conservée.",
    "tags": [],
    "title": "Processus de démarrage, cibles, variables et boucle For",
    "uri": "/semaine3/cours/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Processus de démarrage, variables et FOR",
    "content": "Objectifs de l’atelier Se familiariser avec les cibles (niveaux d’exécution). Comprendre les bases des variables utilisateur en Bash. Apprendre à manipuler et utiliser des variables pour stocker des résultats de commandes. Format de la remise sur Moodle Attention\rPour chaque exercice, vous devez prendre une capture d’écran. Sur les captures, on doit pouvoir voir : Votre nom d’utilisateur (Ne travaillez donc pas avec l’utilisateur root, ni la commande sudo). La ligne de commande et la commande. Le résultat de la commande. Si le résultat fait plus de 10 lignes, capturer juste les 10 premières lignes. Dans votre remise, l’enseignant/e doit pouvoir facilement identifier les captures d’écran et la question (de quel exercice) correspondante. Atelier Exercice 1 : Niveaux d’exécution Modifier le niveau d’exécution par défaut de votre machine virtuelle (VM) pour passer en mode multi-utilisateurs sans interface graphique.\nRedémarrer la VM pour appliquer les changements à l’aide de la commande shutdown -r now.\nAprès le redémarrage, se connecter à votre VM . Vérifier que l’interface graphique ne démarre pas. Utiliser la commande systemctl pour connaître le niveau d’exécution actuel.\nRétablir le mode graphique par défaut. N’oubliez pas de redémarrer la VM pour que les changements soient pris en compte.\nExercice 2 : Caractères génériques et commande find Aller dans le répertoire /etc. Notez qu’il est demandé de ne pas se déplacer pour le reste de cet exercice.\nUtiliser la commande find pour rechercher les fichiers dont le nom commence par la lettre r dans le répertoire courant.\nUtiliser la commande find pour rechercher les fichiers contenant la chaîne rc dans le répertoire courant.\nUtiliser la commande find pour rechercher les fichiers dont le nom comporte exactement trois caractères sur l’ensemble du système de fichiers (à partir de la racine).\nExercice 3 : Expansion d’accolades et boucle for Important\rAssurez-vous d’être revenu dans votre répertoire personnel avant de commencer cet exercice.\nUtiliser l’expansion d’accolades pour créer l’arborescence de dossiers suivante en une seule commande. Astuce\rUtiliser l’option -p de la commande mkdir.\nToujours en utilisant l’expansion d’accolades, créer un fichier vide nommé priseNote dans chaque répertoire lab en une seule commande\nUtiliser une boucle for pour renommer tous les fichiers priseNote en priseNote.txt.\nUtiliser une boucle for pour déplacer les fichiers priseNote.txt des répertoires lab vers les répertoires lecon correspondants.\nVérification des résultats\rUtilisez la commande tree pour vérifier que l’arborescence des dossiers et les fichiers ont été créés et déplacés correctement. Par exemple :\n$ tree semaine1\rLa structure qui devrait s’afficher :\nsemaine1\r├── lab\r│ └── ├── lecon\r│ └── priseNote.txt",
    "description": "Objectifs de l’atelier Se familiariser avec les cibles (niveaux d’exécution). Comprendre les bases des variables utilisateur en Bash. Apprendre à manipuler et utiliser des variables pour stocker des résultats de commandes. Format de la remise sur Moodle Attention\rPour chaque exercice, vous devez prendre une capture d’écran. Sur les captures, on doit pouvoir voir : Votre nom d’utilisateur (Ne travaillez donc pas avec l’utilisateur root, ni la commande sudo). La ligne de commande et la commande. Le résultat de la commande. Si le résultat fait plus de 10 lignes, capturer juste les 10 premières lignes. Dans votre remise, l’enseignant/e doit pouvoir facilement identifier les captures d’écran et la question (de quel exercice) correspondante. Atelier Exercice 1 : Niveaux d’exécution Modifier le niveau d’exécution par défaut de votre machine virtuelle (VM) pour passer en mode multi-utilisateurs sans interface graphique.",
    "tags": [],
    "title": "ATELIER #3: Cibles et variables utilisateurs et for",
    "uri": "/semaine3/atelier/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "Plan de la leçon Théorie : jeudi 13 février (semaine #4)\nQuelques commandes utiles (tree, grep, sep cut, more, less et sort). Les entrées et sorties et la redirection des commandes. Le chainage de commandes (Pipelines). Les commandes de filtrage courantes. La boucle while. Test #1 : lundi 17 février (semaine #4)\nDurée: 1h40, ~20 questions Format: Test sur Moodle Écrire la commande (1 ligne) Écrire la commande (plus d’une ligne) Matière: Semaine 2: Système de fichiers, shell, commandes de base, Vim. Semaine 3: Processus de démarrage, variables, commande find et boucle for Documentation permise: Seulement 1 feuille 8.5 x 11 recto-verso manuscrite. Atelier : Remise au plus tard mardi 18 février Utilisation des diverses commandes. Redirection des entrées et sorties. Enchainer les commandes. Itération avec While.",
    "description": "Plan de la leçon Théorie : jeudi 13 février (semaine #4)\nQuelques commandes utiles (tree, grep, sep cut, more, less et sort). Les entrées et sorties et la redirection des commandes. Le chainage de commandes (Pipelines). Les commandes de filtrage courantes. La boucle while. Test #1 : lundi 17 février (semaine #4)\nDurée: 1h40, ~20 questions Format: Test sur Moodle Écrire la commande (1 ligne) Écrire la commande (plus d’une ligne) Matière: Semaine 2: Système de fichiers, shell, commandes de base, Vim. Semaine 3: Processus de démarrage, variables, commande find et boucle for Documentation permise: Seulement 1 feuille 8.5 x 11 recto-verso manuscrite. Atelier : Remise au plus tard mardi 18 février Utilisation des diverses commandes. Redirection des entrées et sorties. Enchainer les commandes. Itération avec While.",
    "tags": [],
    "title": "Commandes utiles, redirection, chainage et filtrage de commandes et While",
    "uri": "/semaine4/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Commandes utiles, redirection, chainage et filtrage de commandes et While",
    "content": "Commandes diverses tree: Afficher l’arborescence des dossiers La commande tree affiche les fichiers et dossiers sous forme d’arborescence.\nL’option -d permet d’afficher uniquement les répertoires (et pas les fichiers).\nL’option -L permet de limiter l’affichage à N niveaux de profondeur.\nAfficher uniquement les dossiers :\n$ tree -d\t# `d` pour directory\rAfficher les dossiers d’un endroit précis :\n$ tree /etc\rLimiter l’affichage aux 2 premiers niveaux :\n$ tree -L 2\rgrep : Rechercher du texte dans un fichier L’option -r permet de rechercher de manière récursive dans un répertoire et tous ses sous-dossiers.\nLe caractère ^ est utilisé pour faire correspondre le début d’une ligne dans un fichier lorsqu’il est placé au début d’une chaine.\nTrouver “ssh” dans /etc/services :\n$ grep ssh /etc/services\rChercher dans tous les fichiers d’un dossier :\n$ grep -r \"ssh\" /etc/\rChercher uniquement au début des lignes :\n$ grep \"^root\" /etc/passwd\rsed: Remplacer du texte dans un fichier Le préfixe s dans sed signifie substitution. Il est utilisé pour rechercher et remplacer une chaîne de caractères dans un fichier ou un flux de texte. L’option -i permet de modifier un fichier sans créer de fichier temporaire. Par défaut, sed ne remplace que la première occurrence d’un motif sur une ligne. En ajoutant g, il remplace toutes les occurrences. `s/ancien/nouveau/`\t# Remplace 'ancien' par 'nouveau' (`s` pour \"substitute\").\r`s/ancien/nouveau/g`\t# Remplace toutes les occurrences 'd'ancien' par 'nouveau' (`g` pour \"global\").\rChanger « root » en « admin » (affichage uniquement) :\n$ sed 's/root/admin/' /etc/passwd\rChanger toutes les occurrences :\n$ sed 's/root/admin/g' /etc/passwd\rChanger et enregistrer directement dans le fichier :\n$ sed -i 's/root/admin/g' /etc/passwd\rcut: Extraire des colonnes d’un fichier L’option -d permet de définir le délimiteur utilisé pour diviser les champs d’une ligne.\nL’option -f est utilisée pour sélectionner un ou plusieurs champs après avoir défini un délimiteur avec -d.\nDélimiteur par défaut\rPar défaut, cut utilise la tabulation comme délimiteur.\nExtraire le 6e champ d’un fichier où les champs sont séparés par : :\n$ cut -d':' -f6 /etc/passwd\rExtraire plusieurs colonnes ((1re et 3e) :\n$ cut -d':' -f1,3 /etc/passwd\rmore: Lire un fichier page par page (ou less) more affiche le fichier page par page, mais on ne peut pas remonter. less permet d’aller en avant et en arrière. $ less /etc/passwd\rCommandes utiles dans less :\nAller en bas : ↓ ou Entrée Aller en haut : ↑ Aller au début du fichier : g Aller à la fin du fichier : G Descendre d’une page : Espace Monter d’une page : b Rechercher un mot : /mot puis Entrée Rechercher en arrière: ?mot puis Entrée Aller à la prochaine occurrence : n Revenir à l’occurrence précédente : N Quitter : q sort: Trier des lignes L’option -k permet de spécifier la colonne (ou champ) à utiliser pour le tri.\nL’option -n permet de trier des nombres correctement (plutôt qu’en mode texte).\nTrier un fichier alphabétiquement :\n$ sort fruits.txt\rTrier par colonne (exemple : fichier avec noms et numéros) :\n$ sort -k2 profs.txt\rTrier numériquement (sinon, 10 est avant 2) :\n$ sort -k2 -n data.csv\rRediriger la sortie d’une commande Enregistrer la sortie dans un fichier avec 1\u003e ou \u003e:\n$ find / -name services 1\u003e resultats.txt\rInformation\rIci, le chiffre 1 n’est pas obligatoire. Si on ne le met pas, la sortie standard est utilisée par défaut.\nLa commande précédente peut s’écrire aussi comme cela:\n$ find / -name services \u003e resultats.txt\rIgnorer les erreurs à l’aide de 2\u003e:\n$ find / -name services 2\u003e/dev/null\rEnvoyer sortie + erreurs dans un fichier en combinant 2\u003e et 1\u003e:\n$ find / -name services \u003e resultats.txt 2\u003e\u00261\rAjouter du texte à un fichier sans l’écraser à l’aide de \u003e\u003e:\n$ echo \"Bonjour\" \u003e\u003e fichier.txt\rEnchaîner des commandes avec | (pipe) Le | envoie le résultat d’une commande à une autre commande. La 2ème commande récupère le résultat de la 1ère commande pour travailler dessus.\nLe nombre de commandes que l’on peut ainsi enchainer n’a pas de limite.\nAfficher le fichier avec less :\n$ cat /etc/services | less\rChercher « ssh » dans un fichier et afficher :\n$ cat /etc/services | grep ssh\rCompter le nombre de lignes d’un fichier :\n$ cat fichier.txt | wc -l\rExercice 1 Sans être root et sans utiliser sudo, rechercher le fichier services sur tout le disque dur. Est-ce facile de le trouver dans la sortie de la commande ? Faites la même recherche mais en redirigeant les lignes “Accès refusé” vers le fichier /dev/null. Est-ce plus facile de trouver le résultat de la commande ? Sauvegardez le résultat dans le fichier ~/services.txt à l’aide d’une redirection. Solution\r$ find / -name services\rC’est difficile de lire la sortie car les résultats sont noyés au milieu de nombreux messages d’erreurs. Pour rediriger les messages d’erreur:\n$ find / -name services 2\u003e/dev/null\rMaintenant la lecture est beaucoup plus facile: Pour sauvegarder le résultat dans un fichier:\n$ find / -name services 2\u003e/dev/null \u003e~/services.txt\rLes filtres Enchainer des commandes permet d’appliquer de nombreux filtres sur le résultat d’une commande:\nCommande Résutats cat fichier.txt | wc -l Compte le nombre de lignes du fichier (wc : word count, -l pour les lignes) cat fichier | grep [-iv] recherche Permet de garder (ou éliminer -v) les lignes contenant la recherche, sans tenir compte des majuscules -i. find / -name “*.conf” | sort classe le résultat de la commande find par ordre alphabétique. cat /etc/passwd | sed ’s/root/admin/’ Remplace la 1ère occurrence de root par admin dans l’affichage (pas dans le fichier) cat /etc/passwd | cut -d’:’ -f1 | sort Affiche uniquement le 1er champs de chaque ligne du fichier /etc/passwd en utilisant : comme séparateur de champs et les classe par ordre alphabétique. D’autres commandes utiles Remplacer des lettres avec la commande tr\n$ echo SAlut | tr 'A' 'a' salut\rSupprimer les doublons (nécessite sort) avec la commande uniq\n$ cat fichier | sort | uniq\rTransformer $PATH en liste triée\n$ echo $PATH | tr ':' '\\n' | sort\rCela affiche chaque dossier du PATH sur une ligne et le trie.\nExercice 2 Trouver le numéro de port de zephyr-srv dans /etc/services. Combien de lignes dans /etc/services n’ont pas de e? Combien de lignes **n’ont ni e ni a ? Solution\rPour trouver le numéro de port:\ncat /etc/services | grep \"zephyr-srv\"\rLe numéro du port est 2102. Pour trouver le nombre de lignes ne contenant pas ’e':\ncat /etc/services | grep -v e | wc -l\rPour les lignes ne contenant ni ’e’ ni ‘a’:\ncat /etc/services | grep -v e | grep -v a | wc -l\rLa boucle while La boucle while permet de traiter chaque ligne d’une commande une par une.\nLa syntaxe de base d’une boucle while en Bash est la suivante :\nwhile condition; do Commandes à exécuter tant que la condition est vraie; done\rou sur plusieurs lignes\nwhile condition do Commandes à exécuter tant que la condition est vraie done\rExemple : connaître la taille de chaque dossier dans la variable d’environnement $PATH.\n$ echo $PATH | tr ':' '\\n' | while read i; do du -sh $i; done\rtr ':' '\\n' ➡ Remplace : par un saut de ligne. while read i; do ... done ➡ Lit chaque ligne et exécute du -sh dessus. Résultat : La taille de chaque dossier dans $PATH.\nExercices 3 Recherchez tous les fichiers de configuration du système (on considère qu’ils se terminent par .conf) puis n’affichez que le nom du fichier sans le chemin. La commande basename /rep1/rep2/…/fichier.txt affiche seulement fichier.txt. Une fois l’exercice terminé, classez les résultats par ordre alphabétique. Avec une boucle while, parcourez le fichier /etc/services et pour chaque ligne, ne garder que le 1er champs en utilisant comme délimiteur (espace). Une fois terminé, éliminez les doublons et comptez le nombre de lignes. Solution\rPremière partie: Pour trouver les fichiers de configuration:\nfind / -name \"*.conf\" 2\u003e/dev/null\rPour afficher seulement le nom sans le chemin:\nfind / -name \"*.conf\" 2\u003e/dev/null | while read i; do basename \"$i\"; done\rPour classer par ordre alphabétique:\nfind / -name \"*.conf\" 2\u003e/dev/null | while read i; do basename \"$i\"; done | sort\rDeuxième partie:\ncat /etc/services | while read i; do echo \"$i\" | cut -d' ' -f1 ; done\rPour enlever les doublons et compter le nombre de ligne:\ncat /etc/services | while read i; do echo \"$i\" | cut -d' ' -f1 ; done | sort | uniq | wc -l",
    "description": "Commandes diverses tree: Afficher l’arborescence des dossiers La commande tree affiche les fichiers et dossiers sous forme d’arborescence.\nL’option -d permet d’afficher uniquement les répertoires (et pas les fichiers).\nL’option -L permet de limiter l’affichage à N niveaux de profondeur.\nAfficher uniquement les dossiers :\n$ tree -d\t# `d` pour directory\rAfficher les dossiers d’un endroit précis :\n$ tree /etc\rLimiter l’affichage aux 2 premiers niveaux :\n$ tree -L 2\rgrep : Rechercher du texte dans un fichier L’option -r permet de rechercher de manière récursive dans un répertoire et tous ses sous-dossiers.",
    "tags": [],
    "title": "Commandes utiles, redirection, chainage, filtres et boucle While",
    "uri": "/semaine4/cours/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Commandes utiles, redirection, chainage et filtrage de commandes et While",
    "content": "Objectifs de l’atelier Utiliser les commandes tree, grep, sep, cut, more, less et sort. Rediriger les résultats de commandes. Enchainer les commandes. Filtrer des données de fichiers ou répertoires. Itérer sur des résultats de commandes avec la boucle While. Atelier Astuce\rPour réaliser les exercices, vous aurez besoin de regarder les différentes commandes vues en cours (commandes et boucles). Vous DEVREZ consulter les pages de manuel des différentes commandes pour trouver la façon de réaliser ce que vous souhaitez. Pour effectuer des opérations simple, vous pouvez utiliser la commande bc de cette façon: $ echo 7-3 | bc\rExercice 1 Ouvrir une session avec l’utilisateur standard et reproduire, dans le répertoire courant, l’arborescence suivante et ce en utilisant un maximum de trois commandes : ├── H2025\r│ ├── Linux\r│ │ ├── Cours\r│ │ └── Ateliers\r│ └── Virtualisation\r│ └── machines\r└── Icones\rChanger de répertoire en allant dans le dossier Cours. Pour le reste des question de cet exercice, rester dans le répertoire Cours.\nEn saisissant une seule commande, créer, à l’intérieur du répertoire courant, les dossiers semaine1, semaine2, …, semaine15. Vous ne devez pas entrer tous les noms de semaines dans la commande (hint: expansion d’accolades).\nÀ l’aide d’une boucle for, à l’intérieur de chaque dossier semaine, créer un fichier .txt qui contient la phrase suivante : Ce cours concerne la semaineN\nOù N correspond au numéro de la semaine.\nToujours à partir du répertoire courant, utiliser un chemin relatif pour copier dans le dossier ateliers le fichier passwd qui est dans /etc.\nToujours à partir du répertoire courant et en utilisant le chemin relatif, renommer le fichier copié en ajoutant “Copie” à son nom (passwdCopie).\nChanger toutes les occurrences du caractère délimiteur : (deux points) du fichier passwdCopie par ; (point-virgule).\nTrier le contenu du fichier passwdCopie en ordre croissant du numéro de groupe, soit le quatrième champ. On veut que le fichier soit trié et non uniquement le résultat retourné par la commande.\nExercice 2 Revenir dans votre dossier personnel.\nÉcrire la commande qui permet de compter le nombre d’utilisateurs qui ont pour shell le /bin/bash. Vous trouverez cette information dans le fichier /etc/passwd. À l’exécution de la commande, on veut un résultat comme ceci: 11 utilisateurs ont pour shell /bin/bash\rNotez que…\rLe nombre d’utilisateurs pourrait être différent.\nMaintenant on veut écrire la ligne de commande qui permet d’afficher le nombre d’utilisateurs qui ont pour shell par défaut un des shells disponibles sur votre machine. Pour cela, il faut parcourir le fichier /etc/shells ligne par ligne (hint: boucle). Vous y trouverez les shells disponibles. À l’exécution de la commande, on aurait pour chacun des shells un résultat de la même forme que le suivant: 0 utilisateurs ont pour shell /bin/sh 11 utilisateurs ont pour shell /bin/bash 0 utilisateurs ont pour shell /usr/bin/sh 0 utilisateurs ont pour shell /usr/bin/bash\rAttention\rVous ne devez pas indiquer manuellement les noms des shells..\nExercice 3 Revenir dans votre dossier personnel.\nPour cet exercice:\nnomdurépertoire est affiché automatiquement. N est le nombre trouvé. Référez-vous au cours de la semaine 2 sur la commande ls -l\nEn une seule ligne de commande, on veut savoir combien de fichiers et dossiers contient le répertoire courant. Le résultat doit être affiché comme suit : Le répertoire `nomdurépertoire` contient N dossiers\rEn une seule ligne de commande, on veut savoir combien de fichiers standards contient le répertoire courant. Le résultat doit être affiché comme suit : Le répertoire `nomdurépertoire` contient N fichiers standards\rEn une seule ligne de commande, on veut savoir combien d’éléments ne sont ni des dossiers ni des fichiers standards dans le répertoire courant. Le résultat doit être affiché comme suit : Le répertoire `nomdurépertoire` contient N fichiers qui ne sont ni standards ni des répertoires\rÉcrire une commande qui récupère le nom du dernier utilisateur qui a été créé sur votre machine (c’est celui qu’on retrouve à la dernière ligne du fichier /etc/passwd). Le résultat doit être stocké dans une variable nommée nomUtilisateur.\nEn utilisant la variable nomdurépertoire qui contient le nom du dernier utilisateur défini dans /etc/passwd, écrivez une commande permettant de :\nRechercher tous les fichiers du système (find) Lister leurs détails avec ls -l Filtrer uniquement les fichiers appartenant à cet utilisateur. Filtrer uniquement les fichiers standards. La commande doit être une seule ligne en utilisant un pipe (|) et une boucle while read. Exercice 4 En tant qu’utilisateur standard, On veut trouver tous les fichiers .txt sur votre disque dur (ne pas utiliser sudo). Écrire la commande qui permet de retrouver cette information sans afficher les erreurs.\nRécupérer la sortie standard de la commande précédente et à partir de son résultat, lire chaque ligne et à l’aide de la commande ls, afficher la taille de ces fichiers suivi du chemin vers les fichiers.(en une seule commande sans utiliser de variable) Résultat attendu:\n0 /home/mot/dossier2/fichier4.txt 0 /home/mot/dossier3/fichier2.txt 0 /home/mot/dossier3/fichier3.txt 0 /home/mot/dossier3/fichier4.txt 79 /home/mot/prof.txt\rRécupérer la sortie standard de la commande précédente et trier le résultat par ordre croissant de taille. (en une seule commande sans utiliser de variable)",
    "description": "Objectifs de l’atelier Utiliser les commandes tree, grep, sep, cut, more, less et sort. Rediriger les résultats de commandes. Enchainer les commandes. Filtrer des données de fichiers ou répertoires. Itérer sur des résultats de commandes avec la boucle While. Atelier Astuce\rPour réaliser les exercices, vous aurez besoin de regarder les différentes commandes vues en cours (commandes et boucles). Vous DEVREZ consulter les pages de manuel des différentes commandes pour trouver la façon de réaliser ce que vous souhaitez. Pour effectuer des opérations simple, vous pouvez utiliser la commande bc de cette façon: $ echo 7-3 | bc\rExercice 1 Ouvrir une session avec l’utilisateur standard et reproduire, dans le répertoire courant, l’arborescence suivante et ce en utilisant un maximum de trois commandes : ├── H2025\r│ ├── Linux\r│ │ ├── Cours\r│ │ └── Ateliers\r│ └── Virtualisation\r│ └── machines\r└── Icones\rChanger de répertoire en allant dans le dossier Cours. Pour le reste des question de cet exercice, rester dans le répertoire Cours.",
    "tags": [],
    "title": "ATELIER #4: Commandes utiles, redirection, chainage, filtres et boucle while",
    "uri": "/semaine4/atelier/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "Plan de la leçon Théorie :\nQu’est-ce qu’un processus ? Exemples de processus. L’exécution en arrière-plan. Visualiser les processus. Les états des processus. La gestion des processus. Le code de retour des commandes. Les combinaison de commandes. La création de scripts bash. Atelier :\nGestion et manipulation de processus à l’aide de scripts.",
    "description": "Plan de la leçon Théorie :\nQu’est-ce qu’un processus ? Exemples de processus. L’exécution en arrière-plan. Visualiser les processus. Les états des processus. La gestion des processus. Le code de retour des commandes. Les combinaison de commandes. La création de scripts bash. Atelier :\nGestion et manipulation de processus à l’aide de scripts.",
    "tags": [],
    "title": "Les processus Linux",
    "uri": "/semaine5/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Les processus Linux",
    "content": "Objectifs de l’atelier Manipuler les processus sous Linux en utilisant des commandes de base. Comprendre et explorer les différents types de processus sous Linux. Apprendre à lister, gérer et contrôler les processus. Manipuler les processus en premier plan et en arrière-plan. Remise Vous devez remettre sur Moodle :\nVos deux fichiers .sh Deux captures d’écran illustrant le fonctionnement des scripts : Capture Contenu 01_nombre_de_fichiers_seq.png Appel au script séquentiel et résultats 02_nombre_de_fichiers_conc.png Appel au script concurrent et résultats Atelier Dans cet atelier, vous apprendrez à créer deux scripts Bash :\nl’un avec des commandes séquentielles et l’autre avec des commandes exécutées de manière asynchrone. Ces scripts vous permettront de mieux comprendre les différences entre l’exécution séquentielle et concurrente.\nAstuces et rappels Stocker une valeur dans une variable Pour stocker le nombre de fichiers présents dans un répertoire :\nnb=$(ls | wc -l)\rCette commande place le nombre de fichiers dans la variable nb.\nTester la valeur d’une variable Pour comparer une variable à un chiffre :\ntest $nb -eq 10\rCette commande vérifie si nb est égal à 10. Si c’est le cas, le code de retour sera 0, sinon il sera différent de 0.\nVous pouvez combiner cette commande avec des opérateurs logiques :\ntest $nb -eq 10 \u0026\u0026 echo \"Les deux valeurs sont égales\" || echo \"Les deux valeurs sont différentes\"\rParcourir une variable avec une boucle for Pour parcourir une liste de serveurs :\nserveurs=\"google.com facebook.com youtube.com\" for i in $serveurs; do echo $i; done\rChaque élément de la variable serveurs sera affiché séparément.\nConseils supplémentaires Pour mesurer les performances des scripts, utilisez la commande time. Comparez les temps d’exécution pour comprendre l’intérêt de la concurrence. Exercice 1 : Script séquentiel Créer un script Bash nommé nombre_de_fichiers_seq.sh pour compter le nombre de fichiers par type. Aide pour l’exercice Ce script doit compter et afficher le nombre de fichiers pour chaque type suivant : java, conf, txt, png, tiff.\nStructure de base\nAjoutez cette ligne au début du script :\ntypes=\"java conf txt png tiff\"\rFonctionnalités à implémenter\nCompter le nombre de fichiers pour chaque type. Afficher un message si aucun fichier n’est trouvé. Ne pas afficher d’autres messages. Exemple de sortie\nDécompte des fichiers java conf txt png tiff Il y a 50718 fichiers .java Il y a 1171 fichiers .conf Il y a 6999 fichiers .txt Il y a 67296 fichiers .png Il n’y a aucun fichier .tiff\rExercice 2 : Script concurrent Créer une version concurrente de ce script nommée nombre_de_fichiers_conc.sh, en utilisant des commandes asynchrones (\u0026). Aide pour l’exercice Ce script doit être une version améliorée de nombre_de_fichiers_seq.sh, en exécutant les commandes de manière asynchrone.\nFonctionnalités à implémenter\nUtiliser \u0026 pour exécuter les commandes find en arrière-plan. Regrouper les processus dans un sous-processus avec (CMD1; CMD2; ...) \u0026. Utiliser la commande wait à la fin pour attendre la fin de tous les processus en arrière-plan. Exemple de sortie\nDécompte des fichiers java conf txt png tiff Il y a 1171 fichiers .conf Il n’y a aucun fichier .tiff Il y a 67296 fichiers .png Il y a 50718 fichiers .java Il y a 6999 fichiers .txt",
    "description": "Objectifs de l’atelier Manipuler les processus sous Linux en utilisant des commandes de base. Comprendre et explorer les différents types de processus sous Linux. Apprendre à lister, gérer et contrôler les processus. Manipuler les processus en premier plan et en arrière-plan. Remise Vous devez remettre sur Moodle :\nVos deux fichiers .sh Deux captures d’écran illustrant le fonctionnement des scripts : Capture Contenu 01_nombre_de_fichiers_seq.png Appel au script séquentiel et résultats 02_nombre_de_fichiers_conc.png Appel au script concurrent et résultats Atelier Dans cet atelier, vous apprendrez à créer deux scripts Bash :",
    "tags": [],
    "title": "ATELIER #5: Gestion des processus Linux",
    "uri": "/semaine5/atelier/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "Plan de la leçon Théorie :\nRôles des expressions régulières. Quelques motifs de base. La commande egrep. L’opérateur logique OU. Les ensembles de caractères. Les intervalles. Les quantificateurs. Les groupes. L’échappement de caractères spéciaux. Atelier :.\nUtilisation d’expressions régulières.",
    "description": "Plan de la leçon Théorie :\nRôles des expressions régulières. Quelques motifs de base. La commande egrep. L’opérateur logique OU. Les ensembles de caractères. Les intervalles. Les quantificateurs. Les groupes. L’échappement de caractères spéciaux. Atelier :.\nUtilisation d’expressions régulières.",
    "tags": [],
    "title": "Les expressions régulières",
    "uri": "/semaine6/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Les expressions régulières",
    "content": "Introduction aux expressions régulières Dans l’univers Linux, la manipulation des fichiers texte est une tâche essentielle. Parmi les outils utilisés pour ce faire, on trouve notamment :\ncat : pour afficher le contenu des fichiers, sed : pour les transformations textuelles, grep : pour rechercher et filtrer des lignes. Avec grep, vous pouvez filtrer un texte pour ne conserver que les lignes contenant un mot ou une expression donnée, ou bien les exclure. Mais comment faire si vous souhaitez rechercher des motifs plus complexes, comme des adresses e-mail ou des numéros de téléphone ? C’est ici qu’interviennent les expressions régulières, un outil puissant pour décrire des motifs précis et identifier des textes ayant une structure particulière.\nExemple : URL Web Un exemple d’expression régulière pour capturer une URL Web :\nhttps?://[a-zA-Z0-9\\.-]+\\.[a-zA-Z]{2,4}(/\\S*)?\rPremiers pas avec les expressions régulières Voici quelques motifs de base et leurs significations :\nMotif Description Exemple Contre-exemple ab Recherche la chaîne exacte “ab”. “ab” “a”, “b”, chaîne vide . Correspond à n’importe quel caractère. “a”, “b” “ab”, chaîne vide ^ Indique le début d’une ligne. ^a : un “a” au début. Toute ligne ne commençant pas par “a”. $ Indique la fin d’une ligne. a$ : un “a” à la fin. Toute ligne ne se terminant pas par “a”. Commandes pratiques avec egrep La commande egrep est une version avancée de grep, qui prend en charge les expressions régulières étendues (ERE).\nRechercher les lignes contenant “ssh” dans un fichier :\n$ egrep 'ssh' /etc/services\rRechercher uniquement les commentaires (lignes commençant par #) :\n$ egrep '^#' /etc/services\rRechercher les lignes se terminant par “s” :\n$ egrep 's$' /etc/services\rRechercher les lignes contenant “a” et “z” séparées par un caractère quelconque :\n$ egrep 'a.z' /etc/services\rOpérateurs logiques Le OU (|) L’opérateur | permet de rechercher des lignes contenant l’une ou l’autre des expressions spécifiées.\nExemple : Filtrer les lignes contenant “ssh” ou “ftp” :\n$ egrep 'ssh|ftp' /etc/services\rFiltrer les commentaires ou les lignes se terminant par “s” :\n$ egrep '^#|s$' /etc/services\rEnsembles de caractères Les ensembles permettent de rechercher plusieurs possibilités similaires en regroupant des caractères entre crochets [ ].\nExemple : Rechercher “loucher”, “toucher”, “doucher”, ou “coucher” :\n$ egrep '[ltdc]oucher' fichier\rExclure ces mots tout en recherchant ceux contenant “oucher” :\n$ egrep '[^ltdc]oucher' fichier\rIntervalles Ensemble Description [a-z] Toutes les lettres minuscules. [A-Z] Toutes les lettres majuscules. [0-9] Tous les chiffres. [a-zA-Z0-9] Tous les caractères alphanumériques. Important\rUn ensemble décrit un seul caractère. Rechercher des mots contenant un “f” et un “p” séparés par une lettre minuscule :\n$ egrep 'f[a-z]p' /etc/services\rRechercher les lignes commençant par un chiffre :\n$ egrep '^[0-9]' /etc/services\rExclure les commentaires :\n$ egrep '^[^#]' /etc/services\rQuantificateurs Les quantificateurs précisent le nombre de répétitions d’un motif.\nQuantificateur Signification ? 0 ou 1 fois. + 1 ou plusieurs fois. * 0 ou plusieurs fois. {n} Exactement n fois. {n,m} Entre n et m fois. {n,} Au moins n fois. Rechercher “www” dans un texte :\n$ egrep 'w{3}' fichier\rRechercher “http” ou “https” :\n$ egrep 'https?' fichier\rRechercher une lettre minuscule répétée entre 3 et 6 fois :\n$ egrep '[a-z]{3,6}' fichier\rGroupes Les groupes permettent de regrouper des parties d’expressions avec des parenthèses ( ). Cela permet d’appliquer un quantificateur ou de réutiliser le groupe.\nExemple : (ab)*c\rCorrespond à : “zéro ou plusieurs ‘ab’, suivi d’un ‘c’”. Cela capture “c”, “abc”, “ababc”, etc. Échappement Pour rechercher des caractères ayant une signification spéciale dans les expressions régulières (., +, *, etc.), il faut les échapper avec un antislash ().\nExemple : Rechercher les lignes se terminant par un point : $ egrep '\\.$' fichier\rExercices pratiques Trouvez les numéros de cartes de crédit valides (16 chiffres, commençant par 4540 et sans 9 dans le dernier groupe) :\n4540 6010 4510 8888\r5440 5010 6610 1010\r4540 7010 4428 5490\r4540 8523 4013 1314\r4540 8710 5410 1012 1314\rIdentifiez les noms de variables valides (lettres, chiffres, underscores, mais ne commençant pas par un chiffre) :\nAbcd\rabcd_\rvar123\r_var2\r1nombre\rRecherchez les adresses IPv4 valides (quatre nombres entre 0 et 255, séparés par des points) :\n1.240.40.15\r2.256.20.190\r192.168.255.255\r300.200.100.10\r30.40.50.60\r192.168.2\r10.10.10.10.10",
    "description": "Introduction aux expressions régulières Dans l’univers Linux, la manipulation des fichiers texte est une tâche essentielle. Parmi les outils utilisés pour ce faire, on trouve notamment :\ncat : pour afficher le contenu des fichiers, sed : pour les transformations textuelles, grep : pour rechercher et filtrer des lignes. Avec grep, vous pouvez filtrer un texte pour ne conserver que les lignes contenant un mot ou une expression donnée, ou bien les exclure. Mais comment faire si vous souhaitez rechercher des motifs plus complexes, comme des adresses e-mail ou des numéros de téléphone ? C’est ici qu’interviennent les expressions régulières, un outil puissant pour décrire des motifs précis et identifier des textes ayant une structure particulière.",
    "tags": [],
    "title": "Les expressions régulières",
    "uri": "/semaine6/cours/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Les expressions régulières",
    "content": "Objectif de l’atelier Maîtriser les bases des expressions régulières. Renforcer la capacité à manipuler des fichiers texte. Renforcer la précision dans la recherche et le filtrage de données. Atelier Important\rUtiliser le fichier expr.txt se trouvant sur Moodle. Utiliser seulement la matière vue dans le cours (semaines 1 à 6). Utiliser des expressions régulières courtes et simples au lieu d’expressions complexes et longues. Dans le fichier fourni:\nTrouvez les codes postaux canadiens :\nFormat attendu : Lettre-Chiffre-Lettre Chiffre-Lettre-Chiffre. Identifiez les codes d’employés composés de :\nDeux lettres majuscules suivies de quatre chiffres. Comptez les lignes ne se terminant pas par une lettre :\nIdentifier les numéros de téléphone aux formats : (xxx)xxx-xxxx ou +1(xxx)xxx-xxxx.\nTrouver les URLs comme :\nhttp://www.domaine.tld ou http://www.domaine.tld/ https://www.domaine.tld ou https://www.domaine.tld/ Rechercher des adresses e-mail valides. Elles contiennent : des lettres majuscules ou minuscules, des chiffres et possiblement un ou plusieurs ‘_’ (tiret bas) et un ou plusieurs ‘.’ . Ensuite il y a forcément un ‘@’ puis d’autres caractères (lettres majuscules ou minuscules, chiffres, ‘.’, tiret bas ‘_’) Ensuite il y a obligatoirement un ‘.’ puis pour finir, Entre 2 et 6 lettres minuscules (.qc.ca) et Possiblement un ‘.’ à la fin Dans le fichier /etc/services:\nTrouver les lignes contenant “ssh” sans espace après.\nCompter les lignes totales et celles non vides.\nTrouver les lignes contenant soit udp soit tcp avec un numéro à trois chiffres.\nRechercher les mots de quatre lettres entourés d’espaces.\nIdentifier les mots avec exactement deux “a”.\nDans le fichier /etc/passwd:\nAssurez-vous que toutes les lignes contiennent deux nombres entre “:”.\nCompter les utilisateurs sans bash comme shell.",
    "description": "Objectif de l’atelier Maîtriser les bases des expressions régulières. Renforcer la capacité à manipuler des fichiers texte. Renforcer la précision dans la recherche et le filtrage de données. Atelier Important\rUtiliser le fichier expr.txt se trouvant sur Moodle. Utiliser seulement la matière vue dans le cours (semaines 1 à 6). Utiliser des expressions régulières courtes et simples au lieu d’expressions complexes et longues. Dans le fichier fourni:",
    "tags": [],
    "title": "ATELIER #6: Les expressions régulières",
    "uri": "/semaine6/atelier/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "Plan de la leçon Théorie :\nLes bases de l’utilisation de vim. Les principes de certains fichiers de configuration Linux. Présentation de vim. Atelier :.",
    "description": "Plan de la leçon Théorie :\nLes bases de l’utilisation de vim. Les principes de certains fichiers de configuration Linux. Présentation de vim. Atelier :.",
    "tags": [],
    "title": "Vim et les fichiers de configuration",
    "uri": "/semaine7/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Vim et les fichiers de configuration",
    "content": "L’éditeur de texte VIM Dans les systèmes Linux, la majorité des configurations s’effectuent à l’aide de fichiers texte.\nPour modifier ces fichiers texte, nous utiliserons l’éditeur de texte vim. c’est un éditeur puissant avec de nombreux avantages : • Disponible sur tous les systèmes basés sur UNIX, • Très léger, idéal pour les systèmes sans interface graphique, • Fonctionne en local ou à distance.\nApprendre à utiliser vim est indispensable pour travailler efficacement sous Linux.\nLes principaux modes de VIM vim propose 3 modes principaux pour travailler :\nMode normal (par défaut) : Interprète les touches comme des commandes (ex. copier, supprimer, naviguer). Utilisez la touche Échap (ESC) pour revenir à ce mode à tout moment. Mode visuel : Permet de sélectionner du texte. Activez-le avec : v : pour sélectionner des caractères, V : pour sélectionner des lignes entières. Mode insertion : Permet d’ajouter ou modifier du texte. Activez-le avec : i : insérer à l’endroit du curseur, a : insérer après le curseur, I : insérer au début de la ligne, A : insérer à la fin de la ligne. Navigation dans vim Voici les principales commandes pour se déplacer rapidement :\nAction Commande Un caractère à gauche h Un caractère à droite l Une ligne en bas j Une ligne en haut k Un mot à droite w Un mot à gauche b Début de la ligne 0 Fin de la ligne $ Aller à une ligne précise :numéro (ex. :100) Astuce\rVous pouvez ajouter un quantificateur pour répéter une commande. Exemple : 3w pour avancer de 3 mots, 50j pour descendre de 50 lignes.\nCommandes de base 1. Copier (commande y pour yank)\nÀ copier Commande Une ligne yy Jusqu’à la fin du mot yw Trois lignes 3yy 2. Coller (commande p ou P)\nAction Commande Coller après p minuscule Coller avant P majuscule Exemples avec Copier et Coller\nAction Commande Copier 3 mots y3w Coller 3 fois 3p 3. Modifier du texte\nAction Commande Remplacer un caractère r + (caractère) Remplacer plusieurs caractères R (mode remplacement, taper jusqu’à Échap) 4. Annuler et répéter\nAction Commande Annuler u (undo) Répéter la dernière commande . (point) 5. Supprimer du texte (couper)\na) Supprimer un caractère\nAction Commande Sous le curseur x minuscule Avant le curseur X majuscule b) Autres suppressions\nTexte à supprimer Commande Une ligne dd Jusqu’à la fin du mot dw Jusqu’à la fin de la ligne d$ Fichiers de configuration Linux Sous Linux, les fichiers texte sont utilisés pour gérer la configuration des systèmes. Voici les fichiers les plus courants.\nRéseau Fichier Rôle Exemple /etc/resolv.conf Configure les serveurs DNS nameserver 8.8.8.8 nameserver 8.8.4.4 /etc/hosts Associe des noms de machine à des adresses IP 192.168.1.1 serveur1 Personnalisation du shell Fichier Rôle Exemple ~/.bashrc Permet de créer des alias pour simplifier les commandes alias lh=\"ls -lh\" Autres fichiers utiles Fichier Rôle /etc/selinux/config Configure SELinux (sécurité). /etc/passwd et /etc/group Gèrent les utilisateurs et groupes. /etc/locale.conf Définit la langue du système. /etc/fstab Configure le montage des partitions. /etc/httpd/conf/httpd.conf Configure le serveur Apache. /etc/grub2.cfg Configure le gestionnaire de démarrage.",
    "description": "L’éditeur de texte VIM Dans les systèmes Linux, la majorité des configurations s’effectuent à l’aide de fichiers texte.\nPour modifier ces fichiers texte, nous utiliserons l’éditeur de texte vim. c’est un éditeur puissant avec de nombreux avantages : • Disponible sur tous les systèmes basés sur UNIX, • Très léger, idéal pour les systèmes sans interface graphique, • Fonctionne en local ou à distance.\nApprendre à utiliser vim est indispensable pour travailler efficacement sous Linux.",
    "tags": [],
    "title": "Vim et les fichiers de configuration",
    "uri": "/semaine7/cours/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Vim et les fichiers de configuration",
    "content": "Objectif de l’atelier Approfondir l’utilisation de VIM pour modifier des fichiers de configuration Linux de manière efficace. Modifier des fichiers de configuration Linux efficacement : Utiliser un minimum de touches. Ne pas utiliser la souris. Compléter les exercices : 10 exercices de type A (le curseur est déjà placé). 5 exercices de type B (le curseur commence au début du fichier). Instructions de remise Fournissez les captures d’écran des exercices réussis via Moodle.\nChaque capture doit montrer :\nLa modification effectuée. Le fichier sauvegardé dans l’état final. Exemple de capture attendue :\nUne vidéo de démonstration est disponible :\nAtelier Préparation Installation des outils Créez un fichier vim.sh avec le contenu suivant :\n#!/bin/bash wget http://gyoukou.ca/vimrc.dot || echo ERREUR mv vimrc.dot ~/.vimrc sudo yum install -y epel-release sudo yum install -y meld sudo yum groupinstall -y \"Development Tools\" sudo yum install -y git automake mkdir ~/tmp cd ~/tmp git clone https://github.com/kernc/logkeys.git cd logkeys ./autogen.sh cd build ../configure make sudo make install || echo ERREUR\rExécutez le script pour installer les outils requis :\n$ bash vim.sh\rTéléchargement des exercices Dans votre répertoire personnel, exécutez les commandes suivantes :\n$ cd ~ $ wget http://gyoukou.ca/atelier_06.tar.gz || echo ERREUR $ tar zxvf atelier_06.tar.gz $ cd atelier_06\rExercices de type A (curseur déjà placé) Exercice a01 Fichier de configuration /etc/default/grub\nModification à apporter Avant :\nGRUB_CMDLINE_LINUX=\"rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet\"\rAprès :\nGRUB_CMDLINE_LINUX=\"rd.lvm.lv=centos/root rd.lvm.lv=centos/swap quiet\"\rSupprimez rhgb pour désactiver le démarrage graphique.\nPerformances attendues Record à battre Maximum acceptable 4 touches 9 touches Commandes pour lancer l’exercice $ sh afficher_objectif.sh a01 $ sh exercice_vim.sh a01\rExercice a02 Fichier de configuration /etc/selinux/config\nModification à apporter Avant :\nSELINUX=enforcing\rAprès :\nSELINUX=disabled\rDésactivez SELinux.\nPerformances attendues Record à battre Maximum acceptable 7 touches 25 touches Commandes pour lancer l’exercice $ sh afficher_objectif.sh a02 $ sh exercice_vim.sh a02\rRépétez cette structure pour les autres exercices.\nExercices de type B (curseur au début du fichier) Exercice b01 Fichier de configuration /etc/ssh/sshd_config\nModification à apporter Avant :\n#X11Forwarding yes Après :\nX11Forwarding yes\rDécommentez la ligne pour activer la redirection graphique.\nPerformances attendues Record à battre Maximum acceptable 7 touches 18 touches Commandes pour lancer l’exercice $ sh afficher_objectif.sh b01 $ sh exercice_vim.sh b01\rContinuez avec cette structure pour les exercices restants.\n=====================================================\nAtelier 7b: vim avancé Cet atelier et l’atelier précédent forment l’atelier 7.\nObjectif Effectuer efficacement des modifications à des fichiers de configuration Linux NOTE: efficacement veut dire en moins de X touches, sans utiliser la souris Vous devez réussir: 10 exercices de type A (curseur déjà placé) 5 exercices de type B (curseur au début du fichier) Remise À remettre sur Moodle: Les captures d’écran:\nChaque capture d’écran correspond à un exercice réussi, p.ex:\nVoici un exemple d’exercice réussi: Voici comment l’exercice ci-haut s’est déroulé:\nAstuces: Utilisez ZZ pour sauvegarder et quitter dans vim.\nUtilisez les commandes données dans les images Aide mémoire en fin du cours pour avoir le record.\nTravail à effectuer Préambule Installation des outils nécessaires Copiez le texte suivant dans un script nommé vim.sh\n#!/bin/bash wget http://gyoukou.ca/vimrc.dot || echo ERREUR mv vimrc.dot ~/.vimrc sudo yum install -y epel-release sudo yum install -y meld sudo yum groupinstall -y \"Development Tools\" sudo yum install -y git automake mkdir ~/tmp cd ~/tmp git clone https://github.com/kernc/logkeys.git cd logkeys ./autogen.sh cd build ../configure make sudo make install || echo ERREUR\rExécutez le script :\n$ bash vim.sh\rTélécharger et décompresser les exercices # IMPORTANT: cd ~ pour aller dans votre répertoire ~\r$ cd ~\r$ wget http://gyoukou.ca/atelier_06.tar.gz || echo ERREUR\r$ tar zxvf atelier_06.tar.gz\r$ cd atelier_06\rExercices A: le curseur est déjà placé IMPORTANT: ne pas éditer directement les vrais fichiers de configuration. Editer plutôt la copie qui se trouve dans le dossier atelier téléchargé Exercice a01 Fichier de configuration /etc/default/grub\nConfiguration de grub (outil de démarrage) En particulier: options à donner au noyau Linux au démarrage Modification à apporter AVANT:\n1GRUB_CMDLINE_LINUX=\"rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet\"\rAPRÈS:\n1GRUB_CMDLINE_LINUX=\"rd.lvm.lv=centos/root rd.lvm.lv=centos/swap quiet\"\rEnlever rhgb désactive le démarrage graphique au profit de l’affichage d’un log (rhgb signifie Red Hat Graphical Boot) Nombre de touches Record à battreMaximum acceptable4 touches9\rtouches\rPour visualiser avec meld et lancer l’exercice $ sh afficher_objectif.sh a01\r$ sh exercice_vim.sh a01\rExercice a02 Fichier de configuration /etc/selinux/config\nselinux est un pare-feu d’application qui permet de contrôler ou limiter un grand nombre d’opérations sur un serveur Linux (selinux veut dire Security Enhanced Linux) Modification à apporter AVANT:\n1SELINUX=enforcing\rAPRÈS:\n1SELINUX=disabled\rOn déscative selinux (généralement préférable sur une machine usager) Nombre de touches Record à battreMaximum acceptable7 touches25\rtouches\rPour visualiser avec meld et lancer l’exercice $ sh afficher_objectif.sh a02\r$ sh exercice_vim.sh a02\rExercice a03 Fichier de configuration /etc/fstab\nListe des partitions utilisées dans le système Par défaut, chaque partition est montée au démarrage Modification à apporter AVANT:\n1/dev/mapper/centos-tmp /tmp xfs defaults 0 0\rAPRÈS:\nEn retirant une ligne, on efface la définition d’une partition Le répertoire /tmp devient un sous-répertoire de / (partition centos-root) Nombre de touches Record à battreMaximum acceptable4 touches6\rtouches\rPour visualiser avec meld et lancer l’exercice $ sh afficher_objectif.sh a03\r$ sh exercice_vim.sh a03\rExercice a04 Fichier de configuration /etc/locale.conf\nRégionalisation du système: langue, date, etc. Modification à apporter AVANT:\n1LC_TIME=\"\"\rAPRÈS:\n1LC_TIME=\"fr_CA.UTF-8\"\rOn veut copier fr_CA.UTF-8 entre les \" afin de définir aussi le format de date Nombre de touches Record à battreMaximum acceptable8 touches18\rtouches\rPour visualiser avec meld et lancer l’exercice $ sh afficher_objectif.sh a04\r$ sh exercice_vim.sh a04\rExercice a05 Fichier de configuration /etc/mime.types\nDéfinition des types de fichier et de leur extensions NOTE: la commande file affiche le type d’un fichier Modification à apporter AVANT:\n1application/3gpp-ims+xml 2application/activemessage 3application/andrew-inset\rAPRÈS:\n1application/3gpp-ims+xml\tinconnu 2application/activemessage\tinconnu 3application/andrew-inset\tinconnu\rOn ajoute l’extension inconnu pour les trois premiers types de fichier NOTE: il y a trois tabulations entre le type et l’extension Nombre de touches Record à battreMaximum acceptable18 touches40\rtouches\rPour visualiser avec meld et lancer l’exercice $ sh afficher_objectif.sh a05\r$ sh exercice_vim.sh a05\rExercice a06 Fichier de configuration /etc/hosts\nAssocie un nom réseau à son adresse Pour ces noms, le système ne fera pas de requête DNS (aussi avantageux pour faire des tests) NOTE: ce fichier existe aussi en Windows Modification à apporter AVANT:\n1206.167.24.30 ciboulot.ca 2#172.17.0.30 ciboulot.ca APRÈS:\n1#206.167.24.30 ciboulot.ca 2172.17.0.30 ciboulot.ca\rOn met en commentaire l’adresse publique de ciboulot.ca On active l’adresse locale (seulement valide au Collège) Nombre de touches Record à battreMaximum acceptable6 touches12\rtouches\rPour visualiser avec meld et lancer l’exercice $ sh afficher_objectif.sh a06\r$ sh exercice_vim.sh a06\rExercice a07 Fichier de configuration /etc/firewalld/direct.xml\nRègles de pare-feu directes (écrites à la main) NOTE: l’autre option est de générer les règles via la commande firewall-cmd Modification à apporter AVANT:\n1 \u003crule priority=\"0\" table=\"filter\" ipv=\"ipv4\" chain=\"FORWARD\"\u003e-i PRIVE -o PUBLIC -j ACCEPT\u003c/rule\u003e 2 \u003crule priority=\"0\" table=\"filter\" ipv=\"ipv4\" chain=\"FORWARD\"\u003e-i PUBLIC -o PRIVE -m state --state RELATED,ESTABLISHED -j ACCEPT\u003c/rule\u003e 3 \u003crule priority=\"0\" table=\"nat\" ipv=\"ipv4\" chain=\"POSTROUTING\"\u003e-o PUBLIC -j MASQUERADE\u003c/rule\u003e\rAPRÈS:\n1 \u003crule priority=\"0\" table=\"filter\" ipv=\"ipv4\" chain=\"FORWARD\"\u003e-i 192.168.1.4 -o 10.33.50.3 -j ACCEPT\u003c/rule\u003e 2 \u003crule priority=\"0\" table=\"filter\" ipv=\"ipv4\" chain=\"FORWARD\"\u003e-i 10.33.50.3 -o 192.168.1.4 -m state --state RELATED,ESTABLISHED -j ACCEPT\u003c/rule\u003e 3 \u003crule priority=\"0\" table=\"nat\" ipv=\"ipv4\" chain=\"POSTROUTING\"\u003e-o 10.33.50.3 -j MASQUERADE\u003c/rule\u003e\rOn insère des vraies adresses IP à partir d’un patron NOTE: ces règles indique au système de faire du NAT Nombre de touches Record à battreMaximum acceptable37 touches120\rtouches\rPour visualiser avec meld et lancer l’exercice $ sh afficher_objectif.sh a07\r$ sh exercice_vim.sh a07\rExercice a08 Fichier de configuration ~/.bashrc\nPersonnalisation du SHELL Fichier lu à chaque ouverture du SHEL Modification à apporter AVANT:\nAPRÈS:\n1alias la=\"ls -a\"\rOn ajoute la ligne pour créer un alias NOTE: un alias est un raccourci pour une commande fréquemment utilisée. Nombre de touches Record à battreMaximum acceptable12 touches22\rtouches\rPour visualiser avec meld et lancer l’exercice $ sh afficher_objectif.sh a08\r$ sh exercice_vim.sh a08\rExercice a09 Fichier de configuration /etc/resolv.conf\nLe ou les serveur DNS à utiliser Modification à apporter AVANT:\n1nameserver 10.33.50.1\rAPRÈS:\n1nameserver 192.168.1.1\rOn change l’adresse DNS à 192.168.1.1 Nombre de touches Record à battreMaximum acceptable14 touches35 touches\rPour visualiser avec meld et lancer l’exercice $ sh afficher_objectif.sh a09\r$ sh exercice_vim.sh a09\rExercice a10 Fichier de configuration /etc/ssh/sshd_config\nConfiguration du serveur SSH Modification à apporter AVANT:\n1#X11Forwarding yes APRÈS:\n1X11Forwarding yes\rCertaines options sont déjà inscrites au fichier. Pour les activer, il suffit de les décommenter Ici, on active la redirection graphique Nombre de touches Record à battreMaximum acceptable3 touches8 touches\rPour visualiser avec meld et lancer l’exercice $ sh afficher_objectif.sh a10\r$ sh exercice_vim.sh a10\rExercices B: le curseur est au début du fichier IMPORTANT: ne pas éditer directement le fichier\nExercice b01 Fichier de configuration /etc/ssh/sshd_config\nConfiguration du serveur SSH Modification à apporter AVANT:\n1#X11Forwarding yes APRÈS:\n1X11Forwarding yes\rMême modification que a10, sauf que cette fois-ci le curseur n’est pas déjà placé Nombre de touches Record à battreMaximum acceptable7 touches18 touches\rPour visualiser avec meld et lancer l’exercice $ sh afficher_objectif b01\r$ sh exercice_vim.sh b01\rExercice b02 Fichier de configuration /etc/default/grub\nConfiguration de grub (outil de démarrage) En particulier: options à donner au noyau Linux au démarrage Modification à apporter AVANT:\n1GRUB_CMDLINE_LINUX=\"rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet\"\rAPRÈS:\n1GRUB_CMDLINE_LINUX=\"rd.lvm.lv=centos/root rd.lvm.lv=centos/swap quiet\"\rMême modification que a01, sauf que le curseur n’est pas déjà placé Nombre de touches Record à battreMaximum acceptable8 touches20 touches\rPour visualiser avec meld et lancer l’exercice $ sh afficher_objectif b02\r$ sh exercice_vim.sh b02\rExercice b03 Fichier de configuration /etc/services\nListe des services réseau, protocoles et ports Modification à apporter AVANT:\n1systat 11/tcp users 2systat 11/udp users 3daytime 13/tcp 4daytime 13/udp 5qotd 17/tcp quote 6qotd 17/udp quote 7msp 18/tcp # message send protocol (historic) 8msp 18/udp # message send protocol (historic) 9chargen 19/tcp ttytst source 10chargen 19/udp ttytst source 11ftp-data 20/tcp\rAPRÈS:\nEffacer les services du ports 11 jusqu’au port 20 (inclusif) Nombre de touches Record à battreMaximum acceptable11 touches28 touches\rPour visualiser avec meld et lancer l’exercice $ sh afficher_objectif b03\r$ sh exercice_vim.sh b03\rExercice b04 Fichier de configuration /etc/passwd\nInformation sur les usagers Linux Modification à apporter AVANT:\n1gnome-initial-setup:x:984:977::/run/gnome-initial-setup/:/sbin/nologin 2tcpdump:x:72:72::/:/sbin/nologin 3avahi:x:70:70:Avahi mDNS/DNS-SD Stack:/var/run/avahi-daemon:/sbin/nologin 4apache:x:48:48:Apache:/usr/share/httpd:/sbin/nologin\rAPRÈS:\nOn efface les 4 dernières lignes NOTE: habituellement, ces lignes sont effacées par la commande userdel Nombre de touches Record à battreMaximum acceptable6 touches15 touches\rPour visualiser avec meld et lancer l’exercice $ sh afficher_objectif b04\r$ sh exercice_vim.sh b04\rExercice b05 Fichier de configuration /etc/group\nListe des groupes d’usagers Linux Chaque usager est membre de son propre groupe Un usager membre d’un autre groupe obtient des droits supplémentaires Modification à apporter AVANT:\n1wheel:x:10:\rAPRÈS:\n1wheel:x:10:mbergeron\rOn ajoute l’usager mbergeron au groupe wheel Le groupe wheel est le groupe qui peut faire la commande sudo Nombre de touches Record à battreMaximum acceptable10 touches25 touches\rPour visualiser avec meld et lancer l’exercice $ sh afficher_objectif b05\r$ sh exercice_vim.sh b05",
    "description": "Objectif de l’atelier Approfondir l’utilisation de VIM pour modifier des fichiers de configuration Linux de manière efficace. Modifier des fichiers de configuration Linux efficacement : Utiliser un minimum de touches. Ne pas utiliser la souris. Compléter les exercices : 10 exercices de type A (le curseur est déjà placé). 5 exercices de type B (le curseur commence au début du fichier). Instructions de remise Fournissez les captures d’écran des exercices réussis via Moodle.",
    "tags": [],
    "title": "ATELIER #7: VIM et les fichiers de configuration (À MODIFIER)",
    "uri": "/semaine7/atelier/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e DNF et CRON",
    "content": "Planification des tâches avec cron Cron est un outil qui permet de planifier et d’automatiser des tâches sur un système Linux. Chaque utilisateur peut définir ses propres tâches planifiées.\nPoints essentiels : Les tâches planifiées par un utilisateur sont stockées dans le fichier :\n/var/spool/cron/\u003cuser\u003e Le démon responsable de l’exécution des tâches planifiées s’appelle : crond On peut planifier des tâches complexes grâce aux nombreuses options disponibles. Commandes de base pour gérer les tâches planifiées Afficher la liste des tâches planifiées :\ncrontab -l\rSupprimer toutes les tâches planifiées :\ncrontab -r\rModifier les tâches d’un autre utilisateur (nécessite les droits root) :\ncrontab -u \u003cutilisateur\u003e\rImporter un fichier contenant des tâches planifiées :\ncrontab \u003cfichier\u003e\r⚠️ Chaque import écrase toutes les tâches existantes.\nModifier ou créer des tâches (commande la plus courante) :\ncrontab -e\rSyntaxe d’une tâche cron Une tâche dans une crontab se compose de deux parties :\nLa planification : Décrit quand la tâche doit s’exécuter (5 champs). La commande ou script à exécuter : Peut être une commande bash. Recommandation : utilisez un script, spécifié avec son chemin absolu. Exemple d’une crontab :\n15 * * * * bash /home/user/monscript.sh 30 0 * * * bash /usr/local/bin/autrescript.sh 0 * * * * echo \"Nouvelle heure\" \u003e\u003e /home/user/heure.txt\rLes erreurs de syntaxe dans le fichier crontab sont détectées au moment de l’enregistrement. Si une tâche génère des erreurs lors de l’exécution, elles sont enregistrées dans :\n/var/mail/\u003cuser\u003e\nComprendre la planification La planification utilise 5 champs :\nMinutes Heures Jour du mois Mois Jour de la semaine 0-59 0-23 1-31 1-12 0-7 (dimanche à dimanche) Symboles utiles * : Tous les moments possibles (ex. : toutes les heures). , : Énumération de valeurs (ex. : 1,5,6). - : Intervalle de valeurs (ex. : 1-10). */n : Sauts réguliers (ex. : */2 toutes les 2 heures). Exemples de planifications Tous les jours à 14h30 : 30 14 * * * bash /chemin/script.sh\rChaque heure (25ème minute) en mars uniquement : 25 * * 3 * bash /chemin/script.sh\rLundi, mercredi et vendredi à midi : 0 12 * * 1,3,5 bash /chemin/script.sh\rGestion des paquets avec dnf DNF est un gestionnaire de paquets pour les systèmes basés sur Red Hat (comme AlmaLinux). Il simplifie :\nL’installation. La mise à jour. La suppression de logiciels. Contrairement à l’installation manuelle ou avec des fichiers RPM, dnf gère automatiquement les dépendances.\nCommandes de base Rechercher un paquet Rechercher un paquet par nom ou description :\ndnf search \u003cmot-clé\u003e\rVérifier si un fichier ou commande fait partie d’un paquet :\ndnf provides \u003cfichier/commande\u003e\rInstallation d’un paquet Pour installer un paquet :\nsudo dnf install \u003cnom_du_paquet\u003e\rMettre à jour un paquet ou tout le système Mettre à jour un paquet spécifique : sudo dnf update \u003cnom_du_paquet\u003e\rMettre à jour tous les paquets installés : sudo dnf update\rSupprimer un paquet Pour désinstaller un paquet :\nsudo dnf remove \u003cnom_du_paquet\u003e\rGestion des dépôts Les dépôts sont des serveurs qui contiennent des paquets. Ils sont configurés dans :\n/etc/yum.repos.d\nCommandes utiles Lister les dépôts actifs : dnf repolist\rLister tous les dépôts (actifs ou non) : dnf repolist all\rAjouter un nouveau dépôt Par exemple, pour ajouter le dépôt remi :\nsudo dnf install -y https://rpms.remirepo.net/enterprise/remi-release-9.rpm\rGestion des groupes de paquets Certaines applications ou environnements sont regroupés en groupes pour simplifier leur gestion.\nCommandes importantes Lister les groupes disponibles :\ndnf grouplist\rInstaller un groupe :\nExemple pour installer l’environnement Xfce :\nsudo dnf groupinstall \"Xfce\"\rObtenir des informations sur un groupe :\ndnf groupinfo \"\u003cnom_du_groupe\u003e\"\rAutomatisation avec le shell dnf Le shell dnf permet d’exécuter plusieurs commandes à la suite.\nCréer un fichier avec les commandes (ex. : installations.txt) :\ninstall nmap install zsh run\rExécuter le fichier avec dnf :\ndnf shell installations.txt",
    "description": "Planification des tâches avec cron Cron est un outil qui permet de planifier et d’automatiser des tâches sur un système Linux. Chaque utilisateur peut définir ses propres tâches planifiées.\nPoints essentiels : Les tâches planifiées par un utilisateur sont stockées dans le fichier :\n/var/spool/cron/\u003cuser\u003e Le démon responsable de l’exécution des tâches planifiées s’appelle : crond On peut planifier des tâches complexes grâce aux nombreuses options disponibles. Commandes de base pour gérer les tâches planifiées Afficher la liste des tâches planifiées :",
    "tags": [],
    "title": "CRON et DNF",
    "uri": "/semaine8/cours/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e WSL installation et manipulation (Ubuntu, VS Code)",
    "content": "+++ title = “Installation et manipulation de WSL avec Ubuntu et VS Code” weight = 141 +++\nLe Windows Subsystem for Linux (WSL) est une fonctionnalité de Windows qui permet d’exécuter un environnement Linux directement sur un système Windows sans avoir besoin d’une machine virtuelle.\nNous allons voir comment installer et utiliser WSL avec Ubuntu et Visual Studio Code (VS Code).\nPrérequis Un PC sous Windows 10 (version 2004 ou ultérieure) ou Windows 11. Accès à une connexion Internet. 1. Activation de WSL Activer les fonctionnalités Windows :\nOuvrez “Panneau de configuration” \u003e “Programmes” \u003e “Activer ou désactiver des fonctionnalités Windows”. Cochez les cases suivantes : Sous-système Windows pour Linux Plateforme de machine virtuelle Cliquez sur “OK” et redémarrez votre PC. Installer WSL 2 :\nOuvrez PowerShell en mode administrateur. Exécutez la commande suivante pour définir WSL 2 comme version par défaut : wsl --set-default-version 2\r2. Installation d’Ubuntu sur WSL Installer Ubuntu :\nOuvrez le Microsoft Store. Recherchez “Ubuntu” et choisissez une version (par ex., “Ubuntu 22.04 LTS”). Cliquez sur “Installer”. Configurer Ubuntu :\nLancez l’application Ubuntu depuis le menu Démarrer. Créez un utilisateur et un mot de passe lors du premier démarrage. 3. Installation de Visual Studio Code Installer VS Code :\nTéléchargez et installez Visual Studio Code depuis le site officiel : code.visualstudio.com. Installer l’extension WSL :\nOuvrez VS Code. Accédez à l’onglet des extensions (icône de carré à gauche ou Ctrl+Shift+X). Recherchez et installez l’extension Remote - WSL. 4. Configuration de l’environnement Accéder à WSL depuis VS Code :\nLancez Ubuntu (WSL) et naviguez jusqu’à votre répertoire de projet ou créez-en un : mkdir mon_projet\rcd mon_projet\rTapez code . pour ouvrir VS Code directement dans ce répertoire. Configurer le terminal :\nDans VS Code, allez dans Fichier \u003e Préférences \u003e Paramètres. Recherchez “terminal.integrated.defaultProfile.windows” et sélectionnez “WSL” comme terminal par défaut. 5. Manipulation de l’environnement Ubuntu dans WSL Installer des outils de développement :\nUtilisez apt pour installer des packages : sudo apt update\rsudo apt install build-essential git curl\rCloner un projet Git :\nUtilisez la commande suivante pour cloner un projet : git clone https://github.com/utilisateur/projet.git\rExécuter un projet :\nPar exemple, pour un projet Node.js : sudo apt install nodejs npm\rnpm install\rnpm start\r6. Conseils et Astuces Partage de fichiers entre Windows et WSL : Les fichiers créés sous WSL sont accessibles dans l’explorateur Windows sous : \\\\wsl$\\Ubuntu\\. Performances : Pour des performances optimales, stockez vos fichiers de projet dans le système de fichiers Linux (dans WSL) plutôt que dans le système de fichiers Windows. Mises à jour : Pensez à mettre à jour régulièrement WSL et Ubuntu : sudo apt update \u0026\u0026 sudo apt upgrade\rConclusion Avec WSL, Ubuntu et VS Code, vous disposez d’un environnement puissant pour le développement sous Linux, tout en conservant la commodité de Windows.",
    "description": "+++ title = “Installation et manipulation de WSL avec Ubuntu et VS Code” weight = 141 +++\nLe Windows Subsystem for Linux (WSL) est une fonctionnalité de Windows qui permet d’exécuter un environnement Linux directement sur un système Windows sans avoir besoin d’une machine virtuelle.\nNous allons voir comment installer et utiliser WSL avec Ubuntu et Visual Studio Code (VS Code).\nPrérequis Un PC sous Windows 10 (version 2004 ou ultérieure) ou Windows 11. Accès à une connexion Internet. 1. Activation de WSL Activer les fonctionnalités Windows :",
    "tags": [],
    "title": "WSL installation et manipulation (Ubuntu, VS Code)",
    "uri": "/semaine14/cours/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Solutions de ateliers",
    "uri": "/solutions/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Solutions de ateliers",
    "content": "Capture d’écran prouvant la réussite de l’installation d’AlmaLinux sur VMware.\nLa capture d’écran doit montrer\nLa fenêtre du Terminal. Votre nom d’utilisateur standard. Votre nom complet écrit sur la ligne de commande. Exemple:",
    "description": "Capture d’écran prouvant la réussite de l’installation d’AlmaLinux sur VMware.\nLa capture d’écran doit montrer\nLa fenêtre du Terminal. Votre nom d’utilisateur standard. Votre nom complet écrit sur la ligne de commande. Exemple:",
    "tags": [],
    "title": "Atelier 1",
    "uri": "/solutions/semaine1/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Solutions de ateliers",
    "content": "Solution des exercices Exercice 1 : Explorer l’arborescence Linux Afficher le chemin de votre répertoire courant :\n$ pwd\rAller dans /usr/share/doc et vérifier le chemin :\n$ cd /usr/share/doc $ pwd\rRemonter dans le répertoire parent :\n$ cd .. $ pwd\rRetourner dans le répertoire personnel :\n$ cd ~ $ pwd\rLister les fichiers présents dans le répertoire courant :\n$ ls\rLister les fichiers du répertoire /usr :\n$ ls /usr\rExercice 2 : Commandes Linux simples Afficher la date et l’heure actuelles :\n$ date $ date +\"%r\"\rAfficher les 10 premières lignes de /etc/services :\n$ head /etc/services\rAfficher les 10 dernières lignes de /etc/services :\n$ tail /etc/services\rRépéter la commande précédente en trois frappes :\n$ tail /etc/services # (Utilisez la flèche \"haut\" pour la rappeler)\rAfficher les 20 dernières lignes :\n$ tail -n 20 /etc/services\rRéutiliser l’historique pour afficher l’heure :\n$ history $ !\u003cnuméro de la commande date +\"%r\"\u003e\rExercice 3 : Commandes de base Créer le répertoire Atelier2 :\n$ mkdir Atelier2\rCopier le fichier fichier.txt dans Atelier2 :\n$ cp fichier.txt Atelier2/\rCréer le répertoire Rep2 :\n$ mkdir Rep2\rDéplacer Atelier2 dans Rep2 :\n$ mv Atelier2 Rep2/\rSe déplacer dans Atelier2 :\n$ cd Rep2/Atelier2\rModifier fichier.txt avec vim :\n$ vim fichier.txt\r(Écrire votre nom complet, enregistrer et quitter avec :wq).\nAfficher le contenu de fichier.txt :\n$ cat fichier.txt\rCréer fichier2.txt :\n$ touch fichier2.txt\rAfficher le contenu des deux fichiers avec cat :\n$ cat fichier.txt fichier2.txt\rRevenir dans le répertoire personnel :\n$ cd ~\rSupprimer le répertoire Rep2 :\n$ rm -r Rep2\rAfficher le répertoire courant :\n$ pwd\rCréer Rep3 dans /root :\n$ mkdir /root/Rep3\r(Peut échouer sans sudo).\nLister le contenu de /etc avec -l :\n$ ls -l /etc\rIdentifier les caractères au début des lignes : (Réponse : d pour répertoire, - pour fichier, l pour lien symbolique).\nDifférence de /proc : (Réponse : Contient des fichiers virtuels donc éphémères, représentant des informations sur le système).\nDifférence entre /bin et /sbin : (Réponse : /bin contient des binaires pour tous les utilisateurs, /sbin est réservé à l’administration).\nRépertoire du noyau : (Réponse : /boot).\nRépertoire pour une clé USB : (Réponse : /media ou /mnt).\nRépertoire pour Apache : (Réponse : /etc/apache2 ou /etc/httpd, selon la distribution).",
    "description": "Solution des exercices Exercice 1 : Explorer l’arborescence Linux Afficher le chemin de votre répertoire courant :\n$ pwd\rAller dans /usr/share/doc et vérifier le chemin :\n$ cd /usr/share/doc $ pwd\rRemonter dans le répertoire parent :\n$ cd .. $ pwd\rRetourner dans le répertoire personnel :\n$ cd ~ $ pwd\rLister les fichiers présents dans le répertoire courant :\n$ ls\rLister les fichiers du répertoire /usr :",
    "tags": [],
    "title": "Atelier 2",
    "uri": "/solutions/semaine2/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux \u003e Solutions de ateliers",
    "content": "Solution des exercices Exercice 1 : Niveaux d’exécution Modifier le niveau d’exécution par défaut de votre machine virtuelle (VM) pour passer en mode multi-utilisateurs sans interface graphique. $ systemctl set-default multi-user\rRedémarrer la VM pour appliquer les changements à l’aide de la commande shutdown -r now. $ shutdown -r now\rou\n$ systemctl reboot\rAprès le redémarrage, se connecter à votre VM . Vérifier que l’interface graphique ne démarre pas. Si au redémarrage vous êtes en mode graphique…\rCela signifie qu’à la question #1, vous n’avez pas changé le mode par défaut (permanent), mais vous avez changé temporairement le mode en utilisant isolate. Le système étant configuré pour démarrer en mode graphique (graphical.target) par défaut, c’est lui qui reprend au redémarrage.\nUtiliser une commande systemctl pour connaître le niveau d’exécution actuel.\n$ systemctl get-default\rPourquoi get-default ?\rSi le default.target est différent du target réellement actif, cela signifie que le système fonctionne temporairement sous un autre niveau (par exemple, après une modification manuelle avec systemctl isolate ou en raison d’un problème au démarrage).\nou\n$ who -r\rou\n$ runlevel\rRétablir le mode graphique par défaut. N’oubliez pas de redémarrer la VM pour que les changements soient pris en compte. $ systemctl set-default graphical\rExercice 2 : Caractères génériques et commande find Aller dans le répertoire /etc. Notez qu’il est demandé de ne pas se déplacer pour le reste de cet exercice. $ cd /etc\rUtiliser la commande find pour rechercher les fichiers dont le nom commence par la lettre r dans le répertoire courant. $ find . -name \"r*\"\rUtiliser la commande find pour rechercher les fichiers contenant la chaîne rc dans le répertoire courant. $ find . -name \"*rc*\"\rUtiliser la commande find pour rechercher les fichiers dont le nom comporte exactement trois caractères sur l’ensemble du système de fichiers (à partir de la racine). $ find / -name \"???\"\rExercice 3 : Expansion d’accolades et boucle for Important\rAssurez-vous d’être revenu dans votre répertoire personnel avant de commencer cet exercice.\n$ cd ~\rUtiliser l’expansion d’accolades pour créer l’arborescence de dossiers suivante en une seule commande. $ mkdir -p coursLinux/semaine{1..5}/l{econ,ab}\rou\n$ mkdir -p coursLinux/semaine{1..5}/{lecon,lab}\rou\n$ mkdir -p coursLinux/semaine{1..5}/lab coursLinux/semaine{1..5}/lecon $ tree coursLinux\rToujours en utilisant l’expansion d’accolades, créer un fichier vide nommé priseNote dans chaque répertoire lab en une seule commande. $ touch coursLinux/semaine{1..5}/lab/priseNote\rUtiliser une boucle for pour renommer tous les fichiers priseNote en priseNote.txt. $ for i in coursLinux/semaine{1..5}/lab/priseNote; do mv \"$i\" \"$i.txt\"; done\rUtiliser une boucle for pour déplacer les fichiers priseNote.txt des répertoires lab vers les répertoires lecon correspondants. $ for i in coursLinux/semaine{1..5}; do mv $i/lab/priseNote.txt $i/lecon; done ou\n$ for i in {1..5}; do mv ./coursLinux/semaine$i/lab/priseNote.txt ./coursLinux/semaine$i/lecon;done",
    "description": "Solution des exercices Exercice 1 : Niveaux d’exécution Modifier le niveau d’exécution par défaut de votre machine virtuelle (VM) pour passer en mode multi-utilisateurs sans interface graphique. $ systemctl set-default multi-user\rRedémarrer la VM pour appliquer les changements à l’aide de la commande shutdown -r now. $ shutdown -r now\rou\n$ systemctl reboot\rAprès le redémarrage, se connecter à votre VM . Vérifier que l’interface graphique ne démarre pas. Si au redémarrage vous êtes en mode graphique…\rCela signifie qu’à la question #1, vous n’avez pas changé le mode par défaut (permanent), mais vous avez changé temporairement le mode en utilisant isolate. Le système étant configuré pour démarrer en mode graphique (graphical.target) par défaut, c’est lui qui reprend au redémarrage.",
    "tags": [],
    "title": "Atelier 3",
    "uri": "/solutions/semaine3/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/categories/index.html"
  },
  {
    "breadcrumb": "420-ZG4-MO Système d’exploitation Linux",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/tags/index.html"
  }
]
